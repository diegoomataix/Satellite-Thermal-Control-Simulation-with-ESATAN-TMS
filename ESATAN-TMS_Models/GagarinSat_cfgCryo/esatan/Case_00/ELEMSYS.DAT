########################################
#                                      #
#   ESATAN/FHTS system elements file   #
#                                      #
########################################
#
# $Id: ELEMSYS.DAT 1.85 2009/01/12 10:49:35GMT jstrutt Released  $
#
# Copyright (c) 2004-2007 ITP Engines UK Ltd.
#
##############################################
##############################################
#
$MODEL ACCP
#
# Accumulator model - constant pressure J type node
#  Mandatory data is AFD and AVOL or AFL
#
$DEFAULTS
AFX=0.0; AFY=0.0; AFZ=0.0; # Default coordinates
AFST = 'P&T' ;    # )
AP = 0.0 ;        # )
AT = 0.0 ;        # > Default fluid state
AFE = 0.0 ;       # )
AVQ = 0.0 ;       # )
AFF = 0.0 ;       # Switch off internal correlation for friction Dp
AFLA = RL2 ;      # Area of circle diameter FD
AA = RL4 ;        # Surface area of cylinder diameter FD
AVOL = 0.0 ;      # Volume defaults to 0.0 (length must be specified)
AFL = RL3 / RL2 ; # Length = Volume / flow area
#
$LOCALS
#
# Note Flow area and volume need to be defined prior to heat transfer
#    area to avoid FL being undefined if VOL and FD specified
#
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %AFD% * %AFD% / 4.0 ;  # Flow area
RL3 = %AVOL% ;                     # Volume
RL4 = RL1 * %AFD% * %AFL% ;        # Heat transfer area
#
$NODES
#
J1, A = %AA%, FD = %AFD% , FL = %AFL%, FLA = %AFLA%,
    FST = %AFST%, T = %AT%, P = %AP%, FE = %AFE%, VQ = %AVQ%,
    FF = %AFF%, FX = %AFX%, FY = %AFY%, FZ = %AFZ%;
#
$ENDMODEL ACCP
$MODEL ACCPT
#
# Accumulator model - constant pressure and enthalpy R type node
#  Mandatory data is AFD and AVOL or AFL
#
$DEFAULTS
AFX=0.0 ;         # )
AFY=0.0 ;         # > Default coordinates
AFZ=0.0 ;         # )
AFST = 'P&T' ;    # )
AP = 0.0 ;        # )
AT = 0.0 ;        # > Default fluid state
AFE = 0.0 ;       # )
AVQ = 0.0 ;       # )
AFF = 0.0 ;       # Switch off internal frictional DP calc
AFLA = RL2 ;      # Area of circle diameter FD
AA = RL4 ;        # Surface area of cylinder diameter FD
AVOL = 0.0 ;      # Volume defaults to 0.0 (length must be specified)
AFL = RL3 / RL2 ; # Length = Volume / flow area
#
$LOCALS
#
# Note Flow area and volume need to be defined prior to heat transfer
#    area to avoid FL being undefined if VOL and FD specified
#
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %AFD% * %AFD% / 4.0 ;  # Flow area
RL3 = %AVOL% ;                     # Volume
RL4 = RL1 * %AFD% * %AFL% ;        # Heat transfer area
#
$NODES
#
R1, A = %AA%, FD = %AFD% , FL = %AFL%, FLA = %AFLA%,
    FST = %AFST%, T = %AT%, P = %AP%, FE = %AFE%, VQ = %AVQ%,
    FF = %AFF%, FX = %AFX%, FY = %AFY%, FZ = %AFZ%;
#
$ENDMODEL ACCPT
$MODEL ACTA
#
# Active accumulator
#
# Origin: FHTS Upgrade 1 9197/90/NL/PP: ERC/92:4:11/JHS
#
$DEFAULTS
AFX=0.0 ; AFY=0.0 ; AFZ=0.0; # Default coordinates
AFST = 'P&T';           # Fluid state descriptor
AVQ = 0.0;              # Vapour quality
AP = 0.0;               # Fluid pressure
AT = 0.0;               # Fluid temperature
AFE = 0.0;              # Fluid enthalpy
AFLA = RL2;             # Flow area
AA = RL3;               # Heat transfer area
SPEED = 0.0;            # Piston speed
PPOS = 0.5;             # Piston position
#
$LOCALS
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %AFD% * %AFD% / 4.0 ;         # Flow area
RL3 = 4.0 * %PPOS% * %VOLACC% / %AFD%;    # Heat transfer area
#
$NODES
#
# Nodal length calculated from the volume within $INITIAL -
#    Note that the solution updates the length from the volume.
#
F1, A = %AA%, FD = %AFD%, FLA = %AFLA%, FL = 0.0,
    FST = %AFST%, T = %AT%, P = %AP%, FE = %AFE%, VQ = %AVQ%,
    FF = 0.0, FX = %AFX% , FY = %AFY% , FZ = %AFZ% ;
#
$CONSTANTS
#
$REAL
PPOS = %PPOS%;          # Position of piston
SPEED = %SPEED%;        # Speed of piston
#
$INITIAL
#
# Set to length changing
#
      CALL VOLST(F1 , 'L')
#
      FL1 = %PPOS% * %VOLACC% / FLA1
#
$VARIABLES1
#
# Update piston position
#
      PPOS = VOL1 / %VOLACC%
#
      VDT1 = SPEED * FLA1

#
$ENDMODEL ACTA
$MODEL CAPFILTER
#
#   Capillary filter pressure loss
#
$DEFAULTS
#
CAI    = RL12; CAO   = RL13;  # default to area of a cylinder
CFLAI  = RL4 ; CFLAO = RL5 ;  # default to circular pipe
CFXI   = 0.0 ; CFXO  = 0.0 ;  # )
CFYI   = 0.0 ; CFYO  = 0.0 ;  # > Default coordinateS
CFZI   = 0.0 ; CFZO  = 0.0 ;  # )
CFST  = 'P&T' ;               # default to P,T s.p or P,FE tp
CFEI   = 0.0 ; CFEO  = 0.0 ;
CTI    = 0.0 ; CTO   = 0.0 ;
CPI    = 0.0 ; CPO   = 0.0 ;
CVQI   = 0.0 ; CVQO  = 0.0 ;
CFFI   = 0.0 ; CFFO  = 0.0;
CVOL = 0.0 ;
CFLI = RL10 / 2.0 / RL4 ;      # Volume / flow area of inlet
CFLO = RL10 / 2.0 / RL5 ;      # Volume / flow area of outlet
ZETACA = 0.0;
#
$LOCALS
#
$REAL
RL1 = 3.1415927 ;                   # PI value
RL4 = RL1 * %CFDI% * %CFDI% / 4.0 ; # Flow area of inlet
RL5 = RL1 * %CFDO% * %CFDO% / 4.0 ; # Flow area of outlet
RL10 = %CVOL% ;                     # Capilary volume
RL12 = RL1 * %CFDI% * %CFLI% ;      # Heat transfer area of inlet
RL13 = RL1 * %CFDO% * %CFLO% ;      # Heat transfer area of outlet
#
$NODES
F1,A=%CAI%,FD=%CFDI%,FL=%CFLI%,P=%CPI%,T=%CTI%,FF=%CFFI%,FE=%CFEI%,
    VQ=%CVQI%,FST=%CFST%,FLA=%CFLAI%,
    FX=%CFXI%,FY=%CFYI%,FZ=%CFZI%;
K2,A=%CAO%,FD=%CFDO%,FL=%CFLO%,P=%CPO%,T=%CTO%,FF=%CFFO%,FE=%CFEO%,
    VQ=%CVQO%,FST=%CFST%,FLA=%CFLAO%,
    FX=%CFXO%,FY=%CFYO%,FZ=%CFZO%;
#
$CONDUCTORS
M(1,2) = %MFLOW% ;
#
$CONSTANTS
$REAL
ZETACA = %ZETACA%;    # Pressure loss coefficient (resistance)
$VARIABLES1
C
      CHARACTER MESAGE * 150 , ENAME * 6
      DOUBLE PRECISION ENTHP2
      DOUBLE PRECISION ZERO
      INTEGER ERR , TYPE
C
      PARAMETER (ZERO = 0.0D0 , ENAME = 'CAPFIL')
C
C compute the GP
C
      IF(ABS(ZETACA) .GT. 1.0D-37)THEN
         GP(1, 2) = 1.0D0 / ZETACA
C
      ELSE
         GP(1, 2) = 1.0D10
C
      END IF
C
C check for vapour at the inlet
C
      IF (VQ1 .GT. 0.0D0) THEN
         MESAGE = 'Element CAPFILTER - Fluid is not subcooled@' //
     &            'at TIMEN =                 , ' //
     &            'Output enthalpy set to saturation condition'
         WRITE(MESAGE(55 : 70) , '(E16.4)')TIMEN
         TYPE = 1
         ERR = 1
C
         CALL SETERX(MESAGE , TYPE , ERR , ENAME)
C
C compute outlet saturation enthalpy
C
         ENTHP2 = PROPS2(FT2 , 'ENTH' , P2 , ZERO , 'P&VQ')
C
         FE2 = ENTHP2
C
      ELSE
C
C Subcooled at inlet - set enthalpy of K node to inlet conditions
C
         FE2 = FE1
C
      END IF
C
$ENDMODEL CAPFILTER
$MODEL CHX
#
# PURPOSE:
#    Simulation of a condensing heat exchanger (counter flow) for use with
#    moist air (fluid type AIRW)
#
# DESCRIPTION:
#    Heat transfer from the primary side to the secondary (coolant) is
#    calculated; both sensible and latent heat are included, the latter from
#    condensation of water vapour. Condensate is completely removed from the
#    primary side
#       The effectiveness of the heat exchanger is determined by the heat-
#    transfer coefficient, UA; the product of this and the logarithmic average
#    temperature difference gives the rate of heat transfer.
#       The primary fluid is assumed to be AIRW, the secondary (the coolant) is
#    user-specified. Two damping factors are available to improve convergence
#    in steady-state or implicit transient solution.
#
# ORIGIN:
#    FHTS Upgrade 1 9197/90/NL/PP: ERC/92:1:21/JHS
#
# ==============================================================================
#
# CONNECTION POINTS:
#    F1   -   Primary inlet
#    F2   -   Primary outlet
#    F3   -   Secondary inlet
#    F4   -   Secondary outlet
#
# SUBSTITUTIONS DATA:
# (Default values in brackets)
# General:
#   UA       - REAL                Heat-transfer coefficient
#   DAMPQ    - REAL     (1.0)      Damping factor - heat transfer
#   DAMPW    - REAL     (1.0)      Damping factor - condensation
# Hot side:
#   XTH      - REAL                Initial temperature
#   XPH      - REAL                Initial pressure
#   XFLH     - REAL                Pipe length (total)
#   XFDH     - REAL                Pipe diameter
#   XFLAH    - REAL   (circular)   Pipe flow area
#   XFFH     - REAL                Surface roughness
#   XFXIH \
#   XFYIH  > - REAL     (0.0)      Inlet coordinates
#   XFZIH /
#   XFXOH \
#   XFYOH  > - REAL     (0.0)      Outlet coordinates
#   XFZOH /
#   MFLOWH   - REAL                Initial mass flow rate
#   XGPH     - REAL    (1.0E10)    Fitting-loss conductance
# Cold side:
#   XTYPC    - CHAR                Coolant fluid type
#   XFSTC    - CHAR    ('P&T')     Fluid state descriptor
#   XTC      - REAL     (0.0)      Initial temperature
#   XPC      - REAL     (0.0)      Initial pressure
#   XFEC     - REAL     (0.0)      Initial enthalpy
#   XVQC     - REAL     (0.0)      Initial enthalpy
#   XFLC     - REAL                Pipe length (total)
#   XFDC     - REAL                Pipe diameter
#   XFLAC    - REAL   (circular)   Pipe flow area
#   XFFC     - REAL     (0.0)      Surface roughness
#   XFXIC \
#   XFYIC  > - REAL     (0.0)      Inlet coordinates
#   XFZIC /
#   XFXOC \
#   XFYOC  > - REAL     (0.0)      Outlet coordinates
#   XFZOC /
#   MFLOWC   - REAL                Initial mass flow rate
#   XGPC     - REAL    (1.0E10)    Fitting-loss conductance
#
# ==============================================================================
#
$DEFAULTS
#
XFXIH=0.0; XFYIH=0.0; XFZIH=0.0;
XFXOH=0.0; XFYOH=0.0; XFZOH=0.0;
XFXIC=0.0; XFYIC=0.0; XFZIC=0.0;
XFXOC=0.0; XFYOC=0.0; XFZOC=0.0;
XFSTC = 'P&T';                # Fluid state - note hot side must be 'P&T'
XVQC = 0.0;                   # Vapour quality of the cold side
XPC = 0.0;                    # Pressure of cold side
XTC = 0.0;                    # Temperature of cold side
XFEC = 0.0;                   # Enthalpy of cold side
XFLAH = RL2; XFLAC = RL3;     # Flow area
XFFH = 0.0; XFFC = 0.0;       # Surface roughness
DAMPQ = 1.0; DAMPW = 1.0;     # Damping for condensate and latent heat
XGPH = 1.0E10; XGPC = 1.0E10; # Pressure loss coefficient
#
$LOCALS
#
$REAL
RL1 = 3.1415927;                   # Pi
RL2 = RL1 * %XFDH% * %XFDH% / 4.0; # Flow area of inlet
RL3 = RL1 * %XFDC% * %XFDC% / 4.0; # Flow area of outlet
#
$NODES
F1, T = %XTH%, P = %XPH%, FL = %XFLH% / 2.0, FD = %XFDH%,
    FLA = %XFLAH%, FF = %XFFH%, FT = 'AIRW',
    FX = %XFXIH%, FY = %XFYIH%, FZ = %XFZIH%;
F2, T = %XTH%, P = %XPH%, FL = %XFLH% / 2.0, FD = %XFDH%,
    FLA = %XFLAH%, FF = %XFFH%, FT = 'AIRW',
    FX = %XFXOH%, FY = %XFYOH%, FZ = %XFZOH%;
F3, FST = %XFSTC%, T = %XTC%, P = %XPC%, FE = %XFEC%, VQ = %XVQC%,
    FL = %XFLC% / 2.0, FD = %XFDC%, FLA = %XFLAC%, FF = %XFFC%, FT = %XTYPC%,
    FX = %XFXIC%, FY = %XFYIC%, FZ = %XFZIC%;
F4, FST = %XFSTC%, T = %XTC%, P = %XPC%, FE = %XFEC%, VQ = %XVQC%,
    FL = %XFLC% / 2.0, FD = %XFDC%, FLA = %XFLAC%, FF = %XFFC%, FT = %XTYPC%,
    FX = %XFXOC%, FY = %XFYOC%, FZ = %XFZOC%;
#
$CONDUCTORS
M(1,2) = %MFLOWH%;
M(3,4) = %MFLOWC%;
GP(1,2) = %XGPH%;
GP(3,4) = %XGPC%;
#
$CONSTANTS
#
$REAL
CRATE = 0.0;     # Calculated condensation rate
QOUT = 0.0;      # Outlet heat source
QCOUT = 0.0;     # Coolant outlet heat source
DAMPQ = %DAMPQ%; # Damping factor for heat inputs
DAMPW = %DAMPW%; # Damping factor for w.v. sink rate
UA = %UA%;       # Heat transfer coefficient
WCOND = 0.0;     # Applied condensation rate
#
$SUBROUTINES
#
      SUBROUTINE HXCALC
#
# PURPOSE: Calculate heat transfer and condensation rate
# METHOD : Estimate outlet temperature by bisection method. Calculate
#          implied heat transfer (sensible and latent heat) and compare
#          with that obtained from logarithmic average temperature
#          difference. Iterate until the two agree.
#
# LOCAL:
#   CHI    - DOUBLE PRECISION CONSTANT Ratio of molecular weights,
#            water vapour : air
#   CNVGD  - LOGICAL 'Solution converged' flag
#   CPCMN  - DOUBLE PRECISION Mean specific heat for coolant
#   CPIN   - DOUBLE PRECISION Specific heat for air/vapour at inlet
#   CPOUT  - DOUBLE PRECISION Specific heat for air/vapour at outlet
#   CPTILD - DOUBLE PRECISION Specific heat of air/vapour for heat
#            transfer calculation
#   CRMAX  - DOUBLE PRECISION Maximum condensation rate
#   DTAV   - DOUBLE PRECISION Logarithmic mean temperature difference
#   FTIAW  - INTEGER Fluid-type integer for AIRW
#   FTIW   - INTEGER Fluid-type integer for WATER
#   INFIN  - DOUBLE PRECISION CONSTANT `Infinity'
#   LAMBDA - DOUBLE PRECISION Latent heat of condensation
#   PS     - DOUBLE PRECISION Saturation pressure
#   PVIN   - DOUBLE PRECISION Partial pressure of w.v. at inlet
#   QAA    - DOUBLE PRECISION Heat transfer calculated from temperature
#            drop in air/vapour
#   QBB    - DOUBLE PRECISION Heat transfer from logarithmic average
#            temperature difference
#   SHIN   - DOUBLE PRECISION Specific humidity at inlet
#   SHMAX  - DOUBLE PRECISION Maximum spec. hum. at outlet, i.e. saturated
#   SHOUT  - DOUBLE PRECISION Actual spec. hum. at outlet
#   TCOUT  - DOUBLE PRECISION Coolant outlet temp.
#   TLOWER - DOUBLE PRECISION Lower limit for binary chop
#   TMAX   - DOUBLE PRECISION Maximum temperature for binary search
#   TMIN   - DOUBLE PRECISION Minimum temperature for binary search
#   TOUT   - DOUBLE PRECISION Outlet temperature
#   TS     - DOUBLE PRECISION Saturation temperature
#   TUPPER - DOUBLE PRECISION Upper limit for binary chop
#   WAOUT  - DOUBLE PRECISION Outlet mass flow rate of air
#   WVIN   - DOUBLE PRECISION Inlet mass flow rate for w.v.
#   WVOUT  - DOUBLE PRECISION Outlet mass flow rate for w.v.
#
      DOUBLE PRECISION CHI, CPCMN, CPIN, CPOUT, CPTILD, CRMAX, DTAV, INFIN,
     &                 LAMBDA, PS, PVIN, QAA, QBB, SHIN, SHMAX, SHOUT, TCOUT,
     &                 TLOWER, TMAX, TMIN, TOUT, TS, TUPPER, WAOUT, WVIN, WVOUT
      INTEGER FTIAW, FTIW
      LOGICAL CNVGD
#
      PARAMETER (CHI = 0.6221, INFIN = 1.0D15)
#
# Get fluid-type integers
#
      FTIAW = FTYPEI('AIRW')
      FTIW = FTYPEI('WATER')
#
# Define inlet conditions...
#
      SHIN = SHUM(F1)
      WVIN = SHIN / (1.0D0 + SHIN) * M(1, 2)
      PVIN = (P1 + PABS) * SHIN /(SHIN + CHI) - PABS
      CPIN = XCP(P1, T1, SHIN, FTIAW, 0)
      TS = XTEMPS(PVIN, FTIW, 0)
      LAMBDA = XENTHS(PVIN, TS, 1.0D0, FTIW, 0)
     &         - XENTHS(PVIN, TS, 0.0D0, FTIW, 0)
#
# ...and air outflow ( = inflow)...
#
      WAOUT = M(1, 2) - WVIN
#
# ...and mean Cp for coolant
#
      CPCMN = 0.5D0 * (CP(F3) + CP(F4))
#
      IF (UA .LT. 1.0D-37) THEN
         TOUT = T1
         WVOUT = WVIN
         CRATE = 0.0D0
         QAA = 0.0D0
      ELSE
#
# Initialise extreme values for binary chop
#
         TMIN = MIN(T1, T3)
         TMAX = MAX(T1, T3)
#
         TLOWER = TMIN
         TUPPER = TMAX
#
         CNVGD = .FALSE.
#
         REPEAT
#
# Estimate outlet temperature
#
            TOUT = 0.5D0 * (TLOWER + TUPPER)
#
# Calculate maximum vapour content at outlet temp. from saturation
# pressure
#
            PS = XPRESS(TOUT, FTIW, 0)
#
            IF (P2 - PS .GT. 1.0D-15) THEN
               SHMAX = CHI * (PS + PABS) / (P2 - PS)
            ELSE
               SHMAX = INFIN
            END IF
#
# Compare with w.v. content at inlet
#
            IF (SHIN .GT. SHMAX) THEN
#
# Condensation occurring
#
               WVOUT = WVIN * SHMAX / SHIN
               CRATE = WVIN - WVOUT
            ELSE
#
# No condensation
#
               WVOUT = WVIN
               CRATE = 0.0D0
            END IF
#
            IF (ABS(WAOUT) .LE. 1.0D-37) THEN
#
               IF (ABS(WVOUT) .LE. 1.0D-37) THEN
                  SHOUT = 0.0D0
               ELSE
                  SHOUT = INFIN
               END IF
#
            ELSE
               SHOUT = WVOUT / WAOUT
            END IF
#
# Calculate consequent heat transfer and resulting coolant outlet temp.
# Uses average Cp's to be compatible with main solution
#
            CPTILD = XCP(P2, TOUT, SHIN, FTIAW, 0)
            QAA = M(1, 2) * 0.5D0 * (CPIN + CPTILD) * (T1 - TOUT)
     &            + CRATE * LAMBDA
#
            IF (ABS(M(3, 4)) .LE. 1.0D-37) THEN
               TCOUT = T3
            ELSE
               TCOUT = T3 + QAA / (M(3, 4) * CPCMN)
            ENDIF
#
# Work out logarithmic average temperature difference and
# resulting heat transfer
#
            IF (ABS((T1 - TCOUT) - (TOUT - T3)) .LE. 1.0D-37) THEN
               DTAV = T1 - TCOUT
            ELSE IF (ABS(T1 - TCOUT) .LE. 1.0D-37
     &               .OR. ABS(T3 - TOUT) .LE. 1.0D-37) THEN
               DTAV = 0.0D0
            ELSE
               DTAV = (T1 - TCOUT + T3 - TOUT)
     &                / LOG(ABS((T1 - TCOUT) / (TOUT - T3)))
            END IF
#
            QBB = UA * DTAV
#
# Compare the two rates of heat transfer: if (approximately) equal and
# temperature converged within FRLXCA, then solution found
#
            IF (ABS((QAA - QBB) / UA) .LE. 1.0D-2
     &          .AND. TUPPER - TLOWER .LT. FRLXCA) THEN
               CNVGD = .TRUE.
            ELSE
#
               IF (TUPPER - TMIN .LT. 1.0D-15) THEN
#
# Lower limit too high
#
                  TMIN = TMIN - 5.0
                  TLOWER = TMIN
               ELSE IF (TMAX - TLOWER .LT. 1.0D-15) THEN
#
# Upper limit too low
#
                  TMAX = TMAX + 5.0D0
                  TUPPER = TMAX
               ELSE IF (TUPPER - TLOWER .LT. FRLXCA) THEN
#
# Assume converged - QBB sensitive
#
                  CNVGD = .TRUE.
               ELSE
#
# Adjust binary-chop limits
#
                  IF (QBB .GT. 0.0D0) THEN
#
                     IF (QAA .LT. QBB) THEN
#
                        IF (TOUT .GT. T3) THEN
                           TUPPER = TOUT
                        ELSE
                           TLOWER = TOUT
                        END IF
#
                     ELSE
#
                        IF (TOUT .GT. T3) THEN
                           TLOWER = TOUT
                        ELSE
                           TUPPER = TOUT
                        END IF
#
                     END IF
#
                  ELSE
#
                     IF (QAA .GT. QBB) THEN
#
                        IF (TOUT .GT. T3) THEN
                           TUPPER = TOUT
                        ELSE
                           TLOWER = TOUT
                        END IF
#
                     ELSE
#
                        IF (TOUT .GT. T3) THEN
                           TLOWER = TOUT
                        ELSE
                           TUPPER = TOUT
                        END IF
#
                     END IF
#
                  END IF
#
               END IF
#
            END IF
#
         UNTIL (CNVGD)
#
      END IF
#
# Calculate outlet heat fluxes
#
      CPOUT = XCP(P2, TOUT, SHOUT, FTIAW, 0)
      QOUT =  - M(1, 2) * 0.5D0 * (CPIN + CPOUT) * (T1 - TOUT)
      QCOUT = QAA
#
      RETURN
#
      END
#
$VARIABLES1
#
      IF (SOLTYP .EQ. 'THERMAL') THEN
#
# Apply heat fluxes
#
         CALL HXCALC
         FQ2 = FQ2 + DAMPQ * (QOUT - FQ2)
         FQ4 = FQ4 + DAMPQ * (QCOUT - FQ4)
      END IF
#
      IF (SOLTYP .EQ. 'HUMID') THEN
#
# Apply condensate flow
#
         CALL HXCALC
         WCOND = WCOND + DAMPW * (CRATE - WCOND)
         CALL WVSINK(F2, WCOND)
      END IF
#
$ENDMODEL CHX
$MODEL COLDPLATE
#
# Model of coldplate heat exchanger
#
#  T SWIFT   ----- 9 FEBRUARY 1988
#
$DEFAULTS
EFX1=0.0 ; EFY1=0.0 ; EFZ1=0.0 ;
EFX2=0.0 ; EFY2=0.0 ; EFZ2=0.0 ;
EFX3=0.0 ; EFY3=0.0 ; EFZ3=0.0 ;
EFST = 'P&T' ;
EVQ = 0.0 ;
EFE = 0.0;
EP = 0.0 ;
ET = 0.0 ;
EFF = 0.0 ;                  # no frictional pressure loss
NU = 2 ;                     # default to one segment
NX = 4 ;                     # number of solid nodes in x direction
NY = 4 ;                     # number of solid nodes in y direction
ERHO = 0.0 ;                 # arithmetic solid nodes
ECP = 0.0 ;                  # arithmetic solid nodes
EQ = 0.0 ;                   # no impressed heat load
KLOSS = RL60 * 1.0E-10 ;   # zero pressure loss per link (GP=1.0E10)
#
$LOCALS
#
# Store all parameters in local constants
#
# Node numbers and number of u-sections
#
$INTEGER
IL1=%NX%;IL2=%NY%;IL3=%NU%;
#
# Derived parameters from node numbers
#
IL4=IL1/4;IL5=IL1*IL2;IL6=IL2-2*IL4;IL7=IL1/2;
#
# Real versions of node numbers for calculations
#
$REAL
RL1=%NX%.0;RL2=%NY%.0;
#
# Dimensions of each u-section (width, length, and depth)
#
RL3=%LENX%;RL4=%LENY%;RL5=%DZ%;
#
# Conductivity, Cp and density of plate
#
RL6=%EK%;RL7=%ECP%;RL8=%ERHO%;
#
# Fluid length and area for nodes in x-direction
#
RL12=3.14159;
RL13=%LENX%/RL1;             # fluid node length LENX / NX
RL14=0.5*RL12*%EFD%*RL13;    # heat transfer area of fluid nodes in x direction
#
# Fluid length and area for nodes in y-direction
#
RL15=%LENY%/RL2;             # fluid node length LENY / NY
RL16=0.5*RL12*%EFD%*RL15;    # heat transfer area of fluid nodes in y direction
#
# Thermal node dimensions
#
RL20=RL3/RL1;RL21=RL4/RL2;   # LENX / NX and LENY / NY
#
# Thermal capacitance of thermal nodes
#
RL30=RL5*RL20*RL21*RL7*RL8;  # DZ * LENX / NX * LENY / NY * Cp * RHO
#
# Heat transfer areas for thermal nodes -
#                     X and Y directions]
#
RL40=RL5*RL21; RL41=RL5*RL20; # DZ * LENY / NY and DZ * LENX / NX
#
# Conductances in X and Y directions
#
RL50=RL40*RL6/RL20;  # DZ * LENY / NY * EK * NX / LENX
RL51=RL41*RL6/RL21;  # DZ * LENX / NX * EK * NY / LENY
#
RL60= 2.0 * %NY%.0 * %NU%.0 - %NU%.0;  # No of flow links generated
$NODES
#
# Node definitions for one u-plate section
#
#
# Node numbers and number of u-sections
#
KL1=%NX%;KL2=%NY%;KL3=%NU%;
#
# Loop for each section
#
FOR KL8=1 TO %NU% DO
#
# Derived parameters from node numbers
#
   KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
   KL9=1000*KL8;
   KL10=KL9;
#
# Generate thermal nodes
#
   FOR KL20=1 TO KL5 DO
      KL30=KL10+KL20;
      DKL30, T = %ETP%, C = RL30, QI = %EQ% / %NU% / RL1 / RL2;
   END DO
#
# Generate fluid nodes in five sections
#
   KL10=KL9+KL5;
#
# Input arm (xyz coordinates definied within $INITIAL block)
#
   FOR KL20=1 TO KL4 DO
      KL30=KL10+KL20;
      FKL30, A = RL14, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL13, FD = %EFD%, FF = %EFF%;
   END DO
#
# First leg of U
#
   KL11=KL6;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+KL4;
      FKL30, A = RL16, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL15, FD = %EFD%, FF = %EFF%;
   END DO
#
# Top of U
#
   KL11=KL7;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+KL4+KL6;
      FKL30, A = RL14, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL13, FD = %EFD%, FF = %EFF%;
   END DO
#
# Second leg of U
#
   KL11=KL6;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+KL6+3*KL4;
      FKL30, A = RL16, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL15, FD = %EFD%, FF = %EFF%;
   END DO
#
# Output arm
#
   KL11=KL4;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+2*KL6+3*KL4;
      FKL30, A = RL14, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL13, FD = %EFD%, FF = %EFF%;
   END DO
#
END DO
#
$CONDUCTORS
#
# Define all conductors for one U-section
#
# Node numbers and number of U-sections
#
KL1=%NX%;KL2=%NY%;KL3=%NU%;
#
# Derived parameters from node numbers
#
KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
#
# Define thermal conductances across x-direction
#
FOR KL9=1 TO %NU% DO
   KL10=1000*KL9;
   KL11=KL1-1;KL12=KL2;
   FOR KL20=1 TO KL11 DO
      FOR KL30=1 TO KL12 DO
         KL40=KL10+(KL30-1)*KL1+KL20;
         KL50=KL40+1;
         GL(KL40,KL50)=RL50;
      END DO
   END DO
#
# Define thermal conductances across y-direction
#
   KL11=KL2-1;KL12=KL1;
   FOR KL20=1 TO KL11 DO
      FOR KL30=1 TO KL12 DO
         KL40=KL10+KL30+(KL20-1)*KL1;
         KL50=KL40+KL1;
         GL(KL40,KL50)=RL51;
      END DO
   END DO
#
# Define thermal / fluid transfer conductances
#      -  done in five sections as for node definitions
#
   KL20=KL10+KL5;
#
# Input arm
#
   KL11=KL4;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30;
      KL50=(KL4-1)*KL1+KL30+KL10;
      KL60=KL50+KL1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# First leg of U
#
   KL11=KL6;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+KL4;
      KL50=(KL4+KL30-1)*KL1+KL4+KL10;
      KL60=KL50+1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Top of U
#
   KL11=KL7;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+KL4+KL6;
      KL50=(KL2-KL4-1)*KL1+KL4+KL30+KL10;
      KL60=KL50+KL1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Second leg of U
#
   KL11=KL6;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+KL4*3+KL6;
      KL50=KL1*(KL2-KL4+1-KL30)-KL4+KL10;
      KL60=KL50+1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Output arm
#
   KL11=KL4;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+3*KL4+2*KL6;
      KL50=KL4*(KL1-1)+KL30+KL10;
      KL60=KL50+KL1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Generate fluid links
#
   KL11=2*KL2-1;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30;
      KL50=KL40+1;
      M(KL40,KL50)=%MFLOW%;
      GP(KL40,KL50)= RL60 / KLOSS;
   END DO
END DO
#
# Now generate links between U-sections
#
FOR KL10=1 TO %NU%-1 DO
   FOR KL20=1 TO %NY% DO
      KL30=1000*KL10+%NX%*KL20;
      KL40=1000*(KL10+1)+%NX%*(KL20-1)+1;
      GL(KL30,KL40)=RL50;
   END DO
   KL50=KL10*1000+%NX%*%NY%+2*%NY%;
   KL60=(KL10+1)*1000+%NX%*%NY%+1;
   M(KL50,KL60)=%MFLOW%;
   GP(KL50,KL60)= RL60 / KLOSS;
END DO
#
$CONSTANTS
$REAL
KLOSS = %KLOSS% ;                      # Resistance coefficient
#
$INITIAL
C
C Local variables:
C I      INTEGER Loop counter
C MU     DOUBLE PRECISION Gemoetric factor
C NODE   INTEGER User node number
C NU     DOUBLE PRECISION Gemoetric factor
C UNITS  INTEGER Loop count upon number of segments
C XCORD  DOUBLE PRECISION X coordinate
C XX1    DOUBLE PRECISION x coordinate of corner 1 of u-tube UNITS
C XX2    DOUBLE PRECISION x coordinate of corner 2 of u-tube UNITS
C XX3    DOUBLE PRECISION x coordinate of corner 3 of u-tube UNITS
C YCORD  DOUBLE PRECISION Y coordinate
C YY1    DOUBLE PRECISION y coordinate of corner 1 of u-tube UNITS
C YY2    DOUBLE PRECISION y coordinate of corner 2 of u-tube UNITS
C YY3    DOUBLE PRECISION y coordinate of corner 3 of u-tube UNITS
C ZCORD  DOUBLE PRECISION Z coordinate
C ZZ1    DOUBLE PRECISION x coordinate of corner 1 of u-tube UNITS
C ZZ2    DOUBLE PRECISION x coordinate of corner 2 of u-tube UNITS
C ZZ3    DOUBLE PRECISION x coordinate of corner 3 of u-tube UNITS
C
        INTEGER I , UNITS , NODE
        DOUBLE PRECISION MU , NU , XCORD , XX1 , XX2 , XX3 , YCORD , YY1
     &                   , YY2 , YY3 , ZCORD , ZZ1 , ZZ2 , ZZ3
        LOGICAL FOUND
#
        FOUND = .FALSE.
        UNITS = 1
#
        REPEAT
#
# Get first fluid node number
#
           NODE = UNITS * 1000 + %NX% * %NY% + 1
#
# Calculate coords of edges of segment no UNITS
#
# Input coords are for edge of plate not edge of segment
#
# Node 2 (RHS bottom)
#
           XX2 = %EFX1% + UNITS / %NU%.0 * (%EFX2% - %EFX1%)
           YY2 = %EFY1% + UNITS / %NU%.0 * (%EFY2% - %EFY1%)
           ZZ2 = %EFZ1% + UNITS / %NU%.0 * (%EFZ2% - %EFZ1%)
#
# Node 1 (LHS bottom)
#
           XX1 = %EFX1% + (UNITS - 1) / %NU%.0 * (%EFX2% - %EFX1%)
           YY1 = %EFY1% + (UNITS - 1) / %NU%.0 * (%EFY2% - %EFY1%)
           ZZ1 = %EFZ1% + (UNITS - 1) / %NU%.0 * (%EFZ2% - %EFZ1%)
#
# Node 3 (LHS top)
#
           XX3 = %EFX3% + (UNITS - 1) / %NU%.0 * (%EFX2% - %EFX1%)
           YY3 = %EFY3% + (UNITS - 1) / %NU%.0 * (%EFY2% - %EFY1%)
           ZZ3 = %EFZ3% + (UNITS - 1) / %NU%.0 * (%EFZ2% - %EFZ1%)
#
# Generate coordinate values for input arm for UNITS
#
           I = 1
           REPEAT
              MU = (FLOAT(I) - 0.5) / %NX%.0
              NU = 0.25 * %NX%.0 / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              I = I + 1
              NODE = NODE + 1
           UNTIL(I .GT. %NX%/4)
#
# Generate coords for first leg of segment UNITS
#
           I = 1
           MU = 0.25
           REPEAT
              NU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GT. %NY% - %NX% / 2)
#
# Generate coords for top of U of segment UNITS
#
           I = 1
           REPEAT
              MU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NX%
              NU = 1.0 - ( %NX%.0 / 4.0 / %NY%.0)
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GT. %NX% / 2)
#
# Second leg of U
#
           I = 1
           MU = 0.75
           REPEAT
              NU = (%NY%.0 - 0.25 * %NX%.0 + 0.5 - FLOAT(I)) / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GT. (%NY% - %NX% / 2))
#
# Output arm
#
           I = 1
           REPEAT
              MU = (FLOAT(I) - 0.5 + 0.75 * %NX%.0) / %NX%.0
              NU = 0.25 * %NX%.0 / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GE. %NX% / 4)
#
           UNITS = UNITS + 1
        UNTIL(UNITS .GT. %NU%)
$ENDMODEL COLDPLATE
$MODEL COLDPLATE1
#
# Model of coldplate heat exchanger (special case of NU = 1)
#
#  T SWIFT   ----- 9 FEBRUARY 1988
#
$DEFAULTS
EFX1=0.0 ; EFY1=0.0 ; EFZ1=0.0 ;
EFX2=0.0 ; EFY2=0.0 ; EFZ2=0.0 ;
EFX3=0.0 ; EFY3=0.0 ; EFZ3=0.0 ;
EFST = 'P&T' ;
EVQ = 0.0 ;
EFE = 0.0;
EP = 0.0 ;
ET = 0.0 ;
EFF = 0.0 ;                  # no firctional pressure loss
NX = 4 ;                     # number of solid nodes in x direction
NY = 4 ;                     # number of solid nodes in y direction
ERHO = 0.0 ;                 # arithmetic solid nodes
ECP = 0.0 ;                  # arithmetic solid nodes
EQ = 0.0 ;                   # no impressed heat load
KLOSS = RL60 * 1.0E-10 ;     # zero pressure loss per link (GP=1.0E10)
#
$LOCALS
#
# Store all parameters in local constants
#
# Node numbers
#
$INTEGER
IL1=%NX%;IL2=%NY%;
#
# Derived parameters from node numbers
#
IL4=IL1/4;IL5=IL1*IL2;IL6=IL2-2*IL4;IL7=IL1/2;
#
# Real versions of node numbers for calculations
#
$REAL
RL1=%NX%.0;RL2=%NY%.0;
#
# Dimensions of each u-section (width, length, and depth)
#
RL3=%LENX%;RL4=%LENY%;RL5=%DZ%;
#
# Conductivity, Cp and density of plate
#
RL6=%EK%;RL7=%ECP%;RL8=%ERHO%;
#
# Fluid length and area for nodes in x-direction
#
RL12=3.14159;
RL13=%LENX%/RL1;             # fluid node length LENX / NX
RL14=0.5*RL12*%EFD%*RL13;    # heat transfer area of fluid nodes in x direction
#
# Fluid length and area for nodes in y-direction
#
RL15=%LENY%/RL2;             # fluid node length LENY / NY
RL16=0.5*RL12*%EFD%*RL15;    # heat transfer area of fluid nodes in y direction
#
# Thermal node dimensions
#
RL20=RL3/RL1;RL21=RL4/RL2;   # LENX / NX and LENY / NY
#
# Thermal capacitance of thermal nodes
#
RL30=RL5*RL20*RL21*RL7*RL8;  # DZ * LENX / NX * LENY / NY * Cp * RHO
#
# Heat transfer areas for thermal nodes -
#                     X and Y directions]
#
RL40=RL5*RL21; RL41=RL5*RL20; # DZ * LENY / NY and DZ * LENX / NX
#
# Conductances in X and Y directions
#
RL50=RL40*RL6/RL20;  # DZ * LENY / NY * EK * NX / LENX
RL51=RL41*RL6/RL21;  # DZ * LENX / NX * EK * NY / LENY
#
RL60 = 2.0 * %NY%.0  - 1.0;     # No of flow links generated
$NODES
#
# Node definitions for one u-plate section
#
#
# Node numbers and number of u-sections
#
KL1=%NX%;KL2=%NY%;
#
# Derived parameters from node numbers
#
KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
KL9=1000;
KL10=KL9;
#
# Generate thermal nodes
#
FOR KL20=1 TO KL5 DO
   KL30=KL10+KL20;
   DKL30, T = %ETP%, C = RL30, QI = %EQ% / RL1 / RL2;
END DO
#
# Generate fluid nodes in five sections
#
KL10=KL9+KL5;
#
# Input arm (xyz coordinates definied within $INITIAL block)
#
FOR KL20=1 TO KL4 DO
   KL30=KL10+KL20;
   FKL30, A = RL14, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
          VQ = %EVQ%, FL = RL13, FD = %EFD%, FF = %EFF%;
END DO
#
# First leg of U
#
KL11=KL6;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+KL4;
   FKL30, A = RL16, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
          VQ = %EVQ%, FL = RL15, FD = %EFD%, FF = %EFF%;
END DO
#
# Top of U
#
KL11=KL7;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+KL4+KL6;
   FKL30, A = RL14, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
         VQ = %EVQ%, FL = RL13, FD = %EFD%, FF = %EFF%;
END DO
#
# Second leg of U
#
KL11=KL6;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+KL6+3*KL4;
   FKL30, A = RL16, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL15, FD = %EFD%, FF = %EFF%;
END DO
#
# Output arm
#
KL11=KL4;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+2*KL6+3*KL4;
   FKL30, A = RL14, FST = %EFST%, T = %ET%, FE =  %EFE%, P = %EP%,
            VQ = %EVQ%, FL = RL13, FD = %EFD%, FF = %EFF%;
END DO
#
$CONDUCTORS
#
# Define all conductors for one U-section
#
# Node numbers and number of U-sections
#
KL1=%NX%;KL2=%NY%;
#
# Derived parameters from node numbers
#
KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
#
# Define thermal conductances across x-direction
#
KL10=1000;
KL11=KL1-1;KL12=KL2;
FOR KL20=1 TO KL11 DO
   FOR KL30=1 TO KL12 DO
      KL40=KL10+(KL30-1)*KL1+KL20;
      KL50=KL40+1;
      GL(KL40,KL50)=RL50;
   END DO
END DO
#
# Define thermal conductances across y-direction
#
KL11=KL2-1;KL12=KL1;
FOR KL20=1 TO KL11 DO
   FOR KL30=1 TO KL12 DO
      KL40=KL10+KL30+(KL20-1)*KL1;
      KL50=KL40+KL1;
      GL(KL40,KL50)=RL51;
   END DO
END DO
#
# Define thermal / fluid transfer conductances
#      -  done in five sections as for node definitions
#
KL20=KL10+KL5;
#
# Input arm
#
KL11=KL4;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30;
   KL50=(KL4-1)*KL1+KL30+KL10;
   KL60=KL50+KL1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# First leg of U
#
KL11=KL6;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+KL4;
   KL50=(KL4+KL30-1)*KL1+KL4+KL10;
   KL60=KL50+1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Top of U
#
KL11=KL7;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+KL4+KL6;
   KL50=(KL2-KL4-1)*KL1+KL4+KL30+KL10;
   KL60=KL50+KL1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Second leg of U
#
KL11=KL6;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+KL4*3+KL6;
   KL50=KL1*(KL2-KL4+1-KL30)-KL4+KL10;
   KL60=KL50+1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Output arm
#
KL11=KL4;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+3*KL4+2*KL6;
   KL50=KL4*(KL1-1)+KL30+KL10;
   KL60=KL50+KL1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Generate fluid links
#
KL11=2*KL2-1;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30;
   KL50=KL40+1;
   M(KL40,KL50)=%MFLOW%;
   GP(KL40,KL50)= RL60 / KLOSS;
END DO
#
$CONSTANTS
$REAL
KLOSS = %KLOSS% ;                 # Resistance coefficient
#
$INITIAL
C
C Local variables:
C I      INTEGER Loop counter
C MU     DOUBLE PRECISION Geometric factor
C NODE   INTEGER User node number
C NU     DOUBLE PRECISION Geometric factor
C XCORD  DOUBLE PRECISION X coordinate
C XX1    DOUBLE PRECISION x coordinate of corner 1 of u-tube
C XX2    DOUBLE PRECISION x coordinate of corner 2 of u-tube
C XX3    DOUBLE PRECISION x coordinate of corner 3 of u-tube
C YCORD  DOUBLE PRECISION Y coordinate
C YY1    DOUBLE PRECISION y coordinate of corner 1 of u-tube
C YY2    DOUBLE PRECISION y coordinate of corner 2 of u-tube
C YY3    DOUBLE PRECISION y coordinate of corner 3 of u-tube
C ZCORD  DOUBLE PRECISION Z coordinate
C ZZ1    DOUBLE PRECISION x coordinate of corner 1 of u-tube
C ZZ2    DOUBLE PRECISION x coordinate of corner 2 of u-tube
C ZZ3    DOUBLE PRECISION x coordinate of corner 3 of u-tube
C
        INTEGER I , NODE
        DOUBLE PRECISION MU , NU , XCORD , XX1 , XX2 , XX3 , YCORD , YY1
     &                   , YY2 , YY3 , ZCORD , ZZ1 , ZZ2 , ZZ3
        LOGICAL FOUND
#
        FOUND = .FALSE.
#
# Get first fluid node number
#
        NODE = 1000 + %NX% * %NY% + 1
#
# Node 2 (RHS bottom)
#
        XX2 = %EFX2%
        YY2 = %EFY2%
        ZZ2 = %EFZ2%
#
# Node 1 (LHS bottom)
#
        XX1 = %EFX1%
        YY1 = %EFY1%
        ZZ1 = %EFZ1%
#
# Node 3 (LHS top)
#
        XX3 = %EFX3%
        YY3 = %EFY3%
        ZZ3 = %EFZ3%
#
# Generate coordinate values for input arm
#
        I = 1
        REPEAT
           MU = (FLOAT(I) - 0.5) / %NX%.0
           NU = 0.25 * %NX%.0 / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           I = I + 1
           NODE = NODE + 1
        UNTIL(I .GT. %NX%/4)
#
# Generate coords for first leg
#
        I = 1
        MU = 0.25
        REPEAT
           NU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GT. %NY% - %NX% / 2)
#
# Generate coords for top of U
#
        I = 1
        REPEAT
           MU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NX%
           NU = 1.0 - ( %NX%.0 / 4.0 / %NY%.0)
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GT. %NX% / 2)
#
# Second leg of U
#
        I = 1
        MU = 0.75
        REPEAT
           NU = (%NY%.0 - 0.25 * %NX%.0 + 0.5 - FLOAT(I)) / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GT. (%NY% - %NX% / 2))
#
# Output arm
#
        I = 1
        REPEAT
           MU = (FLOAT(I) - 0.5 + 0.75 * %NX%.0) / %NX%.0
           NU = 0.25 * %NX%.0 / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GE. %NX% / 4)
#
$ENDMODEL COLDPLATE1
$MODEL EVAPUMP
#
# Evaporator pump model
#
$DEFAULTS
#
EVAI = RL12 ; EVAO = RL13 ;
EVFLAI = RL4 ; EVFLAO = RL5 ;
EVXI = 0.0 ; EVXO = 0.0 ;
EVYI = 0.0 ; EVYO = 0.0 ;
EVZI = 0.0 ; EVZO = 0.0 ;
EVFST = 'P&T' ;
EVEI = 0.0 ; EVEO = 0.0 ;
EVTI = 0.0 ; EVTO = 0.0 ;
EVPI = 0.0 ; EVPO = 0.0 ;
EVVQI = 0.0 ; EVVQO = 0.0 ;
EVLI = RL10 / 2.0 / RL4 ;     # Length of inlet node (volume defined)
EVLO = RL10 / 2.0 / RL5 ;     # Length of outlet node (volume defined)
EVVOL = 0.0 ;                 # total volume of capilary pump
#
$LOCALS
#
$REAL
RL1 = 3.1415927 ;                   # PI value
RL4 = RL1 * %EVDI% * %EVDI% / 4.0 ; # Flow area of inlet
RL5 = RL1 * %EVDO% * %EVDO% / 4.0 ; # Flow area of outlet
RL10 = %EVVOL% ;                    # Volume
RL12 = RL1 * %EVDI% * %EVLI% ;      # Heat transfer area of inlet
RL13 = RL1 * %EVDO% * %EVLO% ;      # Heat transfer area of outlet
#
$NODES
#
# Node F100 : input branch
# Node F200 : output branch, saturated vapor
#
F100,A=%EVAI%,FD=%EVDI%,FL=%EVLI%,P=%EVPI%,T=%EVTI%,FF=%EVFI%,FE=%EVEI%,
     VQ=%EVVQI%,FST=%EVFST%,FLA=%EVFLAI%,
     FM=-%MFLOW%,FX=%EVXI%,FY=%EVYI%,FZ=%EVZI%;
F200,A=%EVAO%,FD=%EVDO%,FL=%EVLO%,P=%EVPO%,T=%EVTO%,FF=%EVFO%,FE=%EVEO%,
     VQ=%EVVQO%,FST=%EVFST%,FLA=%EVFLAO%,
     FM=%MFLOW%,FH=%EVEO%,FR=%EVTO%,FW=%EVVQO%,
     FX=%EVXO%,FY=%EVYO%,FZ=%EVZO%;
#
$CONDUCTORS
#
$CONSTANTS
$REAL
QINPUT = %QINPUT%;
QMINI = %QMINI%;
QMAXI = %QMAXI%;
#
$ARRAYS
$REAL
QPARR(2,2) = %QMINI%,%DP1%,
             %QMAXI%,%DP2%;
#
$VARIABLES1
C
      CHARACTER MESAGE * 150 , ENAME * 6
      DOUBLE PRECISION HSAT2 , ONE
      INTEGER ERR , TYPE
      PARAMETER(ENAME = 'EVAPUM' , ONE = 1.0D0 )
C
C     check if heat input is between maximal and minimal heat input
C
      IF (QINPUT .LT. QMINI) THEN
         MESAGE = 'Element EVAPUMP - Heat load below minimum load@' //
     &            'TIMEN =                 , ' //
     &            'Evaporator not functioning correctly, ' //
     &            'Heat load set to minimum load'
         WRITE(MESAGE(56 : 71) , '(E16.4)')TIMEN
         TYPE = 2
         ERR = 1
C
         CALL SETERX(MESAGE , TYPE , ERR , ENAME)
C
         QINPUT = QMINI
C
      ELSE
         CONTINUE
C
      END IF
C
      IF (QINPUT .GT. QMAXI) THEN
          MESAGE = 'Element EVAPUMP - Heat load above maximum load@' //
     &             'TIMEN =                 , ' //
     &             'Evaporator dries out, heat load set to maximum load'
         WRITE(MESAGE(56 : 71) , '(E16.4)')TIMEN
         TYPE = 2
         ERR = 2
C
         CALL SETERX(MESAGE , TYPE , ERR , ENAME)
C
         QINPUT = QMAXI
C
      ELSE
         CONTINUE
C
      END IF
C
C     check if fluid at node F100 is subcooled
C
      IF (VQ100 .GT. 0.0D0)THEN
         MESAGE = 'Element EVAPUMP - Fluid is not subcooled@' //
     &            'TIMEN =                 , ' //
     &            'Evaporator not functioning correctly'
         WRITE(MESAGE(50 : 65) , '(E16.4)')TIMEN
         TYPE = 2
         ERR = 3
C
         CALL SETERX(MESAGE , TYPE , ERR , ENAME)
C
      ELSE
         CONTINUE
C
      END IF
C
      HSAT2 = PROPS2(FT200 , 'ENTH' , P200 , ONE , 'P&VQ')
C
C     compute pumped mass flux
C
      FM100 = -QINPUT / (HSAT2 - FE100)
      FM200 = -FM100
      FH100 = FE100
C
C     set output enthalpy to saturation condition
C
      FH200 = HSAT2
C
$VARIABLES2
C
      CHARACTER MESAGE * 182 , ENAME * 6
      DOUBLE PRECISION DELTAP , DPMAX
      INTEGER ERR , TYPE
      PARAMETER(ENAME = 'EVAPUM' )
C
      DELTAP = P200 - P100
      DPMAX = INTRP1(QINPUT , QPARR , 1)
C
C     Check if delta pressure of loop is bigger than maximal possible
C     delta pressure of evaporator
C
      IF (DELTAP .GT. DPMAX) THEN
         MESAGE = 'Element EVAPUMP - Loop pressure drop too large@' //
     &            'TIMEN =                 , ' //
     &            'Maximum capillary pressure =                 , ' //
     &            'Loop pressure drop =                 '
         WRITE(MESAGE(56 : 71) , '(E16.4)')TIMEN
         WRITE(MESAGE(103 : 118) , '(E16.4)')DPMAX
         WRITE(MESAGE(142 : 157) , '(E16.4)')DELTAP
         TYPE = 4
         ERR = 4
C
         CALL SETERX(MESAGE , TYPE , ERR , ENAME)
C
      ELSE
         CONTINUE
C
      END IF
C
$ENDMODEL EVAPUMP
$MODEL HPBANK
#
# Heat/pipe bank model
#
#   T SWIFT ---- 8 APRIL 1988
#
$DEFAULTS
HPFXI=0.0 ; HPFYI=0.0 ; HPFZI=0.0 ;
HPFXO=0.0 ; HPFYO=0.0 ; HPFZO=0.0 ;
HPA = RL2;                # Heat transfer area per section
HPFST = 'P&T';            # )
HPP = 0.0;                # )
HPE = 0.0;                # > Default fluid state
HPT = 0.0;                # )
HPVQ = 0.0;               # )
NNODES = 1;               # Only once section by default
TC = 0.0;                 # Arithmetic solid nodes
HPFF = 0.0;               # Zero friction, accounted for by GP?
KLOSS = RL10 * 1.0E-10;   # Zero pressure loss (GP=1.0E10)
#
$LOCALS
#
$REAL
RL1 = 3.1415927;
RL2 = %NTUBES%.0 * RL1 * %HPFD% * %HPLT% ;
RL5 = %NTUBES%.0 * RL1 * %HPFD% * %HPFD% / 4.0 ; # Flow area of tubes
RL10 = %NNODES%.0 + 1.0;                         # Number of mass flow links
#
$NODES
#
# Fluid nodes
#
F1, A = 0.0, FD = %HPDIN%, FL = %HPLT%, FST = %HPFST%, P = %HPP%,
    FE = %HPE%, T = %HPT%, VQ = %HPVQ%, FF = %HPFF%;
#
FOR KL1 = 2 TO %NNODES%+1 DO
   FKL1, A = %HPA%, FD = %HPFD%, FLA = RL5 , FL = %HPLT%, FST = %HPFST%,
         P = %HPP%, FE = %HPE%, T = %HPT%, VQ = %HPVQ%,
         FF = %HPFF%;
END DO
#
KL1=%NNODES%+2;
FKL1, A = 0.0, FD = %HPDIN%, FL = %HPLT%, FST = %HPFST%, P = %HPP%,
      FE = %HPE%, T = %HPT%, VQ = %HPVQ%, FF = %HPFF%;
#
# Thermal nodes
#
FOR KL1 = 1 TO %NNODES% DO
   KL2 = 1000 + KL1;
   DKL2, T = %TT%, C = %TC%;
END DO
#
$CONDUCTORS
#
# Fluid conductors
#
FOR KL1 = 1 TO %NNODES% + 1 DO
   KL2=KL1+1;
   M(KL1, KL2) = %MFLOWT%;
   GP(KL1, KL2) = RL10 / KLOSS;
END DO
#
# Fluid/thermal links
#
FOR KL1 = 1 TO %NNODES% DO
   KL2=KL1+1;
   KL3=1000+KL1;
   GL(KL2,KL3)=0.1;
END DO
#
$CONSTANTS
#
$REAL
KLOSS = %KLOSS%;               # Total pressure loss coefficient
#
$INITIAL
#
      INTEGER I
      I = 0
      REPEAT
      FX1(I) = %HPFXI% + (FLOAT(I) / (%NNODES%.0 + 1.0)
     &                       * (%HPFXO% - %HPFXI%))
      FY1(I) = %HPFYI% + (FLOAT(I) / (%NNODES%.0 + 1.0)
     &                       * (%HPFYO% - %HPFYI%))
      FZ1(I) = %HPFZI% + (FLOAT(I) / (%NNODES%.0 + 1.0)
     &                       * (%HPFZO% - %HPFZI%))
      I=I+1
      UNTIL (I.GT.%NNODES% + 1)
$VARIABLES1
C
C  Redefine thermal/fluid conductances using intrinsic correlations
C
      INTEGER I
      I=0
      REPEAT
         GL(2, 1001)(I) = HTCOEF(F2(I), D1001(I))
         I=I+1
      UNTIL (I.EQ.%NNODES%)
$ENDMODEL HPBANK
$MODEL HXANNULAR
#
#  Annular heat exchanger element
#
$DEFAULTS
HFXI=0.0   ; HFYI=0.0 ; HFZI=0.0 ;
HFXO=0.0   ; HFYO=0.0 ; HFZO=0.0 ;
HAT = RL2  ;
HAS = RL3  ;
HFSTT = 'P&T';
HFSTS = 'P&T';
HPT  = 0.0 ; HPS  = 0.0 ;
HFET = 0.0 ; HFES = 0.0 ;
HVQT = 0.0 ; HVQS = 0.0 ;
HFTT  = 0.0 ; HFTS  = 0.0 ;
HFFT = 0.0 ; HFFS = 0.0 ;
TC   = 0.0 ;
TKLOSS = RL4 * 1.0E-10 ;      # Zero pressure loss/link: tube side(GP=1.0E10)
SKLOSS = RL4 * 1.0E-10 ;      # Zero pressure loss/link: shell side(GP=1.0E10)
#
NNODES = 2;
#
$LOCALS
$REAL
#
RL1 = 3.14159265;
RL2 = RL1 * %HTDIA% * %HFLT% / %NNODES%.0;  # Heat transfer area (tube)
#
# Heat transfer area (shell) - note heat transfer is to the inner tube
#    wall and thus has the same heat transfer area as the tube (assumes
#    zero thickness of tube wall)
#
RL3 = RL2;
RL4 = %NNODES%.0-1.0;                       # No of mass flow links
RL10 = %HSDIA% - %HTDIA% ;                  #True hydraulic dia of shell
#
# True flow area of shell side nodes
#
RL15 = RL1 / 4.0 * (%HSDIA% * %HSDIA% - %HTDIA% * %HTDIA%) ;
#
$NODES
#
# Define nodes in shell section
#
FOR KL1=1 TO %NNODES% DO
   FKL1, A = %HAS%, FD = RL10, FLA = RL15, FL = %HFLS%,
         FST = %HFSTS%, P = %HPS%, FE = %HFES%, T = %HFTS%, VQ = %HVQS%,
         FF = %HFFS%, FT = %HTYPS%;
END DO
#
# Define nodes in tube section
#
KL3=1000+%NNODES%;
FOR KL4=1001 TO KL3 DO
   FKL4, A = %HAT%, FD = %HTDIA%, FL = %HFLT%, FST = %HFSTT%,
         P = %HPT%, FE = %HFET%, T = %HFTT%, VQ = %HVQT%,
         FF = %HFFT%, FT = %HTYPT%;
END DO
#
# Define thermal wall nodes
#
KL3=2000+%NNODES%;
FOR KL4=2001 TO KL3 DO
   DKL4, %TT%, %TC%;
END DO
#
$CONDUCTORS
#
# Define standard GL conductors between fluid and wall
#
FOR KL1=1 TO %NNODES% DO
   KL2=KL1+1000;
   KL3=KL1+2000;
   GL(KL1,KL3)=0.0; # Defined in $VARIABLES1
   GL(KL2,KL3)=*;
END DO
#
# Define fluid conductors and GP conductors
#
FOR KL1=1 TO %NNODES%-1 DO
   KL2=1000+KL1;
   KL3=KL1+1;
   KL4=KL2+1;
   M(KL1, KL3) = %MFLOWS%;
   GP(KL1, KL3) = RL4 / SKLOSS;
   M(KL2, KL4) = %MFLOWT%;
   GP(KL2, KL4) = RL4 / TKLOSS;
END DO
#
$CONSTANTS
#
$REAL
SKLOSS = %SKLOSS%;              # Shell side pressure loss coefficient
TKLOSS = %TKLOSS%;              # Tube side pressure loss coefficient
#
$INITIAL
#
# Set correct fluid nodal coordinates
#
      INTEGER I
      I=0
      REPEAT
         FX1001(I) = %HFXI% + (DBLE(I) / (%NNODES%.0 - 1.0)
     &                          * (%HFXO% - %HFXI%))
         FX1(I) = FX1001(I)
         FY1001(I) = %HFYI% + (DBLE(I) / (%NNODES%.0 - 1.0)
     &                          * (%HFYO% - %HFYI%))
         FY1(I) = FY1001(I)
         FZ1001(I) = %HFZI% + (DBLE(I) / (%NNODES%.0 - 1.0)
     &                       * (%HFZO% - %HFZI%))
         FZ1(I) = FZ1001(I)
         I=I+1
      UNTIL (I.EQ.%NNODES%)
#
$VARIABLES1
#
# Set heat transfer between shell side nodes and walls
#
      INTEGER I
      I=0
      REPEAT
         GL(1, 2001)(I) = HTCOEF(F1(I), D2001(I))
         I=I+1
      UNTIL (I.EQ.%NNODES%)
$ENDMODEL HXANNULAR
$MODEL HXKL3
#
#  General Kays and London heat exchanger
#  To be used for transient analyses (and steady-state)
#  Stanton Prandtl array formation for calculating heat transfer
#  Arrays within element
#
$DEFAULTS
#
# Parallel flow
#
MODE=2 ;
#
# Effectiveness calculated in element (HXTYP)
#
HXTYP=2 ;
#
# Fitting loss conductors
#
GPH=1.0D10 ; GPC=1.0D10 ;
#
# Heat exchanger effectiveness
#
EFF=0.0 ;
#
# Hot & Cold fin temperature effectiveness
#
ETAH=1.0 ; ETAC=1.0 ;
#
# Hot & Cold side pressure drop
#
DPHOT=0.0 ; DPCOLD=0.0 ;
#
# Capacitance to represent thermal inertia - zero for steady state
#
MCP=0.0 ;
#
#
# Solid-fluid conductance - Default value for transients (thermal inertia)
#                           will only be used if HXTYP=1,
#                           MODE=2 or 3 and outside
#                           range of NTU function (see Engineering Manual)
#
UAVAL = 0.0D0;
#
# Default zero cordinates at inlet/outlet on hot/cold side
#
FXIH=0.0 ; FYIH=0.0 ; FZIH=0.0 ;
FXOH=0.0 ; FYOH=0.0 ; FZOH=0.0 ;
FXIC=0.0 ; FYIC=0.0 ; FZIC=0.0 ;
FXOC=0.0 ; FYOC=0.0 ; FZOC=0.0 ;
#
# Default zero surface roughness
#
FFH=0.0 ; FFC=0.0 ;
FSTH = 'P&T'; FSTC = 'P&T';    #)
VQH = 0.0; VQC = 0.0;          #)
FEH = 0.0; FEC = 0.0;          #> Default fluid state
PH = 0.0; PC = 0.0;            #)
TH = 0.0; TC = 0.0;            #)
#
FLAH = RL4; FLAC = RL5;        # Flow area
#
$LOCALS
#
# FLH - DOUBLE PRECISION Total length of heat exchanger hot side
#
$REAL
RL1=%FLH%/2.0;
RL2=%FLC%/2.0;
RL3 = 3.14159;
RL4 = RL3 * %ADH% * %ADH% / 4.0; # Default flow area (hot side)
RL5 = RL3 * %ADC% * %ADC% / 4.0; # Default flow area (cold side)
#
$NODES
#
# FLH - DOUBLE PRECISION Total length of heat exchanger hot side
# ADH - DOUBLE PRECISION Diameter of hot side
# PH  - DOUBLE PRECISION Pressure of hot side
# FEH - DOUBLE PRECISION Enthalpy
# TH  - DOUBLE PRECISION temperature of hot side
# FFH - DOUBLE PRECISION  hot side surface roughness
# FTH - DOUBLE PRECISION hot side fluid type
# FLAH- DOUBLE PRECISION hot side cross-sectional flow area
# Hot side nodes
#
# A defined to equal 1 to enable dbsncf to return h value
#
F1, A = 1.0, FD = %ADH%, FLA = %FLAH%, FL = RL1,
    FST = %FSTH%, P = %PH%, FE = %FEH%, T = %TH%, VQ = %VQH%,
    FF = %FFH%, FT = %TYPH%, FX = %FXIH%, FY = %FYIH%, FZ = %FZIH%;
F2, A = 1.0, FD = %ADH%, FLA = %FLAH%, FL = RL1,
    FST = %FSTH%, P = %PH%, FE = %FEH%, T = %TH%, VQ = %VQH%,
    FF = %FFH%, FT = %TYPH%, FX = %FXOH%, FY = %FYOH%, FZ = %FZOH%;
#
# Cold side nodes
# Entities similarly defined for cold side
#
F3, A = 1.0, FD = %ADC%, FLA = %FLAC%, FL = RL2,
    FST = %FSTC%, P = %PC%, FE = %FEC%, T = %TC%, VQ = %VQC%,
    FF = %FFC%, FT = %TYPC%, FX = %FXIC%, FY = %FYIC%, FZ = %FZIC%;
F4, A = 1.0, FD = %ADC%, FLA = %FLAC%, FL = RL2,
    FST = %FSTC%, P = %PC%, FE = %FEC%, T = %TC%, VQ = %VQC%,
    FF = %FFC%, FT = %TYPC%, FX = %FXOC%, FY = %FYOC%, FZ = %FZOC%;
#
# Diffusion nodes at inlet and outlet
#
D11, C=%MCP%/4., T=%TH%;
D12, C=%MCP%/4., T=%TH%;
D13, C=%MCP%/4., T=%TC%;
D14, C=%MCP%/4., T=%TC%;
#
$CONDUCTORS
M(1,2)=%MFLOWH%;
M(3,4)=%MFLOWC%;
GP(1,2)=GPH;
GP(3,4)=GPC;
#
# Couplings between structure & fluid
#
GL(1,11)=U;
GL(2,12)=U;
GL(3,13)=U;
GL(4,14)=U;
#
$CONSTANTS
$REAL
#
# user input exchanger effectiveness
#
EFF=%EFF%;
#
# hot and cold fin temperature effectivenesses
#
ETAH=%ETAH%;
ETAC=%ETAC%;
FLH = %FLH%;
FLC = %FLC%;
#
GPH=%GPH%;
GPC=%GPC%;
#
DPHOT=%DPHOT%;
DPCOLD=%DPCOLD%;
#
STPRH=1.;
STPRC=1.;
#
$INTEGER
#
# Mode is type of heat exchanger
# 1 = Counterflow
# 3 = Crossflow
# otherwise parallel flow ( default ) is assumed
#
MODE = %MODE%;
#
HXTYP = %HXTYP%;
#
# Heat exchanger type
# 1 means User input value of effectiveness and press drop used
# 2 means effectivnesss is calculated in the element
# 3 means Stanton and Friction factor arrays are used to
# calculate the effectiveness and pressure drops
#
$ARRAYS
#
# Arrays of Reynolds no. versus St*Pr**0.6 and friction factor
# Example here is for Plain Plate-fin surface
# with surface designation 12.0T from Kays and London Table 10.3
#
# Stanton*Prandtl**0.6 array
#
   STARR(2,16)=200.,.01600,300.,.01185,400.,.00955,500.,.00815,
               600.,.00713,800.,.00555,1000.,.00493,1200.,.00441,
               1500.,.00388,2000.,.00346,3000.,.00350,4000.,.00344,
               5000.,.00333,6000.,.00322,7000.,.00312,8000.,.00302;
#
# Friction factor array
#
   FARR(2,17)=200.,.0811,300.,.0566,400.,.0437,500.,.0359,
               600.,.0306,800.,.0238,1000.,.0195,1200.,.0170,
               1500.,.01475,2000.,.01285,3000.,.01128,4000.,.01045,
               5000.,.00980,6000.,.00928,7000.,.00881,8000.,.00851,
               9000.,.00820;
#
$SUBROUTINES
C
C
C  Calculate ntu value using equation 2-10 in Kays and London
C
      DOUBLE PRECISION FUNCTION NTU(NODEH , NODEC , LH , LC , DH , DC ,
     &                              AH , AC , MH , MC , HH , HC)
      INTEGER NODEC , NODEH
      DOUBLE PRECISION AH , AC , CC , CH , CMIN , CPC , CPH , DC , DH ,
     &                 HC , HH , LC , LH , MC , MH , NTC , NTH , RHOC ,
     &                 RHOH , STC , STH , UC , UH
C
      RHOC = RHO(NODEC)
      RHOH = RHO(NODEH)
C
C Fluid velocities
C
      UC = MC / ( RHOC * AC)
      UH = MH / ( RHOH * AH)
C
C Specific heat
C
      CPC = CP(NODEC)
      CPH = CP(NODEH)
C
C Stanton numbers
C HC and HH are hot and cold heat transfer coefficients
C DH and DC are hot and cold hydraulic diameters
C note hydraulic radius = hydraulic diameter/4
C
      STC = HC / (RHOC * CPC * UC)
      STH = HH / (RHOH * CPH * UH)
C
C Heat capacities
C
      CC = MC * CPC
      CH = MH * CPH
      CMIN = MIN(CC , CH)
C
C Equivalent no. of heat transfer units
C
      NTH = STH * CH / CMIN * LH / (DH / 4.0) * ETAH
      NTC = STC * CC / CMIN * LC / (DC / 4.0) * ABS(ETAC)
      NTU = 1.0 / (1.0 / NTH + 1.0 / NTC)
C
C ======================================================================
C
      RETURN
C
C ======================================================================
C
      END
C
C ======================================================================
C
C  Calculate ntu value using equation 2-10 in Kays and London
C  NOTE This function has Stanton numbers as input hh and hc are
C  calculated within routine
C
      DOUBLE PRECISION FUNCTION NTUST(NODEH , NODEC , LH , LC , DH ,
     &                             DC , MH , MC , STH , STC )
      INTEGER NODEC , NODEH
      DOUBLE PRECISION CC , CH , CMIN , DC , DH , LC , LH ,
     &                 MC , MH , NTC , NTH , STC , STH
C
C Heat capacities
C
      CC = MC * CP(NODEC)
      CH = MH * CP(NODEH)
      CMIN = MIN(CC , CH)
C
C Equivalent no. of heat transfer units
C
      NTH = STH * CH / CMIN * LH / (DH / 4.0) * ETAH
      NTC = STC * CC / CMIN * LC / (DC / 4.0) * ABS(ETAC)
      NTUST = 1.0 / (1.0 / NTH + 1.0 / NTC)
C
C ======================================================================
C
      RETURN
C
C ======================================================================
C
      END
C
C =====================================================================
C
C    Function to determine effectiveness if not input by user
C    Equations from Kays and London Page 17 to 19
C
      DOUBLE PRECISION FUNCTION EFFECT(NTT , CMIN , CMAX , MFLAG)
      DOUBLE PRECISION CMAX , CMIN , DEN , NTT , NUM , TAU
      INTEGER MFLAG
C
      SELECT CASE MODE
      CASE 1
C
C Counterflow heat exchanger
C
         IF (ABS(CMAX / CMIN - 1.0) .LT. 0.0001) THEN
            EFFECT = NTT / (1.0 + NTT)
C
         ELSE
            NUM = 1.0 - EXP( - NTT * (1.0 - CMIN / CMAX))
            DEN = 1.0 - CMIN / CMAX * EXP( - NTT * (1.0 - CMIN / CMAX))
            EFFECT = NUM / DEN
C
         END IF
C
      CASE 3
C
C Crossflow heat exchanger
C
         IF (MFLAG .EQ. 1) THEN
C
C Cmax = Cunmixed
C
            TAU = 1.0 - EXP( - NTT * CMIN / CMAX)
            EFFECT = 1.0 - EXP( - TAU * CMAX / CMIN)
C
         ELSE
C
C Cmin = Cunmixed
C
            TAU = 1.0 - EXP( - NTT)
            EFFECT = CMAX / CMIN * (1.0 - EXP( - TAU * CMIN / CMAX))
C
         END IF
C
      CASE ELSE
C
C Parallel flow (default)
C
         NUM = 1.0 - EXP( - NTT * (1.0 + CMIN / CMAX))
         DEN = 1.0 + CMIN / CMAX
         EFFECT = NUM / DEN
C
      END SELECT
C
C ======================================================================
C
      RETURN
C
C ======================================================================
C
      END
C
C ======================================================================
C
C Function to determine UA for user input effectiveness
C Invert equations from Kays and London Page 17 to 19
C Note restrictions on eff for certain cmax/cmin ratios
C
      DOUBLE PRECISION FUNCTION UAVAL(CMIN , CMAX , MFLAG)
      DOUBLE PRECISION CMAX , CMIN , DEN , NUM
      INTEGER MFLAG
C
      SELECT CASE MODE
      CASE 1
C
C Counterflow
C
         IF (ABS(CMAX / CMIN - 1.0D0) .LT. 0.0001) THEN
            UAVAL = CMIN * EFF / (1.0D0 - EFF)
C
         ELSE
            UAVAL = - CMIN / (1.0D0 - CMIN / CMAX) * LOG((1.0D0 - EFF) /
     &             (1.0D0 - EFF * CMIN / CMAX))
C
         END IF
C
      CASE 3
C
C Crossflow heat exchanger
C
         IF (MFLAG .EQ. 1) THEN
C
C Cmax = Cunmixed
C
            IF (EFF .LT. 1.0D0 - EXP( - CMAX / CMIN))THEN
               UAVAL = - CMAX * LOG(1.0D0 + CMIN / CMAX *
     &                LOG(1.0D0 - EFF))
C
            ELSE
C
C Out of range of ntu function of eff, cmin and cmax for crossflow
C Set uaval to user defined value
C
               UAVAL = %UAVAL%
C
            END IF
C
         ELSE
C
C Cmin = Cunmixed
C
            IF (EFF .LT. CMAX / CMIN *
     &                   (1.0D0 - EXP( - CMIN / CMAX)))THEN
               UAVAL = - CMIN * LOG( 1.0D0 + CMAX / CMIN * LOG(1.0D0 -
     &                CMIN / CMAX * EFF) )
C
            ELSE
C
C Out of range of ntu function of eff, cmin and cmax for crossflow
C Set uaval to user defined value
C
               UAVAL = %UAVAL%
C
            END IF
C
         END IF
C
      CASE ELSE
C
C PARALLEL FLOW (DEFAULT)
C
         IF (EFF .LT. 1.0D0 / (1.0D0 + CMIN / CMAX))THEN
            UAVAL = - CMIN / (1.0D0 + CMIN / CMAX) * LOG(1.0D0 - EFF *
     &             (1.0D0 + CMIN / CMAX))
C
         ELSE
C
C Out of range of ntu function of eff, cmin and cmax for crossflow
C Set uaval to user defined value
C
            UAVAL = %UAVAL%
C
         END IF
C
      END SELECT
C
C =====================================================================
      RETURN
C
C ======================================================================
C
      END
C
$VARIABLES1
C
      INTEGER ERR , INC , INH , MFLAG , TYPE
C
      CHARACTER MESAGE * 150 , ENAME * 6
C
      DOUBLE PRECISION CC , CH , CMAX , CMIN , EFFECT , FDC , FDH , FLAC
     &                 , FLAH , FRC , FRH , GFLUX , HC , HH , NTUN ,
     &                 NTUST , PRC , PRH , QKL , REC , REH , ROC , ROH ,
     &                 STC , STH , TINC , TINH , UA
C
C Obtain fluid node no, temperature, flow area and hydraulic diameter
C    of hot and cold sides by upwinding
C
      IF(M(1, 2) .GT. 0.0) THEN
         INH = F1
         TINH = T1
         FLAH = FLA1
         FDH = FD1
C
      ELSE
         INH = F2
         TINH = T2
         FLAH = FLA2
         FDH = FD2
C
      END IF
C
      IF(M(3, 4) .GT. 0.0) THEN
         INC = F3
         TINC = T3
         FLAC = FLA3
         FDC = FD3
C
      ELSE
         INC = F4
         TINC = T4
         FLAC = FLA4
         FDC = FD4
C
      END IF
C
      IF (HXTYP .EQ. 1)THEN
C
C User input effectiveness and pressure drop - note
C     properties upwinded in GP contribution to pressure drop
C
         ROH = RHO(INH)
         ROC = RHO(INC)
C
         GPH = M(1 , 2) ** 2 / 2.D0 / ROH / DPHOT / FLAH ** 2
         GPC = M(3 , 4) ** 2 / 2.D0 / ROC / DPCOLD / FLAC ** 2
C
C Determine flow directions - Use node 1 and 3 to determine flow areas
C
         CH = ABS(M(1 , 2)) * CP(INH)
         CC = ABS(M(3 , 4)) * CP(INC)
         CMAX = MAX(CH , CC)
         CMIN = MIN(CH , CC)
C
         IF (CMAX .EQ. CC) THEN
C
C cmax=cunmixed
C
            MFLAG = 1
C
         ELSE
C
C cmin=cunmixed
C
            MFLAG = 0
C
         END IF
C
C Overall conductance for heat transfer across area A
C
         UA = UAVAL(CMIN , CMAX , MFLAG)
C
      ELSE IF (HXTYP .EQ. 2)THEN
C
C  Calculate effectiveness  internally
C     Determine flow directions and calculate
C     HC and HH (Hot and cold heat transfer coefficiants)
C
         HH = DBSNCF(INH , FLAH , FD1)
C
         HC = DBSNCF(INC , FLAC , FD3)
C
C Heat transfer units - Calculate ntu
C
         NTUN = NTU(INH , INC , FLH , FLC , FD1 , FD3 , FLA1 , FLA3 ,
     &              M(1 , 2) , M(3 , 4) , HH , HC)
C
C Calculate maximum and minimum heat capacities
C
         CH = ABS(M(1 , 2)) * CP(INH)
         CC = ABS(M(3 , 4)) * CP(INC)
         CMAX = MAX(CH , CC)
         CMIN = MIN(CH , CC)
C
         IF (CMAX .EQ. CC) THEN
            MFLAG = 1
C
         ELSE
            MFLAG = 0
C
         END IF
C
C Overwrite user defined value of effectiveness
C
         EFF = EFFECT(NTUN , CMIN , CMAX , MFLAG)
C
         UA = NTUN * CMIN
C
      ELSE IF(HXTYP .EQ. 3)THEN
C
C Pressure drop calculated from user inputed arrays in
C                    VARIABLES1 of main model
C
         ROH = RHO(INH)
         ROC = RHO(INC)
C
C  Determine flow directions and calculate stanton no.s STH and STC
C
C Calculates hot and cold side link Prandtl and Renolds numbers
C for heat exchanger
C note : uses upstream nodal quantities
C
C Hot side
C
         GFLUX = ABS(M(1, 2)) / FLAH
C
C Calculate hot and cold side link  Prandtl and Renolds numbers
C
         REH = GFLUX * FDH / VISC(INH)
         PRH = VISC(INH) * CP(INH) / COND(INH)
C
C Cold side
C
         GFLUX = ABS(M(3, 4)) / FLAC
         REC = GFLUX * FDC / VISC(INC)
         PRC = VISC(INC) * CP(INC) / COND(INC)
C
C Interpolate a single array to obtain St*Pr**0.6
C
         STPRH = INTRP1(REH , STARR , 1)
         STPRC = INTRP1(REC , STARR , 1)
C
C Calculate hot and cold side stanton numbers
C
         STH = STPRH / PRH ** 0.6666666667
         STC = STPRC / PRC ** 0.6666666667
C
C Interpolate a single array to obtain friction factor
C
         FRH = INTRP1(REH , FARR , 1)
         FRC = INTRP1(REC , FARR , 1)
C
C Calculate pressure drop and hence GP values from friction factors
C Note : assume friction factor at both nodes is the same for a link
C
         DPHOT = FRH * (FL1 + FL2) * M(1 , 2) ** 2 / (ROH * FLAH *
     &           FLAH * FDH)
         DPCOLD = FRC * (FL3 + FL4) * M(3 , 4) ** 2 / (ROC * FLAC *
     &            FLAC * FDC)
C
         GPH = M(1 , 2) ** 2 / 2.D0 / ROH / DPHOT / FLAH ** 2
         GPC = M(3 , 4) ** 2 / 2.D0 / ROC / DPCOLD / FLAC ** 2
C
C Heat transfer units
C Calculate ntu
C
         NTUN = NTUST(INH , INC , FLH , FLC , FDH , FDC ,
     &                M(1 , 2) , M(3 , 4) , STH , STC)
C
C Calculate maximum and minimum heat capacities
C
         CH = ABS(M(1 , 2)) * CP(INH)
         CC = ABS(M(3 , 4)) * CP(INC)
         CMAX = MAX(CH , CC)
         CMIN = MIN(CH , CC)
C
         IF (CMAX .EQ. CC) THEN
            MFLAG = 1
C
         ELSE
            MFLAG = 0
C
         END IF
C
C Overwrite user defined value of effectiveness
C
         EFF = EFFECT(NTUN , CMIN , CMAX , MFLAG)
C
         UA = NTUN * CMIN
C
      ELSE
C
C Hxtyp been set to some incorrect value
C
         MESAGE = 'Element HXKL3 - Incorrect HXTYP specified@'//
     &            'Allowable options for HXTYP are 1, 2 & 3'
         ENAME = 'HXKL3'
         TYPE = 4
         ERR = 1
C
         CALL SETERX(MESAGE , TYPE , ERR , ENAME)
C
      END IF
C
C Set conductor links for transient analysis
C
      GL(1 , 11) = UA / 2.
      GL(2 , 12) = UA / 2.
      GL(3 , 13) = UA / 2.
      GL(4 , 14) = UA / 2.
C
      IF(MODULE .EQ. 'FLTNSS' )THEN
C
C Steady state analysis deactivate thermal node links
C
         CALL STATST( 'N11' , 'X' )
C
         CALL STATST( 'N12' , 'X' )
C
         CALL STATST( 'N13' , 'X' )
C
         CALL STATST( 'N14' , 'X' )
C
      END IF
C
      QKL = EFF * CMIN * (TINH - TINC)
C
      IF(INH .EQ. F1)THEN
         FQ2 = - QKL
C
      ELSE
         FQ1 = - QKL
C
      END IF
C
      IF(INC .EQ. F3)THEN
         FQ4 = QKL
C
      ELSE
         FQ3 = QKL
C
      END IF
C
$ENDMODEL HXKL3
$MODEL HXXFLOW
#
#  General cross-flow heat exchanger element
#
#     T SWIFT        31 MARCH 1988
#     C KIRTLEY      17 MAY   1990
#     C KIRTLEY      6  JAN   1991
#
$DEFAULTS
#
TFXI=0.0 ; TFYI=0.0 ; TFZI=0.0 ;
TFXO=0.0 ; TFYO=0.0 ; TFZO=0.0 ;
SFXI=0.0 ; SFYI=0.0 ; SFZI=0.0 ;
SFXO=0.0 ; SFYO=0.0 ; SFZO=0.0 ;
TA = RL4 ; SA = RL1 ;
TFST = 'P&T' ; SFST = 'P&T' ;
TP = 0.0 ; SP = 0.0 ;
TE = 0.0 ; SE = 0.0 ;
TT = 0.0 ; ST = 0.0 ;
TVQ = 0.0 ; SVQ = 0.0 ;
NBAFFL = 1 ;
LAYOUT = 90 ;
CW = 0.0 ;                   # Wall capacitance, default to arithmetic node
#
$LOCALS
#
# Shell side heat transfer taken as the surface area of the
# cross tubes. The tube thickess is ignored
#
$REAL
RL1=3.1415926D0*%TD%*%NTUBES%.0D0*%TL%;      # Shell side nodal area
#
# Shell side assumed to be square section of length Lt
# Area eqated to give RL2 = SQRT(PI / 4) * Ds
#
RL2=%DSHELL% * 0.886227D0;                   # Shell side node length
#
RL4=%NTUBES%.0 * 3.1415926D0 * %TD% * %TL%;  # Tube side h.t. area == RL1
#
RL5=%NTUBES%.0 * 3.1415926D0 * %TD% * %TD% / 4.0;  # Tube side flow area
#
$NODES
#
# Tube side nodes
#
F1, A = 0.0D0, FD = %TDIN%, FL = %TL%, FST = %TFST%, P = %TP%, FE = %TE%,
    T = %TT%, VQ = %TVQ%, FF = %TFF%, FT = %TTYP%;
#
# Note that the flow area is the total (not per tube)
#     thus the fluid velocity per tube is correct
#
FOR KL1 = 2 TO %NBAFFL%+2 DO
   FKL1, A = %TA%, FD = %TD%, FLA = RL5 , FL = %TL%, FST = %TFST%,
         P = %TP%, FE = %TE%, T = %TT%, VQ = %TVQ%, FF = %TFF%, FT=%TTYP%;
END DO
#
KL1=%NBAFFL%+3;
FKL1, A = 0.0D0, FD = %TDIN%, FL = %TL%, FST = %TFST%, P = %TP%, FE = %TE%,
    T = %TT%, VQ = %TVQ%, FF = %TFF%, FT = %TTYP%;
#
# Shell side nodes - Note FD set to 0.0 (defined within $INITIAL block)
#                         FF set to 0.0 (included within GP function)
#
F2001, A = 0.0D0, FD = %SDIN%, FL = RL2, FST = %SFST%, P = %SP%, FE = %SE%,
       T =  %ST%, VQ = %SVQ%, FF = %TFF%, FT = %STYP%;
#
FOR KL1 = 2002 TO 2002+%NBAFFL% DO
   FKL1, A = %SA%, FD = 0.0D0, FL = RL2, FST = %SFST%, P = %SP%, FE = %SE%,
         T = %ST%, VQ = %SVQ%, FF = 0.0D0, FT=%STYP%;
END DO
#
KL1=%NBAFFL% + 2003;
FKL1, A = 0.0D0, FD = %SDIN%, FL = RL2, FST = %SFST%, P = %SP%, FE = %SE%,
      T = %ST%, VQ = %SVQ%, FF = %TFF%, FT = %STYP%;
#
#  Thermal wall nodes - tube wall only - shell wall ignored
#
FOR KL1 = 1001 TO 1001 + %NBAFFL% DO
   DKL1, %TW%, %CW%;
END DO
#
$CONDUCTORS
#
# Tube-side mass flow conductors
#
FOR KL1=1 TO %NBAFFL%+2 DO
   KL2=KL1+1;
   M(KL1,KL2)=%MFLOWT%;
END DO
#
# Shell-side mass flow and gp conductors
#
FOR KL1 = 2 TO %NBAFFL%+1 DO
   KL2 = KL1+2000;
   KL3 = KL2+1;
   M(KL2, KL3) = %MFLOWS%;
END DO
#
M(2001, 2002) = %MFLOWS%;
KL2 = %NBAFFL% + 2002;
KL3 = KL2 + 1;
M(KL2, KL3) = %MFLOWS%;
#
# GL conductors
#
FOR KL1=1 TO %NBAFFL%+1 DO
   KL2 = KL1 + 1;
   KL3 = KL1 + 1000;
   KL4 = KL1 + 2001;
   GL(KL2, KL3) = 0.0D0;
   GL(KL4, KL3) = 0.0D0;
END DO
#
$SUBROUTINES
#
      DOUBLE PRECISION FUNCTION HXGP(DIA , DEQ , LNG , LY , PT , LT ,
     &                 XMASS , NODE)
C
C ======================================================================
C
C INPUT:
C
C DIA    DOUBLE PRECISION Tube diameter
C DEQ    DOUBLE PRECISION Shell side equivelent diameter
C LNG    DOUBLE PRECISION Length of shell node
C LY     INTEGER Layout of tubes
C PT     DOUBLE PRECISION Tube pitch
C LT     DOUBLE PRECISION Length of tubes
C XMASS  DOUBLE PRECISION Cross flow mass flow rate
C NODE   INTEGER Node number of shell side nodes
C
C ======================================================================
C
      DOUBLE PRECISION AC , DEQ , DIA , DS , DT , F , LNG , LT , NR ,
     &                 PI , PT , PX , REYCF , X , XA1 , XA2 , XA3 ,
     &                 XA4 , XA5 , XA6 , XA7 , XC , XMASS , XX , Y ,
     &                 YB1 , YT1
      INTEGER LY , NODE
C
C PI
C
      PI = 3.1415926D0
C
C Cross-sectional area including tube area
C
      AC = LNG * LT
C
C Tube pitch/diameter ratio
C
      X = PT / DIA
C
C Longitudinal pitch
C
      SELECT CASE LY
      CASE 90
         PX = PT
      CASE 45
         PX = 0.707D0 * PT
      CASE 30
         PX = 0.866D0 * PT
      CASE 60
         PX = 0.5D0 * PT
      END SELECT
C
C No. of rows crossed - converted to d.p - NR not used as no bypass
C
      NR = LNG / PX + 1.0D0
C
C Crossflow reynolds number
C
      REYCF = ABS(XMASS * DIA / VISC(NODE) / AC)
C
C Find loss coefficient factor C
C
      IF (LY .EQ. 45 .OR. LY .EQ. 90) THEN
C
         IF (LY .EQ. 90) THEN
            F = 1.0D0
C
         ELSE
            XX = (X - 1.0D0) / X
            XA1 = 10.0D0 + 9.75D0 * LOG10(XX)
            XA2 = 1.6D0 - 0.86D0 * XX
            XA3 = 10.0D0 ** (2.4D0 * XX - 0.03D0)
            XA4 = 1.56D0 * XX
            XA5 = 2.2D0 * XX ** 3.35D0 - 0.11D0
            XA6 = XA4 + XA5 * (1.0D0 - (REYCF / (REYCF + 10 ** 4)) ** 2)
            F = 1.0D0 / SQRT(1.0D0 / ((XA1 * REYCF / (REYCF + 100.0D0))
     &             ** 2 + XA2) + 1.0D0 / (XA3 * (1.0D0 - REYCF /
     &             (REYCF + 400.0D0)) ** 2 + XA6))
C
         END IF
         DS = 4 * X * X / PI - REYCF / (REYCF + 1000.0D0)
         XA7 = REYCF / (REYCF + 10.0D0 ** 4)
         YT1 = (0.1D0 * REYCF / (REYCF + 100.0D0)) ** 2
         YB1 = XA7 * XA7 / (0.5D0 * (1.0D0 + 0.6D0 * XA7)) ** 2 +
     &          1.0D0 / (1.0D0 + 3.0D0 * XA7) ** 2
         Y = SQRT(YT1 / YB1 + 49.0D0 / REYCF ** 1.95D0)
         XC = F * Y * DS / (X - 1) ** 3
C
      ELSE
         XA1 = REYCF / (REYCF + 1.0D4)
         YT1 = 3.61D0 / REYCF ** 0.7D0 * (1.0D0 + 5.0D0 / REYCF **
     &          0.8D0) ** 2
         YB1 = 0.0625D0 * (1.0D0 - XA1) * (1.0D0 - XA1)
         Y = SQRT(YT1 + YB1 + 0.01D0)
         DT = 3.464102D0 * X * X / PI - REYCF / (REYCF + 10.0D0)
         XC = Y * DT / (X - 1.0D0) ** 3
C
      END IF
C
C Now return factor for GP
C Modified to take into account the different velocity used
C internally in 1/2 rho U ** 2 and in the correllation
C ((LNG*LT)/(0.785398D0*DEQ**2)**2) - factor to take into
C account velocity ratio
C
      HXGP = DIA / (XC * LNG) * ((LNG * LT) / ( 0.785398D0 * DEQ ** 2))
     &       ** 2
C
      RETURN
      END
C
      DOUBLE PRECISION FUNCTION HXHTC(DIA , LNG , LY , PT , LT , XMASS ,
     &                 NODE)
C
C ======================================================================
C
C Return heat transfer coefficient for shell side flow
C
      DOUBLE PRECISION AREA , AX , CF , DIA , LNG , LT , MX , NC , NR ,
     &                 PRANTL , PT , PX , PY , REYCF , XMASS
      INTEGER LY , NODE
C
C Set pitch in x and y directions
C
      SELECT CASE LY
      CASE 30
         PX = 0.866D0 * PT
         PY = PT
      CASE 45
         PX = 0.707D0 * PT
         PY = 1.414D0 * PT
      CASE 60
         PX = 0.5D0 * PT
         PY = 1.732D0 * PT
      CASE 90
         PX = PT
         PY = PT
      END SELECT
C
C Number of rows
C
      NR = LNG / PY
C
C Minimum cross flow area
C
      IF (LY .EQ. 30 .OR. LY .EQ. 90 .OR. (LY .EQ. 45 .AND. PT /
     &    DIA .LT. 3.73D0) .OR. (LY .EQ. 60 .AND. PT / DIA .LT. 1.71D0))
     &    THEN
         AREA = NR * (PY - DIA) * LNG
C
      ELSE
         AREA = 2.0D0 * NR * (PT - DIA) * LNG
C
      END IF
C
C Get reynolds and prandtl numbers
C
      REYCF = XMASS * DIA / VISC(NODE) / AREA
      PRANTL = CP(NODE) * VISC(NODE) / COND(NODE)
C
C No. of rows crossed
C
      NC = LNG / PX + 1.0D0
C
C Correction factor
C
      IF (NC .GE. 20.0D0) THEN
         CF = 1.035D0
C
      ELSE
         CF = 1.356D0 * NC / (1.0D0 + 1.26D0 * NC)
C
      END IF
C
C Coefficients for equation based on layout and reynolds no.
C
      IF (REYCF .LT. 3.0D2) THEN
C
         IF (LY .EQ. 90) THEN
            AX = 0.742D0
            MX = 0.431D0
C
         ELSE
            AX = 1.309D0
            MX = 0.360D0
C
         END IF
C
      ELSE IF (REYCF .LT. 2.0D5) THEN
C
         IF (LY .EQ. 90) THEN
            AX = 0.211D0
            MX = 0.651D0
C
         ELSE
            AX = 0.273D0
            MX = 0.635D0
C
         END IF
C
      ELSE
C
         IF (LY .EQ. 90) THEN
            AX = 0.116D0
            MX = 0.700D0
C
         ELSE
            AX = 0.124D0
            MX = 0.700D0
C
         END IF
C
      END IF
C
C Return heat transfer coefficient
C
      HXHTC = AX * COND(NODE) / DIA * REYCF ** MX * PRANTL ** 0.34D0 *
     &       CF
C
      RETURN
      END
$INITIAL
      DOUBLE PRECISION DUM1 , EQIVD
      INTEGER I
C
C Calculate the equivelent flow diameter - is the same for all
C shell side nodes
C
      DUM1 = (%DSHELL% ** 2 - %NTUBES% * %TD% ** 2)
      EQIVD = SQRT(DBLE(%TL%) * (DUM1) /
     &           (0.8862269D0 * DBLE(%DSHELL%)))
      FX1 = %TFXI%
      FY1 = %TFYI%
      FZ1 = %TFZI%
      FX2001 = %SFXI%
      FY2001 = %SFYI%
      FZ2001 = %SFZI%
      I = 0
      REPEAT
         FX2(I) = %TFXI% + (FLOAT(I) / %NBAFFL%.0 * (%TFXO% - %TFXI%))
         FX2002(I) = FX2(I)
         FY2(I) = %TFYI% + (FLOAT(I) / %NBAFFL%.0 * (%TFYO% - %TFYI%))
         FY2002(I) = FY2(I)
         FZ2(I) = %TFZI% + (FLOAT(I) / %NBAFFL%.0 * (%TFZO% - %TFZI%))
         FZ2002(I) = FZ2(I)
         FD2002(I) = EQIVD
         FLA2002(I) = 3.1415927D0 * EQIVD * EQIVD / 4.0D0
         I = I + 1
      UNTIL (I .EQ. %NBAFFL% + 1)
      FX2(I) = %TFXO%
      FY2(I) = %TFYO%
      FZ2(I) = %TFZO%
      FX2002(I) = %SFXO%
      FY2002(I) = %SFYO%
      FZ2002(I) = %SFZO%
$VARIABLES1
      DOUBLE PRECISION HXHTC, HXGP, PITCH
      INTEGER I, LY
C
C  Calculate pitch
C
      PITCH = 0.886227D0 * %DSHELL% / SQRT(FLOAT(%NTUBES%))
C
C  Modify layout to be valid option
C
      LY = %LAYOUT%
      IF (LY.NE.30 .AND. LY.NE.60 .AND. LY.NE.45) THEN
         LY = 90
      END IF
C
C  Evaluate thermal conductances
C
      I = 0
      REPEAT
         GL(2, 1001) (I) = HTCOEF(F2(I), D1001(I))
         GL(2002, 1001)(I) = HXHTC(DBLE(%TD%), DBLE(%DSHELL%)
     &                            * 0.886227D0, LY, PITCH,
     &                            DBLE(%TL%), M(2002,2003)(I),
     &                            F2002(I)) * A2002(I)
      I = I + 1
      UNTIL (I .EQ. %NBAFFL% + 1)
C
C Evaluate gp conductances for shell-side flow
C
      I = 0
      REPEAT
      GP(2002,2003)(I) = HXGP(DBLE(%TD%), FD2002(I),
     &                        DBLE(%DSHELL%) * 0.886227D0, LY,
     &                        PITCH, DBLE(%TL%), M(2002,2003)(I),
     &                        F2002(I))
      I = I + 1
      UNTIL (I .EQ. %NBAFFL%)
$ENDMODEL HXXFLOW
$MODEL PANEL
#
# Model of panel radiator
#
#  T SWIFT   ----- 23rd March 1988
#
$DEFAULTS
RFX1=0.0 ; RFY1=0.0 ; RFZ1=0.0 ;
RFX2=0.0 ; RFY2=0.0 ; RFZ2=0.0 ;
RFX3=0.0 ; RFY3=0.0 ; RFZ3=0.0 ;
RFST = 'P&T' ;
RVQ = 0.0 ;
RFE = 0.0;
RP = 0.0 ;
RT = 0.0 ;
RFF = 0.0 ;                  # no firctional pressure loss
NU = 2 ;                     # default to one segment
NX = 4 ;                     # number of solid nodes in x direction
NY = 4 ;                     # number of solid nodes in y direction
RRHO = 0.0 ;                 # arithmetic solid nodes
RCP = 0.0 ;                  # arithmetic solid nodes
REMM1 = 1.0 ;                # Emissivity of face 1 (black body)
REMM2 = 1.0 ;                # Emissivity of face 2 (black body)
RVFAC1 = 1.0 ;               # View factor between face 1 and boundary
RVFAC2 = 1.0 ;               # View factor between face 2 and boundary
KLOSS = RL70 * 1.0E-10 ;   # zero pressure loss per link (GP=1.0E10)
#
$LOCALS
#
# Store all parameters in local constants
#
# Node numbers and number of u-sections
#
$INTEGER
IL1 = %NX%; IL2 = %NY%; IL3 = %NU%;
#
# Derived parameters from node numbers
#
IL4=IL1/4;IL5=IL1*IL2;IL6=IL2-2*IL4;IL7=IL1/2;
#
# Real versions of node numbers for calculations
#
$REAL
RL1=%NX%.0;RL2=%NY%.0;
#
# Dimensions of each u-section (width, length, and depth)
#
RL3=%LENX%;RL4=%LENY%;RL5=%DZ%;
#
# Conductivity, Cp and density of plate
#
RL6=%RK%;RL7=%RCP%;RL8=%RRHO%;
#
# Fluid length and area for nodes in x-direction
#
RL12=3.14159;
RL13=%LENX%/RL1;             # fluid node length LENX / NX
RL14=0.5*RL12*%RFD%*RL13;    # heat transfer area of fluid nodes in x direction
#
# Fluid length and area for nodes in y-direction
#
RL15=%LENY%/RL2;             # fluid node length LENY / NY
RL16=0.5*RL12*%RFD%*RL15;    # heat transfer area of fluid nodes in y direction
#
# Thermal node dimensions
#
RL20=RL3/RL1;RL21=RL4/RL2;   # LENX / NX and LENY / NY
#
# Thermal capacitance of thermal nodes
#
RL30=RL5*RL20*RL21*RL7*RL8;  # DZ * LENX / NX * LENY / NY * Cp * RHO
#
# Heat transfer areas for thermal nodes -
#                     X and Y directions]
#
RL40=RL5*RL21; RL41=RL5*RL20; # DZ * LENY / NY and DZ * LENX / NX
#
# Conductances in X and Y directions
#
RL50=RL40*RL6/RL20;  # DZ * LENY / NY * EK * NX / LENX
RL51=RL41*RL6/RL21;  # DZ * LENX / NX * EK * NY / LENY
#
# Radiative conductance values
#
RL60=%REMM1%*%RVFAC1%*RL20*RL21;
RL61=%REMM2%*%RVFAC2%*RL20*RL21;
#
RL70=2.0 * %NY%.0 * %NU%.0 - 1.0;  # No of flow links generated
$NODES
#
# Node definitions for one u-plate section
#
#
# Node numbers and number of u-sections
#
KL1=%NX%;KL2=%NY%;KL3=%NU%;
#
# Loop for each section
#
FOR KL8=1 TO %NU% DO
#
# Derived parameters from node numbers
#
   KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
   KL9=1000*KL8;
   KL10=KL9;
#
# Generate thermal nodes
#
   FOR KL20=1 TO KL5 DO
      KL30=KL10+KL20;
      DKL30, T = %RTP%, C = RL30;
   END DO
#
# Generate fluid nodes in five sections
#
   KL10=KL9+KL5;
#
# Input arm (xyz coordinates definied within $INITIAL block)
#
   FOR KL20=1 TO KL4 DO
      KL30=KL10+KL20;
      FKL30, A = RL14, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL13, FD = %RFD%, FF = %RFF%;
   END DO
#
# First leg of U
#
   KL11=KL6;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+KL4;
      FKL30, A = RL16, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL15, FD = %RFD%, FF = %RFF%;
   END DO
#
# Top of U
#
   KL11=KL7;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+KL4+KL6;
      FKL30, A = RL14, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL13, FD = %RFD%, FF = %RFF%;
   END DO
#
# Second leg of U
#
   KL11=KL6;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+KL6+3*KL4;
      FKL30, A = RL16, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL15, FD = %RFD%, FF = %RFF%;
   END DO
#
# Output arm
#
   KL11=KL4;
   FOR KL20=1 TO KL11 DO
      KL30=KL10+KL20+2*KL6+3*KL4;
      FKL30, A = RL14, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL13, FD = %RFD%, FF = %RFF%;
   END DO
#
# Generate boundary radiative thermal nodes
#
   KL11=KL9+KL5+2*KL2+1;
   KL12=KL11+1;
   BKL11, T = %RT1%;
   BKL12, T = %RT2%;
#
END DO
#
$CONDUCTORS
#
# Define all conductors for one U-section
#
# Node numbers and number of U-sections
#
KL1=%NX%;KL2=%NY%;KL3=%NU%;
#
# Derived parameters from node numbers
#
KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
#
# Define thermal conductances across x-direction
#
FOR KL9=1 TO %NU% DO
   KL10=1000*KL9;
   KL11=KL1-1;KL12=KL2;
   FOR KL20=1 TO KL11 DO
      FOR KL30=1 TO KL12 DO
         KL40=KL10+(KL30-1)*KL1+KL20;
         KL50=KL40+1;
         GL(KL40,KL50)=RL50;
      END DO
   END DO
#
# Define thermal conductances across y-direction
#
   KL11=KL2-1;KL12=KL1;
   FOR KL20=1 TO KL11 DO
      FOR KL30=1 TO KL12 DO
         KL40=KL10+KL30+(KL20-1)*KL1;
         KL50=KL40+KL1;
         GL(KL40,KL50)=RL51;
      END DO
   END DO
#
# Define thermal / fluid transfer conductances
#      -  done in five sections as for node definitions
#
   KL20=KL10+KL5;
#
# Input arm
#
   KL11=KL4;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30;
      KL50=(KL4-1)*KL1+KL30+KL10;
      KL60=KL50+KL1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# First leg of U
#
   KL11=KL6;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+KL4;
      KL50=(KL4+KL30-1)*KL1+KL4+KL10;
      KL60=KL50+1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Top of U
#
   KL11=KL7;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+KL4+KL6;
      KL50=(KL2-KL4-1)*KL1+KL4+KL30+KL10;
      KL60=KL50+KL1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Second leg of U
#
   KL11=KL6;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+KL4*3+KL6;
      KL50=KL1*(KL2-KL4+1-KL30)-KL4+KL10;
      KL60=KL50+1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Output arm
#
   KL11=KL4;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30+3*KL4+2*KL6;
      KL50=KL4*(KL1-1)+KL30+KL10;
      KL60=KL50+KL1;
      GL(KL40,KL50)=*;
      GL(KL40,KL60)=*;
   END DO
#
# Generate fluid links
#
   KL11=2*KL2-1;
   FOR KL30=1 TO KL11 DO
      KL40=KL20+KL30;
      KL50=KL40+1;
      M(KL40,KL50)=%MFLOW%;
      GP(KL40,KL50)= RL70 / KLOSS;
   END DO
#
# Generate radiative links to boundary
#
   KL11=KL10+KL5+2*KL2+1;
   KL12=KL11+1;
   FOR KL20=1 TO KL5 DO
      KL30=KL20+KL10;
      GR(KL30,KL11)=RL60;
      GR(KL30,KL12)=RL61;
   END DO
END DO
#
# Now generate links between U-sections
#
FOR KL10 = 1 TO %NU%-1 DO
   FOR KL20 = 1 TO %NY% DO
      KL30 = 1000*KL10 + %NX%*KL20;
      KL40 = 1000*(KL10+1) + %NX%*(KL20-1) + 1;
      GL(KL30, KL40) = RL50;
   END DO
   KL50 = KL10*1000 + %NX%*%NY% + 2*%NY%;
   KL60 = (KL10+1)*1000 + %NX%*%NY% + 1;
   M(KL50, KL60) = %MFLOW%;
   GP(KL50, KL60) = RL70 / KLOSS;
END DO
#
$CONSTANTS
$REAL
KLOSS = %KLOSS% ;                      # Resistance coefficient
#
$INITIAL
C
C Local variables:
C I      INTEGER Loop counter
C MU     DOUBLE PRECISION Gemoetric factor
C NODE   INTEGER User node number
C NU     DOUBLE PRECISION Gemoetric factor
C UNITS  INTEGER Loop count upon number of segments
C XCORD  DOUBLE PRECISION X coordinate
C XX1    DOUBLE PRECISION x coordinate of corner 1 of u-tube UNITS
C XX2    DOUBLE PRECISION x coordinate of corner 2 of u-tube UNITS
C XX3    DOUBLE PRECISION x coordinate of corner 3 of u-tube UNITS
C YCORD  DOUBLE PRECISION Y coordinate
C YY1    DOUBLE PRECISION y coordinate of corner 1 of u-tube UNITS
C YY2    DOUBLE PRECISION y coordinate of corner 2 of u-tube UNITS
C YY3    DOUBLE PRECISION y coordinate of corner 3 of u-tube UNITS
C ZCORD  DOUBLE PRECISION Z coordinate
C ZZ1    DOUBLE PRECISION x coordinate of corner 1 of u-tube UNITS
C ZZ2    DOUBLE PRECISION x coordinate of corner 2 of u-tube UNITS
C ZZ3    DOUBLE PRECISION x coordinate of corner 3 of u-tube UNITS
C
        INTEGER I , UNITS , NODE
        DOUBLE PRECISION MU , NU , XCORD , XX1 , XX2 , XX3 , YCORD , YY1
     &                   , YY2 , YY3 , ZCORD , ZZ1 , ZZ2 , ZZ3
        LOGICAL FOUND
#
        FOUND = .FALSE.
        UNITS = 1
#
        REPEAT
#
# Get first fluid node number
#
           NODE = UNITS * 1000 + %NX% * %NY% + 1
#
# Calculate coords of edges of segment no UNITS
#
# Input coords are for edge of plate not edge of segment
#
# Node 2 (RHS bottom)
#
           XX2 = %RFX1% + UNITS / %NU%.0 * (%RFX2% - %RFX1%)
           YY2 = %RFY1% + UNITS / %NU%.0 * (%RFY2% - %RFY1%)
           ZZ2 = %RFZ1% + UNITS / %NU%.0 * (%RFZ2% - %RFZ1%)
#
# Node 1 (LHS bottom)
#
           XX1 = %RFX1% + (UNITS - 1) / %NU%.0 * (%RFX2% - %RFX1%)
           YY1 = %RFY1% + (UNITS - 1) / %NU%.0 * (%RFY2% - %RFY1%)
           ZZ1 = %RFZ1% + (UNITS - 1) / %NU%.0 * (%RFZ2% - %RFZ1%)
#
# Node 3 (LHS top)
#
           XX3 = %RFX3% + (UNITS - 1) / %NU%.0 * (%RFX2% - %RFX1%)
           YY3 = %RFY3% + (UNITS - 1) / %NU%.0 * (%RFY2% - %RFY1%)
           ZZ3 = %RFZ3% + (UNITS - 1) / %NU%.0 * (%RFZ2% - %RFZ1%)
#
# Generate coordinate values for input arm for UNITS
#
           I = 1
           REPEAT
              MU = (FLOAT(I) - 0.5) / %NX%.0
              NU = 0.25 * %NX%.0 / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              I = I + 1
              NODE = NODE + 1
           UNTIL(I .GT. %NX%/4)
#
# Generate coords for first leg of segment UNITS
#
           I = 1
           MU = 0.25
           REPEAT
              NU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GT. %NY% - %NX% / 2)
#
# Generate coords for top of U of segment UNITS
#
           I = 1
           REPEAT
              MU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NX%
              NU = 1.0 - ( %NX%.0 / 4.0 / %NY%.0)
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GT. %NX% / 2)
#
# Second leg of U
#
           I = 1
           MU = 0.75
           REPEAT
              NU = (%NY%.0 - 0.25 * %NX%.0 + 0.5 - FLOAT(I)) / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GT. (%NY% - %NX% / 2))
#
# Output arm
#
           I = 1
           REPEAT
              MU = (FLOAT(I) - 0.5 + 0.75 * %NX%.0) / %NX%.0
              NU = 0.25 * %NX%.0 / %NY%.0
              XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
              YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
              ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
              CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                    FOUND)
#
              NODE = NODE + 1
              I = I + 1
           UNTIL(I .GE. %NX% / 4)
#
           UNITS = UNITS + 1
        UNTIL(UNITS .GT. %NU%)
$ENDMODEL PANEL
$MODEL PANEL1
#
# Model of panel radiator (special case of NU = 1)
#
#  T SWIFT   ----- 23 March 1988
#
$DEFAULTS
RFX1=0.0 ; RFY1=0.0 ; RFZ1=0.0 ;
RFX2=0.0 ; RFY2=0.0 ; RFZ2=0.0 ;
RFX3=0.0 ; RFY3=0.0 ; RFZ3=0.0 ;
RFST = 'P&T' ;
RVQ = 0.0 ;
RFE = 0.0;
RP = 0.0 ;
RT = 0.0 ;
RFF = 0.0 ;                  # no firctional pressure loss
NX = 4 ;                     # number of solid nodes in x direction
NY = 4 ;                     # number of solid nodes in y direction
RRHO = 0.0 ;                 # arithmetic solid nodes
RCP = 0.0 ;                  # arithmetic solid nodes
REMM1 = 1.0 ;                # Emissivity of face 1 (black body)
REMM2 = 1.0 ;                # Emissivity of face 2 (black body)
RVFAC1 = 1.0 ;               # View factor between face 1 and boundary
RVFAC2 = 1.0 ;               # View factor between face 2 and boundary
KLOSS = RL70 * 1.0E-10 ;     # zero pressure loss per link (GP=1.0E10)
#
$LOCALS
#
# Store all parameters in local constants
#
# Node numbers
#
$INTEGER
IL1=%NX%;IL2=%NY%;
#
# Derived parameters from node numbers
#
IL4=IL1/4;IL5=IL1*IL2;IL6=IL2-2*IL4;IL7=IL1/2;
#
# Real versions of node numbers for calculations
#
$REAL
RL1=%NX%.0;RL2=%NY%.0;
#
# Dimensions of each u-section (width, length, and depth)
#
RL3=%LENX%;RL4=%LENY%;RL5=%DZ%;
#
# Conductivity, Cp and density of plate
#
RL6=%RK%;RL7=%RCP%;RL8=%RRHO%;
#
# Fluid length and area for nodes in x-direction
#
RL12=3.14159;
RL13=%LENX%/RL1;             # fluid node length LENX / NX
RL14=0.5*RL12*%RFD%*RL13;    # heat transfer area of fluid nodes in x direction
#
# Fluid length and area for nodes in y-direction
#
RL15=%LENY%/RL2;             # fluid node length LENY / NY
RL16=0.5*RL12*%RFD%*RL15;    # heat transfer area of fluid nodes in y direction
#
# Thermal node dimensions
#
RL20=RL3/RL1;RL21=RL4/RL2;   # LENX / NX and LENY / NY
#
# Thermal capacitance of thermal nodes
#
RL30=RL5*RL20*RL21*RL7*RL8;  # DZ * LENX / NX * LENY / NY * Cp * RHO
#
# Heat transfer areas for thermal nodes -
#                     X and Y directions]
#
RL40=RL5*RL21; RL41=RL5*RL20; # DZ * LENY / NY and DZ * LENX / NX
#
# Conductances in X and Y directions
#
RL50=RL40*RL6/RL20;  # DZ * LENY / NY * EK * NX / LENX
RL51=RL41*RL6/RL21;  # DZ * LENX / NX * EK * NY / LENY
#
# Radiative conductance values
#
RL60=%REMM1%*%RVFAC1%*RL20*RL21;
RL61=%REMM2%*%RVFAC2%*RL20*RL21;
#
RL70 = 2.0 * %NY%.0 - 1.0;      # No of flow links generated
$NODES
#
# Node definitions for one u-plate section
#
#
# Node numbers and number of u-sections
#
KL1=%NX%;KL2=%NY%;
#
# Derived parameters from node numbers
#
KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
KL9=1000;
KL10=KL9;
#
# Generate thermal nodes
#
FOR KL20=1 TO KL5 DO
   KL30=KL10+KL20;
   DKL30, T = %RTP%, C = RL30;
END DO
#
# Generate fluid nodes in five sections
#
KL10=KL9+KL5;
#
# Input arm (xyz coordinates definied within $INITIAL block)
#
FOR KL20=1 TO KL4 DO
   KL30=KL10+KL20;
   FKL30, A = RL14, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
          VQ = %RVQ%, FL = RL13, FD = %RFD%, FF = %RFF%;
END DO
#
# First leg of U
#
KL11=KL6;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+KL4;
   FKL30, A = RL16, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
          VQ = %RVQ%, FL = RL15, FD = %RFD%, FF = %RFF%;
END DO
#
# Top of U
#
KL11=KL7;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+KL4+KL6;
   FKL30, A = RL14, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
         VQ = %RVQ%, FL = RL13, FD = %RFD%, FF = %RFF%;
END DO
#
# Second leg of U
#
KL11=KL6;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+KL6+3*KL4;
   FKL30, A = RL16, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL15, FD = %RFD%, FF = %RFF%;
END DO
#
# Output arm
#
KL11=KL4;
FOR KL20=1 TO KL11 DO
   KL30=KL10+KL20+2*KL6+3*KL4;
   FKL30, A = RL14, FST = %RFST%, T = %RT%, FE =  %RFE%, P = %RP%,
            VQ = %RVQ%, FL = RL13, FD = %RFD%, FF = %RFF%;
END DO
#
# Generate boundary radiative thermal nodes
#
KL11=KL9+KL5+2*KL2+1;
KL12=KL11+1;
BKL11, T = %RT1%;
BKL12, T = %RT2%;
#
$CONDUCTORS
#
# Define all conductors for one U-section
#
# Node numbers and number of U-sections
#
KL1=%NX%;KL2=%NY%;
#
# Derived parameters from node numbers
#
KL4=KL1/4;KL5=KL1*KL2;KL6=KL2-2*KL4;KL7=KL1/2;
#
# Define thermal conductances across x-direction
#
KL10=1000;
KL11=KL1-1;KL12=KL2;
FOR KL20=1 TO KL11 DO
   FOR KL30=1 TO KL12 DO
      KL40=KL10+(KL30-1)*KL1+KL20;
      KL50=KL40+1;
      GL(KL40,KL50)=RL50;
   END DO
END DO
#
# Define thermal conductances across y-direction
#
KL11=KL2-1;KL12=KL1;
FOR KL20=1 TO KL11 DO
   FOR KL30=1 TO KL12 DO
      KL40=KL10+KL30+(KL20-1)*KL1;
      KL50=KL40+KL1;
      GL(KL40,KL50)=RL51;
   END DO
END DO
#
# Define thermal / fluid transfer conductances
#      -  done in five sections as for node definitions
#
KL20=KL10+KL5;
#
# Input arm
#
KL11=KL4;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30;
   KL50=(KL4-1)*KL1+KL30+KL10;
   KL60=KL50+KL1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# First leg of U
#
KL11=KL6;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+KL4;
   KL50=(KL4+KL30-1)*KL1+KL4+KL10;
   KL60=KL50+1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Top of U
#
KL11=KL7;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+KL4+KL6;
   KL50=(KL2-KL4-1)*KL1+KL4+KL30+KL10;
   KL60=KL50+KL1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Second leg of U
#
KL11=KL6;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+KL4*3+KL6;
   KL50=KL1*(KL2-KL4+1-KL30)-KL4+KL10;
   KL60=KL50+1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Output arm
#
KL11=KL4;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30+3*KL4+2*KL6;
   KL50=KL4*(KL1-1)+KL30+KL10;
   KL60=KL50+KL1;
   GL(KL40,KL50)=*;
   GL(KL40,KL60)=*;
END DO
#
# Generate fluid links
#
KL11=2*KL2-1;
FOR KL30=1 TO KL11 DO
   KL40=KL20+KL30;
   KL50=KL40+1;
   M(KL40,KL50)=%MFLOW%;
   GP(KL40,KL50)= RL70 / KLOSS;
END DO
#
# Generate radiative links to boundary
#
KL11=KL10+KL5+2*KL2+1;
KL12=KL11+1;
FOR KL20=1 TO KL5 DO
   KL30=KL20+KL10;
   GR(KL30,KL11)=RL60;
   GR(KL30,KL12)=RL61;
END DO
#
$CONSTANTS
$REAL
KLOSS = %KLOSS% ;                 # Resistance coefficient
#
$INITIAL
C
C Local variables:
C I      INTEGER Loop counter
C MU     DOUBLE PRECISION Geometric factor
C NODE   INTEGER User node number
C NU     DOUBLE PRECISION Geometric factor
C XCORD  DOUBLE PRECISION X coordinate
C XX1    DOUBLE PRECISION x coordinate of corner 1 of u-tube
C XX2    DOUBLE PRECISION x coordinate of corner 2 of u-tube
C XX3    DOUBLE PRECISION x coordinate of corner 3 of u-tube
C YCORD  DOUBLE PRECISION Y coordinate
C YY1    DOUBLE PRECISION y coordinate of corner 1 of u-tube
C YY2    DOUBLE PRECISION y coordinate of corner 2 of u-tube
C YY3    DOUBLE PRECISION y coordinate of corner 3 of u-tube
C ZCORD  DOUBLE PRECISION Z coordinate
C ZZ1    DOUBLE PRECISION x coordinate of corner 1 of u-tube
C ZZ2    DOUBLE PRECISION x coordinate of corner 2 of u-tube
C ZZ3    DOUBLE PRECISION x coordinate of corner 3 of u-tube
C
        INTEGER I , NODE
        DOUBLE PRECISION MU , NU , XCORD , XX1 , XX2 , XX3 , YCORD , YY1
     &                   , YY2 , YY3 , ZCORD , ZZ1 , ZZ2 , ZZ3
        LOGICAL FOUND
#
        FOUND = .FALSE.
#
# Get first fluid node number
#
        NODE = 1000 + %NX% * %NY% + 1
#
# Node 2 (RHS bottom)
#
        XX2 = %RFX2%
        YY2 = %RFY2%
        ZZ2 = %RFZ2%
#
# Node 1 (LHS bottom)
#
        XX1 = %RFX1%
        YY1 = %RFY1%
        ZZ1 = %RFZ1%
#
# Node 3 (LHS top)
#
        XX3 = %RFX3%
        YY3 = %RFY3%
        ZZ3 = %RFZ3%
#
# Generate coordinate values for input arm
#
        I = 1
        REPEAT
           MU = (FLOAT(I) - 0.5) / %NX%.0
           NU = 0.25 * %NX%.0 / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           I = I + 1
           NODE = NODE + 1
        UNTIL(I .GT. %NX%/4)
#
# Generate coords for first leg
#
        I = 1
        MU = 0.25
        REPEAT
           NU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GT. %NY% - %NX% / 2)
#
# Generate coords for top of U
#
        I = 1
        REPEAT
           MU = (FLOAT(I) - 0.5 + 0.25 * %NX%.0) / %NX%
           NU = 1.0 - ( %NX%.0 / 4.0 / %NY%.0)
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GT. %NX% / 2)
#
# Second leg of U
#
        I = 1
        MU = 0.75
        REPEAT
           NU = (%NY%.0 - 0.25 * %NX%.0 + 0.5 - FLOAT(I)) / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GT. (%NY% - %NX% / 2))
#
# Output arm
#
        I = 1
        REPEAT
           MU = (FLOAT(I) - 0.5 + 0.75 * %NX%.0) / %NX%.0
           NU = 0.25 * %NX%.0 / %NY%.0
           XCORD = (1.0D0 - MU - NU) * XX1 + MU * XX2 + NU * XX3
           YCORD = (1.0D0 - MU - NU) * YY1 + MU * YY2 + NU * YY3
           ZCORD = (1.0D0 - MU - NU) * ZZ1 + MU * ZZ2 + NU * ZZ3
#
           CALL COORDS(CURRENT , NODE , XCORD , YCORD , ZCORD ,
     &                 FOUND)
#
           NODE = NODE + 1
           I = I + 1
        UNTIL(I .GE. %NX% / 4)
#
$ENDMODEL PANEL1
$MODEL PASSA
# Passive accumulator
#
# Origin: FHTS Upgrade 1 9197/90/NL/PP: ERC/92:4:11/JHS
#
$DEFAULTS
#
AFX=0.0 ; AFY=0.0 ; AFZ=0.0 ;
AFST = 'P&T';           # Fluid state descriptor
AVQ = 0.0;              # Vapour quality
AP = 0.0;               # Fluid pressure
AT = 0.0;               # Fluid temperature
AFE = 0.0;              # Fluid enthalpy
AFLA = RL2;             # Flow area
AA = RL3;               # Heat transfer area
PPOS = 0.5;             # Piston position
#
$LOCALS
#
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %AFD% * %AFD% / 4.0 ;         # Flow area
RL3 = 4.0 * %PPOS% * %VOLACC% / %AFD%;    # Heat transfer area
#
$NODES
#
# Nodal length calculated from the volume within $INITIAL -
#    Note that the solution updates the length from the volume.
#
F1, A = %AA%, FD = %AFD%, FLA = %AFLA%, FL = 0.0,
    FST = %AFST%, T = %AT%, P = %AP%, FE = %AFE%, VQ = %AVQ%,
    FF = 0.0, FX = %AFX% , FY = %AFY% , FZ = %AFZ% ;
#
$CONSTANTS
#
$CHARACTER
PATYPE = %PATYPE%;
#
$REAL
GAMMA = %GAMMA%;        # Ratio of specific heats
PPOS = %PPOS%;          # Position of piston
#
$INITIAL
#
# Set to length changing
#
      CALL VOLST(F1 , 'L')
#
      FL1 = %PPOS% * %VOLACC% / FLA1
#
$VARIABLES1
#
# Update piston position
#
      PPOS = VOL1 / %VOLACC%
#
      IF (.NOT. (VOL1 .LT. 1.0E-37)) THEN
#
         IF (PATYPE .EQ. 'THEQM') THEN
#
# Thermal-equilibrium type
#
            CMP1 = (%VOLACC% - VOL1) / (P1 * VOL1)
#
         ELSE IF(PATYPE .EQ. 'ADIAB') THEN
#
# Adiabatic type
#
            CMP1 = (%VOLACC% - VOL1) / (GAMMA * P1 * VOL1)
#
         ELSE
#
# Error
#
         END IF
#
      ELSE
#
# Compliance large number
#
         CMP1 = 1.0E32
#
      END IF
#
$ENDMODEL PASSA
$MODEL PUMP_CF
#
# PURPOSE:     This model simulates a variable-speed centrifugal pump.
# DESCRIPTION: A pump is represented by 2 F-type fluid nodes connected
#              by a single link. Similarity laws are used to scale the
#              characteristics to account for both speed and density
#              changes. The library routine SETDPV is utilised to define
#              a pressure source and its derivative wrt volumetric flow
#              rate for the pump link.
# ORIGIN:      FHTS: Maintenance 96/97: Upgrade (1) MEC/98.07.15/WJ
#
# ======================================================================
#
# SUBSTITUTIONS DATA:
#   CHAR_TYPE - CHARACTER (OPTIONAL) Pump characteristic type:
#                         'TABLE' for a tabular data set
#                         'POLY'  for a polynomial data set
#   DIAM      - REAL (COMPULSORY) Pump hydraulic diameter (for both
#                    nodes)
#   DP_ARRAY  - REAL ARRAY (OPTIONAL) Pressure head array (pressure
#                          change over the link at a given flow rate)
#   EFF_ARRAY - REAL ARRAY (OPTIONAL) Hydraulic efficiency array (at a
#                          given flow rate)
#   MFLOW     - REAL (COMPULSORY) Mass flow rate
#   PRESS     - REAL (COMPULSORY) Fluid pressure (for both nodes)
#   REL_HUM   - REAL (OPTIONAL) Relative humidity (for fluid type 'AIRW')
#   RHO_REF   - REAL (OPTIONAL) Reference density
#   SPEED     - REAL (OPTIONAL) Pump speed (rpm)
#   TEMP      - REAL (COMPULSORY) Fluid temperature (for both nodes)
#   VF_ARRAY  - REAL ARRAY (OPTIONAL) Volumetric flow rate array (used
#                          if CHAR_TYPE = 'TABLE')
#   VOL       - REAL (COMPULSORY) Total volume of fluid in pump
#   X_COORD   - REAL (OPTIONAL) x-coordinate
#   Y_COORD   - REAL (OPTIONAL) y-coordinate
#   Z_COORD   - REAL (OPTIONAL) z-coordinate
#
# ======================================================================
#
$DEFAULTS
#
CHAR_TYPE = 'TABLE' ;
VF_ARRAY  = 0.0 ;
DP_ARRAY  = 0.0 ;
EFF_ARRAY = 1.0 ;
RHO_REF   = RHO(F1) ;
SPEED     = 1000.0 ;
REL_HUM   = 0.0 ;
X_COORD   = 0.0 ;
Y_COORD   = 0.0 ;
Z_COORD   = 0.0 ;
#
$LOCALS
#
$REAL
#
PI   = 3.14159265359 ;
EFLA = PI * %DIAM% * %DIAM% / 4.0 ;  # pump flow area (circular x-section)
EFL  = %VOL% / EFLA ;                # pump length
#
$NODES
#
F1 , P = %PRESS% , FD = %DIAM% , FL = EFL / 2.0 , T = %TEMP% ,
     A = 0.0 , FF = 0.0 , FLA = EFLA , FST = 'P&T' , PHI = %REL_HUM% ,
     FX = %X_COORD% , FY = %Y_COORD% , FZ = %Z_COORD% ;
F2 , P = %PRESS% , FD = %DIAM% , FL = EFL / 2.0 , T = %TEMP% ,
     A = 0.0 , FF = 0.0 , FLA = EFLA , FST = 'P&T' , PHI = %REL_HUM% ,
     FX = %X_COORD% , FY = %Y_COORD% , FZ = %Z_COORD% ;
#
$CONDUCTORS
#
M(1,2) = %MFLOW% ;
#
$ARRAYS
#
# characteristic arrays at initial pump operating speed
#
VF_ARRAY  = %VF_ARRAY% ;
DP_ARRAY  = %DP_ARRAY% ;
EFF_ARRAY = %EFF_ARRAY% ;
#
$CONSTANTS
#
$INTEGER
#
VF_SIZE  = 0 ;  # size of VF_ARRAY (number of data points in array)
DP_SIZE  = 0 ;  # size of DP_ARRAY
EFF_SIZE = 0 ;  # size of EFF_ARRAY
#
$CHARACTER
#
CHAR_TYPE = %CHAR_TYPE% ;
#
$REAL
#
RHO_REF     = 0.0 ;      # reference density (set in $INITIAL block)
SPEED_REF   = %SPEED% ;  # reference speed
SPEED       = %SPEED% ;  # current pump speed
APPROX_ZERO = 1.0D-10 ;
#
$SUBROUTINES
#
# ======================================================================
#
      SUBROUTINE TABLECALC(VOLFLR , DP , DPDV , EFF)
#
# PURPOSE: Perform linear interpolation upon both DP_ARRAY with
#          VF_ARRAY, and EFF_ARRAY with VF_ARRAY to find the current
#          values of delta pressure and efficiency for the specified
#          volumetric flow rate. The derivative of pressure is also
#          returned.
# METHOD:  Find relevant points bounding current flow rate. If the
#          current flow rate is out of array bounds, return the
#          limiting value and set the derivative to zero. Interpolate
#          points within bounds and evaluate DP, DPDV and EFF.
#
# INPUT:
#   VOLFLR - Volumetric flow rate
#
# OUTPUT:
#   DP   - Value of link delta pressure (dP)
#   DPDV - Value of pressure derivative d(dP)/dV
#   EFF  - Value of efficiency
#
# LOCAL:
#   DDP  - Distance between points DP1 and DP2 in pressure array
#   DEFF - Distance between points EFF1 and EFF2 in efficiency array
#   DP1  - Pressure array data point from DP_ARRAY
#   DP2  - Next pressure array data point from DP_ARRAY
#   DVF  - Distance between points VF1 and VF2 in volumetric flow
#             rate array
#   EFF1 - Efficiency array data point from EFF_ARRAY
#   EFF2 - Next efficiency array data point from EFF_ARRAY
#   VF1  - Volumetric flow rate array data point from VF_ARRAY
#   VF2  - Next volumetric flow rate array data point from VF_ARRAY
#
      CHARACTER MESAGE * 255 , SNAME * 7
#
      INTEGER ERRNUM , I , TYPE
#
      DOUBLE PRECISION DDP , DEFF , DP , DPDV , DP1 , DP2 , DVF , EFF ,
     &                 EFF1 , EFF2 , VF1 , VF2 , VOLFLR
#
      LOGICAL FOUND
#
      FOUND = .FALSE.
#
# check for volumetric flow rate smaller or larger than range of array
# data and set to limiting value if true. If array size is 1 data point
# only, this condition is also found by this check
#
      IF (VOLFLR .LE. VF_ARRAY(1)) THEN
         DP   = DP_ARRAY(1)
         EFF  = EFF_ARRAY(1)
         DPDV = 0.0D0
      ELSE IF (VOLFLR .GE. VF_ARRAY(VF_SIZE)) THEN
         DP   = DP_ARRAY(VF_SIZE)
         EFF  = EFF_ARRAY(EFF_SIZE)
         DPDV = 0.0D0
      ELSE
#
# calculate required data values from characteristics and interpolate
# delta pressure and efficiency and the derivative of delta pressure
# wrt volumetric flow rate
#
         I = 1
#
         REPEAT
#
            IF (VOLFLR .GT. VF_ARRAY(I) .AND.
     &      VOLFLR .LE. VF_ARRAY(I+1)) THEN
               VF1  = VF_ARRAY(I)
               VF2  = VF_ARRAY(I+1)
               DP1  = DP_ARRAY(I)
               DP2  = DP_ARRAY(I+1)
               EFF1 = EFF_ARRAY(I)
               EFF2 = EFF_ARRAY(I+1)
               DEFF = EFF2 - EFF1
               DVF  = VF2 - VF1
               DDP  = DP2 - DP1
#
# interpolation successful - assign values to output variables
#
               IF (ABS(DVF) .GT. APPROX_ZERO) THEN
                  DPDV = DDP / DVF
                  DP   = DP1 + DPDV * (VOLFLR - VF1)
                  EFF  = EFF1 + (DEFF / DVF) * (VOLFLR - VF1)
               ELSE
#
# 2 pressure values given for the same point - assign values
#
                  DP   = DP1
                  DPDV = 0.0D0
                  EFF  = EFF1
               END IF
#
               FOUND = .TRUE.
#
            END IF
#
            I = I + 1
#
         UNTIL ((I .GE. VF_SIZE) .OR. FOUND)
#
         IF (.NOT. FOUND) THEN
#
# interpolation failed - return zero values for output variables
#
            DP   = 0.0D0
            DPDV = 0.0D0
            EFF  = 0.0D0
#
            SNAME  = 'PUMP_CF'
            MESAGE = 'Interpolation data point for pump not found@' //
     &               'Volumetric flow rate required not found within' //
     &               ' range of data points supplied. Check values' //
     &               ' in VF_ARRAY are listed in ascending order.'
            TYPE   = 3
            ERRNUM = 1
#
            CALL SETERX(MESAGE , TYPE , ERRNUM , SNAME)
#
         END IF
#
      END IF
#
      RETURN
#
      END
#
# ======================================================================
#
      SUBROUTINE POLYCALC(VOLFLR , DP , DPDV , EFF)
#
# PURPOSE: Use both DP_ARRAY and EFF_ARRAY to calculate the current
#          values of pressure and efficiency for the current volumetric
#          flow rate and the pressure derivative wrt volumetric flow
#          rate at the point. The pressure derivative is returned.
# METHOD:  Evaluate the polynomial and the derivative. Note that the
#          order of the efficiency polynomial and the delta pressure
#          polynomial may be different.
#
# INPUT:
#   VOLFLR - Volumetric flow rate
#
# OUTPUT:
#   DP   - Value of link delta pressure (dP)
#   DPDV - Value of pressure derivative d(dP)/dV
#   EFF  - Value of efficiency
#
# LOCAL:
#   COEFFE - Co-efficient from efficiency polynomial
#   COEFFP - Co-efficient from pressure head polynomial
#   POWER  - Power of term in pressure or efficiency polynomial
#
      INTEGER I , POWER
#
      DOUBLE PRECISION COEFFE , COEFFP , DP, DPDV , EFF , VOLFLR
#
# set DP, DPDV and EFF to initialised value "a" from the polynomial
# equation a+bV+cV2+dV3+...
#
      DP   = DP_ARRAY(1)
      EFF  = EFF_ARRAY(1)
      DPDV = 0.0D0
#
      POWER = 1
#
# evaluate polynomial bV+cV2+dV3+... and the derivative b+2cV+3dV2+...
#
      WHILE (POWER .LT. DP_SIZE)
         COEFFP = DP_ARRAY(POWER + 1)
         DP     = DP + COEFFP * VOLFLR ** POWER
         DPDV   = DPDV + DBLE(POWER) * COEFFP * VOLFLR ** (POWER - 1)
#
         POWER  = POWER + 1
#
      END WHILE
#
      POWER = 1

      WHILE (POWER .LT. EFF_SIZE)
         COEFFE = EFF_ARRAY(POWER + 1)
         EFF    = EFF + COEFFE * VOLFLR ** POWER
#
         POWER  = POWER + 1
#
      END WHILE
#
      RETURN
#
      END
#
# ======================================================================
#
$INITIAL
#
# LOCAL:
#   ERRNUM - Error number
#   MESAGE - Error message string
#   SNAME  - String containing element name
#   TYPE   - Error type
#
      CHARACTER MESAGE * 255 , SNAME * 7
#
      INTEGER ERRNUM , TYPE
#
# set characteristic array sizes for pressure and efficiency
#
      DP_SIZE  = ASIZE(DP_ARRAY)
      EFF_SIZE = ASIZE(EFF_ARRAY)

      IF (CHAR_TYPE .EQ. 'TABLE') THEN
#
# table characteristic data - set volumetric flow rate size and check
# the pressure and efficiency array sizes - these should have the size
# determined by the volumetric flow rate array
#
         VF_SIZE  = ASIZE(VF_ARRAY)
#
         IF ((VF_SIZE .NE. DP_SIZE) .OR.
     &      (VF_SIZE .NE. EFF_SIZE)) THEN
            SNAME  = 'PUMP_CF'
            MESAGE = 'Pump characteristic arrays not the same size@' //
     &               'The number of data values of both the pressure' //
     &               ' and efficiency characteristics must be the' //
     &               ' same as the number in the volumetric flow' //
     &               ' rate array.'
            TYPE   = 4
            ERRNUM = 2
#
            CALL SETERX(MESAGE , TYPE , ERRNUM , SNAME)
#
         END IF
#
      END IF
#
# check for speed greater than zero
#
      IF (ABS(SPEED_REF) .LE. APPROX_ZERO) THEN
         SNAME  = 'PUMP_CF'
         MESAGE = 'Invalid reference pump speed defined@' //
     &            'Pump reference speed must be non-zero.'
         TYPE   = 4
         ERRNUM = 3
#
         CALL SETERX(MESAGE , TYPE , ERRNUM , SNAME)
#
      END IF
#
# set reference density - GENMOR used to initialise fluid state
#
      GENMOR
      RHO_REF = %RHO_REF%
#
$VARIABLES1
#
# LOCAL:
#   DPDVRF - Reference value of d(dP)/dV
#   DPDVS  - Value of d(dP)/dV using current density and speed
#   DPREF  - Reference value of dP
#   DPS    - Value of dP using current density and speed
#   EFF    - Value for efficiency
#   ERRNUM - Error number
#   MESAGE - Error message string
#   RHOJ   - Flow link fluid density (at upstream node)
#   SNAME  - String containing element name
#   SPEEDR - Ratio SPEED / SPEED_REF
#   TYPE   - Error type
#   VOLR   - Current volumetric flow rate
#   VOLREF - Reference volumetric flow rate
#
      CHARACTER MESAGE * 255 , SNAME * 7
#
      INTEGER ERRNUM , TYPE
#
      DOUBLE PRECISION DPDVRF , DPDVS , DPREF , DPS , EFF , RHOJ ,
     &                 SPEEDR , VOLR , VOLREF
#
# initialise to zero
#
      DPREF  = 0.0D0
      DPDVRF = 0.0D0
      EFF    = 0.0D0
#
# check mass flow direction in link and calculate the volumetric flow
# rate from the current density
#
      IF (M(1,2) .GT. 0.0D0) THEN
         RHOJ = RHO(F1)
      ELSE
         RHOJ = RHO(F2)
      END IF
#
      VOLR = M(1,2) / RHOJ
#
# scale volumetric flow rate to reference curve. Note that efficiency
# is not scaled to a reference value
#
      SPEEDR = ABS(SPEED / SPEED_REF)
#
      IF (SPEEDR .GT. APPROX_ZERO) THEN
         VOLREF = VOLR / SPEEDR
#
         IF (CHAR_TYPE .EQ. 'TABLE') THEN
#
            CALL TABLECALC(VOLREF , DPREF , DPDVRF , EFF)
#
         ELSE IF (CHAR_TYPE .EQ. 'POLY') THEN
#
            CALL POLYCALC(VOLREF , DPREF , DPDVRF , EFF)
#
         ELSE
            SNAME  = 'PUMP_CF'
            MESAGE = 'Invalid CHAR_TYPE defined@' //
     &               'Pump characteristic type defined by CHAR_TYPE' //
     &               ' must be either TABLE or POLY (default = TABLE).'
            TYPE   = 3
            ERRNUM = 4
#
            CALL SETERX(MESAGE , TYPE , ERRNUM , SNAME)
#
         END IF
#
# scale DPREF and DPDVRF from reference curve. Efficiency remains
# unscaled
#
         DPS   = (RHOJ / RHO_REF) * (SPEEDR ** 2) * DPREF
         DPDVS = (RHOJ / RHO_REF) * SPEEDR * DPDVRF
      ELSE
#
# pump speed zero - set values of DPS and DPDVS to zero
#
         DPS   = 0.0D0
         DPDVS = 0.0D0
      END IF
#
$FLUID
#
# assign user-defined pressure source and the derivative for the link
#
      CALL SETDPV('M(1,2)' , DPS , DPDVS)
#
$THERMAL
#
# calculate work done on the fluid - set heat source on the outlet
#
      IF (SPEEDR .GT. APPROX_ZERO) THEN
#
         IF (ABS(EFF) .GT. APPROX_ZERO) THEN
#
            IF (M(1,2) .GT. 0.0D0) THEN
               FQ2 = VOLR * DPS / EFF
               FQ1 = 0.0D0
            ELSE
               FQ1 = VOLR * DPS / EFF
               FQ2 = 0.0D0
            END IF
#
         ELSE
#
# zero efficiency case - heat source term unchanged from previous value
#
            SNAME  = 'PUMP_CF'
            MESAGE = 'Pump efficiency of zero found@' //
     &               'Current volumetric flow rate = '
            WRITE(MESAGE(62 : ) , 9000) VOLR
            TYPE   = 2
            ERRNUM = 5
#
            CALL SETERX(MESAGE , TYPE , ERRNUM , SNAME)
#
         END IF
#
      ELSE
#
# zero speed case - heat source term set to zero
#
         FQ1 = 0.0D0
         FQ2 = 0.0D0
      END IF
#
 9000 FORMAT (G11.5E2)
#
$ENDMODEL PUMP_CF
$MODEL TEE
#
# Standard tee-piece element with fitting loss
#  Solution routines automatically take into account
#  pressure changes due to direction change. TGP
#  substitution data provided to allow specification
#  of irreversible losses.
#
# Mandatory data is TFD1, TFD2, TFL1, TFL2 and MFLOW.
#
$DEFAULTS
#
TGP=1.0D10 ;
TFX1  = 0.0 ; TFX2  = 0.0 ;
TFY1  = 0.0 ; TFY2  = 0.0 ;
TFZ1  = 0.0 ; TFZ2  = 0.0 ;
TA1   = RL2 ; TA2   = RL3 ;
TFLA1 = RL4 ; TFLA2 = RL5 ;
TFST = 'P&T' ;
TFE1  = 0.0 ; TFE2  = 0.0 ;
TT1   = 0.0 ; TT2   = 0.0 ;
TP1   = 0.0 ; TP2   = 0.0 ;
TVQ1  = 0.0 ; TVQ2  = 0.0 ;
TFF1  = 0.0 ; TFF2  = 0.0 ;
#
$LOCALS
#
$REAL
RL1 = 3.1415927 ;                   # PI value
RL2 = RL1 * %TFD1% * %TFL1% ;       # Heat transfer area of inlet
RL3 = RL1 * %TFD2% * %TFL2% ;       # Heat transfer area of outlet
RL4 = RL1 * %TFD1% * %TFD1% / 4.0 ; # Flow area of inlet
RL5 = RL1 * %TFD2% * %TFD2% / 4.0 ; # Flow area of outlet
#
$NODES
#
# Main line node
#
Q1, A = %TA1%, FD = %TFD1%, FL = %TFL1%, FLA = %TFLA1%,
    FST = %TFST%, P = %TP1%, T = %TT1%, FE = %TFE1%, VQ = %TVQ1%,
    FF = %TFF1%, FX = %TFX1%, FY = %TFY1%, FZ = %TFZ1%;
#
# Branch node
#
S2, A = %TA2%, FD = %TFD2%, FL = %TFL2%, FLA = %TFLA2%,
    FST = %TFST%, P = %TP2%, T = %TT2%, FE = %TFE2%, VQ = %TVQ2%,
    FF = %TFF2%, FX = %TFX2%, FY = %TFY2%, FZ = %TFZ2%;
#
$CONDUCTORS
#
M(1, 2)  = %MFLOW%;
GP(1, 2) = %TGP%;    # irreversible pressure loss coefficient
#
$ENDMODEL
$MODEL TEEFN
#
$DEFAULTS
#
TA1 = RL2 ; TA2 = RL3 ; TA3 = RL4 ;
TFLA1 = RL5 ; TFLA2 = RL6 ; TFLA3 = RL7 ;
TFX1 = 0.0 ; TFX2 = 0.0 ; TFX3 = 0.0 ;
TFY1 = 0.0 ; TFY2 = 0.0 ; TFY3 = 0.0 ;
TFZ1 = 0.0 ; TFZ2 = 0.0 ; TFZ3 = 0.0 ;
TFST = 'P&T' ;
TFE1 = 0.0 ; TFE2 = 0.0 ; TFE3 = 0.0 ;
TT1 = 0.0 ; TT2 = 0.0 ; TT3 = 0.0 ;
TP1 = 0.0 ; TP2 = 0.0 ; TP3 = 0.0 ;
TVQ1 = 0.0 ; TVQ2 = 0.0 ; TVQ3 = 0.0 ;
TFF1 = 0.0 ; TFF2 = 0.0 ; TFF3 = 0.0 ;
ANGLE = 90.0 ;     # Default to right angled tee piece
#
$LOCALS
#
$REAL
RL1 = 3.1415927 ;                   # PI value
RL2 = RL1 * %TFD1% * %TFL1% ;       # Heat transfer area of node 1
RL3 = RL1 * %TFD2% * %TFL2% ;       # Heat transfer area of node 2
RL4 = RL1 * %TFD3% * %TFL3% ;       # Heat transfer area of node 3
RL5 = RL1 * %TFD1% * %TFD1% / 4.0 ; # Flow area of node 1
RL6 = RL1 * %TFD2% * %TFD2% / 4.0 ; # Flow area of node 2
RL7 = RL1 * %TFD3% * %TFD3% / 4.0 ; # Flow area of node 3
RL8 = RL1 * %TFD1% * %TFLI% ;       # Heat transfer area of node 10
#
$NODES
F1,A=%TA1%,FD=%TFD1%,FL=%TFL1%,P=%TP1%,T=%TT1%,FF=%TFF1%,FE=%TFE1%,
   VQ=%TVQ1%,FST=%TFST%,FLA=%TFLA1%,
   FX=%TFX1%,FY=%TFY1%,FZ=%TFZ1%;
F2,A=%TA2%,FD=%TFD2%,FL=%TFL2%,P=%TP2%,T=%TT2%,FF=%TFF2%,FE=%TFE2%,
   VQ=%TVQ2%,FST=%TFST%,FLA=%TFLA2%,
   FX=%TFX2%,FY=%TFY2%,FZ=%TFZ2%;
F3,A=%TA3%,FD=%TFD3%,FL=%TFL3%,P=%TP3%,T=%TT3%,FF=%TFF3%,FE=%TFE3%,
   VQ=%TVQ3%,FST=%TFST%,FLA=%TFLA3%,
   FX=%TFX3%,FY=%TFY3%,FZ=%TFZ3%;
F10,A=RL8,FD=%TFD1%,FL=%TFLI%,P=%TP1%,T=%TT1%,FF=%TFF1%,FE=%TFE1%,
   VQ=%TVQ1%,FST=%TFST%,FLA=%TFLA1%,
   FX=(%TFX2%-%TFX1%)*0.5+%TFX1%,FY=(%TFY2%-%TFY1%)*0.5+%TFY1%,
   FZ=(%TFZ2%-%TFZ1%)*0.5+%TFZ1%;
#
$CONDUCTORS
      M(1,10) = %MFLOW1% ;
      M(2,10) = %MFLOW2% ;
      M(3,10) = %MFLOW3% ;
#
$CONSTANTS
$REAL
      ANG0 = %ANGLE%;
      ANG = %ANGLE%;
      AU1 = 0.1;
      AU2 = 0.1;
      AU3 = 0.1;
      AA  = 0.1;
      KR1 = 0.1;
      KR2 = 0.1;
      KR3 = 0.1;
      KR4 = 0.1;
      KS4 = 0.1;
      KS5 = 0.1;
      KS6 = 0.1;
#
$ARRAYS
$REAL
ZPR1(2,4)  = 0.0,0.02, 0.03,0.05, 0.05,0.10, 0.1,0.20;
ZPR2(2,4)  = 0.0,0.04, 0.03,0.08, 0.05,0.10, 0.1,0.20;
ZPR3(2,6)  = 0.0,0.08, 0.03,0.12, 0.05,0.18, 0.1,0.25, 0.2,0.34,
             0.3,0.32;
ZPR4(2,8)  = 0.0,0.45, 0.03,0.50, 0.05,0.52, 0.1,0.59, 0.2,0.66,
             0.3,0.64, 0.40,0.62, 0.50,0.58;
ZPR5(2,10) = 0.0,1.00, 0.03,1.04, 0.05,1.06, 0.1,1.16, 0.2,1.25,
             0.3,1.28, 0.40,1.22, 0.50,1.10, 0.6,0.88, 0.7,0.70;
ZPR6(2,14) = 0.0,1.00, 0.10,0.81, 0.20,0.64, 0.3,0.50, 0.4,0.36,
             0.5,0.25, 0.60,0.16, 0.80,0.04, 1.0,0.00, 1.2,0.07,
             1.4,0.39, 1.60,0.90, 1.80,1.78, 2.0,3.20;
ZPR7(2,14) = 0.0,1.00, 0.10,0.81, 0.20,0.64, 0.3,0.52, 0.4,0.40,
             0.5,0.30, 0.60,0.23, 0.80,0.16, 1.0,0.20, 1.2,0.36,
             1.4,0.78, 1.60,1.36, 1.80,2.43, 2.0,4.00;
ZPR8(2,12) = 0.0,1.00, 0.10,0.81, 0.20,0.64, 0.3,0.52, 0.4,0.38,
             0.5,0.28, 0.60,0.20, 0.80,0.12, 1.0,0.10, 1.2,0.21,
             1.4,0.59, 1.60,1.15;
ZPR9(2,11) = 0.0,1.00, 0.10,0.81, 0.20,0.64, 0.3,0.50, 0.4,0.37,
             0.5,0.26, 0.60,0.18, 0.80,0.07, 1.0,0.05, 1.2,0.14,
             1.4,0.49;
ZPR10(2,10)= 0.0,1.00, 0.10,0.81, 0.20,0.64, 0.3,0.50, 0.4,0.36,
             0.5,0.25, 0.60,0.16, 0.80,0.04, 1.0,0.00, 1.2,0.07;
#
$INITIAL
      AU1 = FLA1
      AU2 = FLA2
      AU3 = FLA3
C
      ANG = ANG0
C
      IF (AU3/AU2 .LE. 0.2D0) THEN
        AA = 1.0D0
      ELSE IF (AU3/AU2 .LE. 0.4D0) THEN
        AA = 0.75D0
      ELSE IF (AU3/AU2 .LE. 0.6D0) THEN
        AA = 0.7D0
      ELSE IF (AU3/AU2 .LE. 0.8D0) THEN
        AA = 0.65D0
      ELSE
        AA = 0.6D0
      END IF
      IF (AU3/AU2 .LE. 0.2D0) THEN
        KR1 = 0.0D0
        KR2 = 0.0D0
        KR4 = 0.0D0
        KS4 = 0.0D0
      ELSE IF (AU3/AU2 .LE. 0.33D0) THEN
        KR1 = 0.14D0
        KR2 = 0.17D0
        KR4 = 0.10D0
        KS4 = 0.0D0
      ELSE
        KR1 = 0.4D0
        KR2 = 0.4D0
        KR4 = 0.25D0
        KS4 = 0.1D0
      END IF
      IF (AU3/AU2 .LE. 0.1D0) THEN
        KR3 = 0.05D0
        KS5 = 0.0D0
      ELSE IF (AU3/AU2 .LE. 0.2D0) THEN
        KR3 = 0.14D0
        KS5 = 0.1D0
      ELSE IF (AU3/AU2 .LE. 0.33D0) THEN
        KR3 = 0.14D0
        KS5 = 0.2D0
      ELSE
        KR3 = 0.3D0
        KS5 = 0.25D0
      END IF
C
$VARIABLES1
C
      DOUBLE PRECISION AA1 , MA1 , MA2 , V1 , V2 , V3 , VR1 , VR2 , X ,
     &                 ZETA1 , ZETA2 , ZETA3
      INTEGER ERR , LEVEL
      CHARACTER ENAME * 6 , MESAGE * 100
      PARAMETER (ENAME = 'TEEFN' )
C
      ANG = ANG0
      V1 = M(1 , 10) / RHO(F1) / AU1
      V2 = - M(2 , 10) / RHO(F10) / AU2
      V3 = - M(3 , 10) / RHO(F10) / AU3
      GP(1 , 10) = 1.0D9
      GP(2 , 10) = 1.0D9
      GP(3 , 10) = 1.0D9
C
      IF (ABS(M(1 , 10)) .LT. 1.D- 9) THEN
         VR1 = 1.D+ 9
         MA1 = 1.D+ 9
C
      ELSE
         VR1 = V2 / V1
         MA1 = M(3 , 10) / M(1 , 10)
C
      END IF
C
      IF (ABS(M(2 , 10)) .LT. 1.D- 9) THEN
         VR2 = 1.D+ 9
         MA2 = 1.D+ 9
C
      ELSE
         VR2 = V1 / V2
         MA2 = M(3 , 10) / M(2 , 10)
C
      END IF
C
C IF M(1,10) > 0.0 BEGIN /1
C
      IF (M(1 , 10) .GT. 0.0D0) THEN
C
C IF M(2,10) > 0.0 BEGIN /2
C
         IF (M(2 , 10) .GT. 0.0D0) THEN
C
C IF M(3,10) > 0 BEGIN /3
C
            IF (M(3 , 10) .GT. 0.0D0) THEN
C
               ERR = 1
               LEVEL = 2
               MESAGE = 'Violation of mass conservation'
C
               CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C If M(3,10) <= ELSE /3
C
            ELSE IF (M(3 , 10) .LE. 0.D0) THEN
C
C IF ANG BEGIN /4
C
               IF (ABS(ANG - 90.D0) .LT. 1.D- 9) THEN
C
                  IF (M(3 , 10) .LT. 0.0D0) THEN
                     ZETA1 = (1. + (AU3 / AU1) ** 2 * (1.+ 3.* ((M(1 ,
     &                      10) / M(3 , 10)) ** 2 + M(1 , 10) / M(3 ,
     &                      10)))) / (M(1 , 10) / M(3 , 10) * AU3 / AU1)
     &                      ** 2
                     ZETA2 = (1. + (AU3 / AU2) ** 2 * (1.+ 3.* ((M(2 ,
     &                      10) / M(3 , 10)) ** 2 + M(2 , 10) / M(3 ,
     &                      10)))) / (M(2 , 10) / M(3 , 10) * AU3 / AU2)
     &                      ** 2
C
                  ELSE
                     ZETA1 = 3
                     ZETA2 = 3
C
                     ERR = 2
                     LEVEL = 2
                     MESAGE = 'Violation of mass conservation'
C
                     CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                  END IF
C
                  IF (ABS(ZETA1) .LT. 1.D- 9) THEN
                     GP(1 , 10) = 1.0E + 9
C
                  ELSE
                     GP(1 , 10) = 1. / ZETA1
C
                  END IF
C
                  IF (ABS(ZETA2) .LT. 1.D- 9) THEN
                     GP(2 , 10) = 1.0E + 9
C
                  ELSE
                     GP(2 , 10) = 1. / ZETA2
C
                  END IF
C
C IF ANG ELSE /4
C
               ELSE
C
                  ERR = 3
                  LEVEL = 2
                  MESAGE = 'Angle out of range'
C
                  CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF ANG END /4
C
               END IF
C
C IF M(3,10) > 0.0 END /3
C
            END IF
C
C IF M(2,10) < 0.0 ELSE /2
C
         ELSE IF (M(2 , 10) .LT. 0.0D0) THEN
C
C IF M(3,10) > 0.0 BEGIN /5
C
            IF (M(3 , 10) .GT. 0.0D0) THEN
C
C IF F(AU) BEGIN /6
C
               IF(((AU1 + AU3) .GT. AU2) .AND. (ABS(AU1 - AU2)
     &                .LT. 1.D- 9)) THEN
C
                  IF (ANG .LE. 60.D0) THEN
C
                     IF (ANG .LE. 30.D0) THEN
                        X = 1.74
C
                     ELSE IF (ANG .LE. 45.D0) THEN
                        X = 1.41
C
                     ELSE
                        X = 1.
C
                     END IF
                     ZETA1 = (1.- (M(1 , 10) / M(2 , 10)) ** 2 - X *
     &                      AU2 / AU3 * (M(3 , 10) / M(2 , 10)) ** 2) /
     &                      (M(1 , 10) / M(2 , 10)) ** 2
                     ZETA3 = (1.+ (M(3 , 10) / M(2 , 10) * AU2 / AU3)
     &                     ** 2 - 2.* (M(1 , 10) / M(2 , 10)) ** 2 -
     &                      X * AU2 / AU3 * (M(3 , 10) / M(2 , 10)) **
     &                      2) / (M(3 , 10) / M(2 , 10) * AU2 / AU3) **
     &                      2
C
                  ELSE IF (ANG .LE. 90.D0) THEN
                     ZETA1 = ( - 1.55 * M(3 , 10) / M(2 , 10) - (M(3 ,
     &                      10) / M(2 , 10)) ** 2) / (M(1 , 10) / M(2 ,
     &                      10)) ** 2
                     ZETA3 = AA * (1.+ (M(3 , 10) / M(2 , 10) * AU2 /
     &                      AU3) ** 2 - 2.* (M(1 , 10) / M(2 , 10)) **
     &                      2) / (M(3 , 10) / M(2 , 10) * AU2 / AU3) **
     &                      2
C
                  ELSE IF (ANG .GT. 90.D0) THEN
C
                     ERR = 4
                     LEVEL = 2
                     MESAGE = 'Angle out of range'
C
                     CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                  END IF
C
C IF F(AU) ELSE /6
C
               ELSE IF (ABS((AU1 + AU3) - AU2) .LT. 1.D- 9) THEN
C
                  IF (ANG .LE. 15.D0) THEN
C
                     IF (ABS(M(3 , 10) / M(2 , 10) + 1.D0) .LT. 1.D- 9)
     &                   THEN
                        ZETA1 = 1.0E + 9
C
                     ELSE
                        ZETA1 = (1.+ (AU2 / AU1) ** 2 * (1 + M(3 , 10)
     &                         / M(2 , 10)) ** 2 - 2.* AU2 / AU1 *
     &                         (1.+ M(3 , 10) / M(2 , 10)) ** 2 -
     &                         1.94 * AU2 / AU3 * (M(3 , 10) / M(2 , 10)
     &                        ) ** 2 + KR1) / ((1.+ M(3 , 10) / M(2 ,
     &                         10)) ** 2 * (AU2 / AU1) ** 2)
C
                     END IF
                     ZETA3 = (1.+ (M(3 , 10) / M(2 , 10) * AU2 / AU3)
     &                     ** 2 - 2.* AU2 / AU1 * (1 + M(3 , 10) /
     &                      M(2 , 10)) ** 2 - 1.94 * AU2 / AU3 * (M(3 ,
     &                      10) / M(2 , 10)) ** 2) / (M(3 , 10) / M(2 ,
     &                      10) * AU2 / AU3) ** 2
C
                  ELSE IF (ANG .LE. 30.D0) THEN
C
                     IF (ABS(M(3 , 10) / M(2 , 10) + 1.D0) .LT. 1.D- 9)
     &                   THEN
                        ZETA1 = 1.0E + 9
C
                     ELSE
                        ZETA1 = (1.+ (AU2 / AU1) ** 2 * (1 + M(3 , 10)
     &                         / M(2 , 10)) ** 2 - 2.* AU2 / AU1 *
     &                         (1.+ M(3 , 10) / M(2 , 10)) ** 2 -
     &                         1.74 * AU2 / AU3 * (M(3 , 10) / M(2 , 10)
     &                        ) ** 2 + KR2) / ((1.+ M(3 , 10) / M(2 ,
     &                         10)) ** 2 * (AU2 / AU1) ** 2)
C
                     END IF
                     ZETA3 = (1.+ (M(3 , 10) / M(2 , 10) * AU2 / AU3)
     &                     ** 2 - 2.* AU2 / AU1 * (1 + M(3 , 10) /
     &                      M(2 , 10)) ** 2 - 1.74 * AU2 / AU3 * (M(3 ,
     &                      10) / M(2 , 10)) ** 2) / (M(3 , 10) / M(2 ,
     &                      10) * AU2 / AU3) ** 2
C
                  ELSE IF (ANG .LE. 45.D0) THEN
C
                     IF (ABS(M(3 , 10) / M(2 , 10) + 1.D0) .LT. 1.D- 9)
     &                   THEN
                        ZETA1 = 1.0E + 9
C
                     ELSE
                        ZETA1 = (1.+ (AU2 / AU1) ** 2 * (1 + M(3 , 10)
     &                         / M(2 , 10)) ** 2 - 2.* AU2 / AU1 *
     &                         (1.+ M(3 , 10) / M(2 , 10)) ** 2 -
     &                         1.41 * AU2 / AU3 * (M(3 , 10) / M(2 , 10)
     &                        ) ** 2 + KR3) / ((1.+ M(3 , 10) / M(2 ,
     &                         10)) ** 2 * (AU2 / AU1) ** 2)
C
                     END IF
                     ZETA3 = (1.+ (M(3 , 10) / M(2 , 10) * AU2 / AU3)
     &                     ** 2 - 2.* AU2 / AU1 * (1.+ M(3 , 10) /
     &                      M(2 , 10)) ** 2 - 1.41 * AU2 / AU3 * (M(3 ,
     &                      10) / M(2 , 10)) ** 2) / (M(3 , 10) / M(2 ,
     &                      10) * AU2 / AU3) ** 2
C
                  ELSE IF (ANG .LE. 60.D0) THEN
C
                     IF (ABS(M(3 , 10) / M(2 , 10) + 1.D0) .LT. 1.D- 9)
     &                   THEN
                        ZETA1 = 1.0E + 9
C
                     ELSE
                        ZETA1 = (1.+ (AU2 / AU1) ** 2 * (1.+ M(3 , 10)
     &                         / M(2 , 10)) ** 2 - 2.* AU2 / AU1 *
     &                         (1.+ M(3 , 10) / M(2 , 10)) ** 2 - AU2 /
     &                         AU3 * (M(3 , 10) / M(2 , 10)) ** 2 + KR4)
     &                         / ((1.+ M(3 , 10) / M(2 , 10)) ** 2 *
     &                         (AU2 / AU1) ** 2)
C
                     END IF
                     ZETA3 = (1.+ (M(3 , 10) / M(2 , 10) * AU2 / AU3)
     &                     ** 2 - 2.* AU2 / AU1 * (1 + M(3 , 10) /
     &                      M(2 , 10)) ** 2 - AU2 / AU3 * (M(3 , 10) /
     &                      M(2 , 10)) ** 2 + KS4) / (M(3 , 10) / M(2 ,
     &                      10) * AU2 / AU3) ** 2
C
                  ELSE IF (ANG .LE. 90.D0) THEN
C
                     IF (ABS(M(3 , 10) / M(2 , 10) + 1.D0) .LT. 1.D- 9)
     &                   THEN
                        ZETA1 = 1.0E + 9
C
                     ELSE
C
                        IF ((AU3 / AU2) .LE. 0.06D0) THEN
                           ZETA1 = INTRP1(ABS(MA2) , ZPR1 , 1) / ((1.+
     &                            M(3 , 10) / M(2 , 10)) ** 2 * (AU2 /
     &                            AU1) ** 2)
C
                        ELSE IF ((AU3 / AU2) .LE. 0.1D0) THEN
                           ZETA1 = INTRP1(ABS(MA2) , ZPR2 , 1) / ((1.+
     &                            M(3 , 10) / M(2 , 10)) ** 2 * (AU2 /
     &                            AU1) ** 2)
C
                        ELSE IF ((AU3 / AU2) .LE. 0.2D0) THEN
                           ZETA1 = INTRP1(ABS(MA2) , ZPR3 , 1) / ((1.+
     &                            M(3 , 10) / M(2 , 10)) ** 2 * (AU2 /
     &                            AU1) ** 2)
C
                        ELSE IF ((AU3 / AU2) .LE. 0.33D0) THEN
                           ZETA1 = INTRP1(ABS(MA2) , ZPR4 , 1) / ((1.+
     &                            M(3 , 10) / M(2 , 10)) ** 2 * (AU2 /
     &                            AU1) ** 2)
C
                        ELSE IF ((AU3 / AU2) .LE. 0.5D0) THEN
                           ZETA1 = INTRP1(ABS(MA2) , ZPR5 , 1) / ((1.+
     &                            M(3 , 10) / M(2 , 10)) ** 2 * (AU2 /
     &                            AU1) ** 2)
C
                        ELSE
C
                           ERR = 5
                           LEVEL = 2
                           MESAGE = 'Diameter relation out of range'
C
                           CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                        END IF
C
                     END IF
                     ZETA3 = (1.+ (M(3 , 10) / M(2 , 10) * AU2 / AU3)
     &                     ** 2 - 2.* AU2 / AU1 * (1.+ M(3 , 10) /
     &                      M(2 , 10)) ** 2 + KS5) / (M(3 , 10) / M(2 ,
     &                      10) * AU2 / AU3) ** 2
C
                  ELSE IF (ANG .GT. 90.D0) THEN
C
                     ERR = 6
                     LEVEL = 2
                     MESAGE = 'Angle out of range'
C
                     CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     WRITE(6 , * ) ' 6 ANGLE OUT OF RANGE'
C
                  END IF
C
C IF F(AU) ELSE /6
C
               ELSE
C
                  ERR = 7
                  LEVEL = 2
                  MESAGE = 'Diameter relation out of range'
C
                  CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF F(AU) END /6
C
               END IF
C
               IF (ABS(ZETA1) .LT. 1.D- 9) THEN
                  GP(1 , 10) = 1.0E + 9
C
               ELSE
                  GP(1 , 10) = 1. / ZETA1
C
               END IF
C
               IF (ABS(ZETA3) .LT. 1.D- 9) THEN
                  GP(3 , 10) = 1.0E + 9
C
               ELSE
                  GP(3 , 10) = 1. / ZETA3
C
               END IF
C
C IF M(3,10) < 0.0 ELSE /5
C
            ELSE IF (M(3 , 10) .LT. 0.D0) THEN
C
C IF F(ANG) BEGIN /7
C
               IF (ANG .GE. 90.D0) THEN
                  ANG = 180.D0 - ANG
C
                  IF (ANG .LE. 15.D0) THEN
                     KS6 = 0.04
C
                  ELSE IF (ANG .LE. 30.D0) THEN
                     KS6 = 0.16
C
                  ELSE IF (ANG .LE. 45.D0) THEN
                     KS6 = 0.36
C
                  ELSE IF (ANG .LE. 60.D0) THEN
                     KS6 = 0.64
C
                  ELSE
                     KS6 = 1.0
C
                  END IF
C
C IF F(AU) BEGIN /8
C
                  IF(((AU2 + AU3) .GT. AU1) .AND. (ABS(AU1 - AU2)
     &                   .LT. 1.D- 9)) THEN
C
                     IF ((V3 / V1) .LE. 0.8D0) THEN
                        AA1 = 1.
C
                     ELSE
                        AA1 = 0.9
C
                     END IF
C
                     IF ((V2 / V1) .LE. 1.D0) THEN
                        ZETA2 = 0.4 * (1.- V2 / V1) ** 2 / (V2 / V1) **
     &                         2
C
                     ELSE
C
                        ERR = 8
                        LEVEL = 2
                        MESAGE = 'Velocity relation out of range'
C
                        CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     END IF
C
                     IF (((AU3 / AU1) .LE. (2.D0 / 3.D0))
     &                   .AND. ((ANG .LT. 60.D0) .OR. (ABS(ANG - 90.D0)
     &                   .LT. 1.D- 9))) THEN
                        ZETA3 = AA1 * (1.+ (V3 / V1) ** 2 - 2.* V3 /
     &                         V1 * COS(ANG * 3.1416 / 180.)) / (V3 /
     &                         V1) ** 2
C
                     ELSE IF ((ABS(AU3 / AU1 - 1.D0) .LT. 1.D- 9)
     &                        .AND. (ABS(ANG - 90.) .LT. 1.E- 9)) THEN
                        ZETA3 = AA1 * (0.34 + (V3 / V1) ** 2) / (V3 /
     &                         V1) ** 2
C
                     ELSE
C
                        ERR = 9
                        LEVEL = 2
                        MESAGE = 'Angle or diameter relation out of ' //
     &                        'range'
C
                        CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     END IF
C
C IF F(AU) ELSE /8
C
                  ELSE IF(ABS((AU2 + AU3) - AU1) .LT. 1.D- 9) THEN
C
                     IF (ANG .LE. 60.D0) THEN
                        ZETA2 = INTRP1(VR1 , ZPR6 , 1) / (V2 / V1) ** 2
C
                     ELSE IF (ABS(ANG - 90.D0) .LT. 1.D- 9) THEN
C
                        IF ((AU2 / AU1) .LE. 0.4D0) THEN
                           ZETA2 = INTRP1(VR1 , ZPR6 , 1) / (V2 / V1) **
     &                            2
C
                        ELSE IF ((AU2 / AU1) .LE. 0.5D0) THEN
                           ZETA2 = INTRP1(VR1 , ZPR7 , 1) / (V2 / V1) **
     &                            2
C
                        ELSE IF ((AU2 / AU1) .LE. 0.6D0) THEN
                           ZETA2 = INTRP1(VR1 , ZPR8 , 1) / (V2 / V1) **
     &                            2
C
                        ELSE IF ((AU2 / AU1) .LE. 0.7D0) THEN
                           ZETA2 = INTRP1(VR1 , ZPR9 , 1) / (V2 / V1) **
     &                            2
C
                        ELSE
                           ZETA2 = INTRP1(VR1 , ZPR10 , 1) / (V2 / V1)
     &                           ** 2
C
                        END IF
C
                     ELSE
C
                        ERR = 10
                        LEVEL = 2
                        MESAGE = 'Angle out of range'
C
                        CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     END IF
                     ZETA3 = (1.+ (V3 / V1) ** 2 - 2.* V3 / V1 *
     &                      COS(ANG * 3.1416 / 180.) - KS6 * (V3 / V1)
     &                     ** 2) / (V3 / V1) ** 2
C
                  ELSE
C
                     ERR = 11
                     LEVEL = 2
                     MESAGE = 'Diameter relation out of range'
C
                     CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                  END IF
C
C IF F(AU) ELSE /8
C
               ELSE
C
                  ERR = 12
                  LEVEL = 2
                  MESAGE = 'Angle out of range'
C
                  CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF F(AU) END /8
C
               END IF
C
               IF (ABS(ZETA2) .LT. 1.D- 9) THEN
                  GP(2 , 10) = 1.0E + 9
C
               ELSE
                  GP(2 , 10) = 1. / ZETA2
C
               END IF
C
               IF (ABS(ZETA3) .LT. 1.D- 9) THEN
                  GP(3 , 10) = 1.0E + 9
C
               ELSE
                  GP(3 , 10) = 1. / ZETA3
C
               END IF
C
C IF M(3,10) ELSE /5
C
            ELSE IF (ABS(M(3 , 10)) .LT. 1.D- 9) THEN
C
               CONTINUE
C
C IF M(3,10) END /5
C
            END IF
C
C IF M(2,10) ELSE /2
C
         ELSE IF (ABS(M(2 , 10)) .LT. 1.D- 9) THEN
C
            CONTINUE
C
            IF (M(3 , 10) .GE. 0.D0) THEN
C
               ERR = 13
               LEVEL = 2
               MESAGE = 'Violation of mass conservation'
C
               CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
            ELSE IF (M(3 , 10) .LT. 0.D0) THEN
               CONTINUE
C
            END IF
C
C IF M(2,10) END /2
C
         END IF
C
C IF M(1,10) ELSE /1
C
      ELSE IF (M(1 , 10) .LT. 0.D0) THEN
C
C IF M(2,10) > 0.0 BEGIN /9
C
         IF (M(2 , 10) .GT. 0.D0) THEN
C
C IF M(3,10) GT 0.0 BEGIN /10
C
            IF (M(3 , 10) .GT. 0.D0) THEN
C
C IF F(ANG) BEGIN /11
C
               IF (ANG .GE. 90.D0) THEN
                  ANG = 180.D0 - ANG
C
C IF F(AU) BEGIN /12
C
                  IF(((AU2 + AU3) .GT. AU1) .AND. (ABS(AU1 - AU2)
     &                   .LT. 1.D- 9)) THEN
C
                     IF (ANG .LE. 60.D0) THEN
C
                        IF (ANG .LE. 30.D0) THEN
                           X = 1.74
C
                        ELSE IF (ANG .LE. 45.D0) THEN
                           X = 1.41
C
                        ELSE
                           X = 1.
C
                        END IF
                        ZETA2 = (1.- (M(2 , 10) / M(1 , 10)) ** 2 - X *
     &                         AU1 / AU3 * (M(3 , 10) / M(1 , 10)) ** 2)
     &                         / (M(2 , 10) / M(1 , 10)) ** 2
                        ZETA3 = (1.+ (M(3 , 10) / M(1 , 10) * AU1 /
     &                         AU3) ** 2 - 2.* (M(2 , 10) / M(1 , 10))
     &                         ** 2 - X * AU1 / AU3 * (M(3 , 10) / M(1 ,
     &                         10)) ** 2) / (M(3 , 10) / M(1 , 10) *
     &                         AU1 / AU3) ** 2
C
                     ELSE IF (ANG .LE. 90.D0) THEN
                        ZETA2 = ( - 1.55 * M(3 , 10) / M(1 , 10) -
     &                         (M(3 , 10) / M(1 , 10)) ** 2) / (M(2 ,
     &                         10) / M(1 , 10)) ** 2
                        ZETA3 = AA * (1.+ (M(3 , 10) / M(1 , 10) *
     &                         AU1 / AU3) ** 2 - 2.* (M(2 , 10) / M(1 ,
     &                         10)) ** 2) / (M(3 , 10) / M(1 , 10) *
     &                         AU1 / AU3) ** 2
C
                     END IF
C
C IF F(AU) ELSE /12
C
                  ELSE IF (ABS((AU2 + AU3) - AU1) .LT. 1.D- 9) THEN
C
                     IF (ANG .LE. 15.D0) THEN
C
                        IF (ABS(M(3 , 10) / M(1 , 10) + 1) .LT. 1.D- 9)
     &                      THEN
                           ZETA2 = 1.0E + 9
C
                        ELSE
                           ZETA2 = (1.+ (AU1 / AU2) ** 2 * (1 + M(3 ,
     &                            10) / M(1 , 10)) ** 2 - 2.* AU1 /
     &                            AU2 * (1.+ M(3 , 10) / M(1 , 10)) **
     &                            2 - 1.94 * AU1 / AU3 * (M(3 , 10) /
     &                            M(1 , 10)) ** 2 + KR1) / ((1.+ M(3 ,
     &                            10) / M(1 , 10)) ** 2 * (AU1 / AU2) **
     &                            2)
C
                        END IF
                        ZETA3 = (1.+ (M(3 , 10) / M(1 , 10) * AU1 /
     &                         AU3) ** 2 - 2.* AU1 / AU2 * (1 + M(3 ,
     &                         10) / M(1 , 10)) ** 2 - 1.94 * AU1 /
     &                         AU3 * (M(3 , 10) / M(1 , 10)) ** 2) /
     &                         (M(3 , 10) / M(1 , 10) * AU1 / AU3) ** 2
C
                     ELSE IF (ANG .LE. 30.D0) THEN
C
                        IF (ABS(M(3 , 10) / M(1 , 10) + 1.D0) .LT. 1.D-
     &                      9) THEN
                           ZETA2 = 1.0E + 9
C
                        ELSE
                           ZETA2 = (1.+ (AU1 / AU2) ** 2 * (1 + M(3 ,
     &                            10) / M(1 , 10)) ** 2 - 2.* AU1 /
     &                            AU2 * (1.+ M(3 , 10) / M(1 , 10)) **
     &                            2 - 1.74 * AU1 / AU3 * (M(3 , 10) /
     &                            M(1 , 10)) ** 2 + KR2) / ((1.+ M(3 ,
     &                            10) / M(1 , 10)) ** 2 * (AU1 / AU2) **
     &                            2)
C
                        END IF
                        ZETA3 = (1.+ (M(3 , 10) / M(1 , 10) * AU1 /
     &                         AU3) ** 2 - 2.* AU1 / AU2 * (1.+ M(3 ,
     &                         10) / M(1 , 10)) ** 2 - 1.74 * AU1 /
     &                         AU3 * (M(3 , 10) / M(1 , 10)) ** 2) /
     &                         (M(3 , 10) / M(1 , 10) * AU1 / AU3) ** 2
C
                     ELSE IF (ANG .LE. 45.D0) THEN
C
                        IF (ABS(M(3 , 10) / M(1 , 10) + 1.D0) .LT. 1.D-
     &                      9) THEN
                           ZETA2 = 1.0E + 9
C
                        ELSE
                           ZETA2 = (1.+ (AU1 / AU2) ** 2 * (1 + M(3 ,
     &                            10) / M(1 , 10)) ** 2 - 2.* AU1 /
     &                            AU2 * (1.+ M(3 , 10) / M(1 , 10)) **
     &                            2 - 1.41 * AU1 / AU3 * (M(3 , 10) /
     &                            M(1 , 10)) ** 2 + KR3) / ((1.+ M(3 ,
     &                            10) / M(1 , 10)) ** 2 * (AU1 / AU2) **
     &                            2)
C
                        END IF
                        ZETA3 = (1.+ (M(3 , 10) / M(1 , 10) * AU1 /
     &                         AU3) ** 2 - 2.* AU1 / AU2 * (1.+ M(3 ,
     &                         10) / M(1 , 10)) ** 2 - 1.41 * AU1 /
     &                         AU3 * (M(3 , 10) / M(1 , 10)) ** 2) /
     &                         (M(3 , 10) / M(1 , 10) * AU1 / AU3) ** 2
C
                     ELSE IF (ANG .LE. 60.D0) THEN
C
                        IF (ABS(M(3 , 10) / M(1 , 10) + 1.D0) .LT. 1.D-
     &                      9) THEN
                           ZETA2 = 1.0E + 9
C
                        ELSE
                           ZETA2 = (1.+ (AU1 / AU2) ** 2 * (1 + M(3 ,
     &                            10) / M(1 , 10)) ** 2 - 2.* AU1 /
     &                            AU2 * (1.+ M(3 , 10) / M(1 , 10)) **
     &                            2 - AU1 / AU3 * (M(3 , 10) / M(1 , 10)
     &                           ) ** 2 + KR4) / ((1.+ M(3 , 10) /
     &                            M(1 , 10)) ** 2 * (AU1 / AU2) ** 2)
C
                        END IF
                        ZETA3 = (1.+ (M(3 , 10) / M(1 , 10) * AU1 /
     &                         AU3) ** 2 - 2.* AU1 / AU2 * (1.+ M(3 ,
     &                         10) / M(1 , 10)) ** 2 - AU1 / AU3 *
     &                         (M(3 , 10) / M(1 , 10)) ** 2 + KS4) /
     &                         (M(3 , 10) / M(1 , 10) * AU1 / AU3) ** 2
C
                     ELSE IF (ANG .LE. 90.D0) THEN
C
                        IF (ABS(M(3 , 10) / M(1 , 10) + 1.D0) .LT. 1.D-
     &                      9) THEN
                           ZETA2 = 1.0E + 9
C
                        ELSE
C
                           IF ((AU3 / AU1) .LE. 0.06D0) THEN
                              ZETA2 = INTRP1(ABS(MA1) , ZPR1 , 1) /
     &                               ((1.+ M(3 , 10) / M(1 , 10)) **
     &                               2 * (AU1 / AU2) ** 2)
C
                           ELSE IF ((AU3 / AU1) .LE. 0.1D0) THEN
                              ZETA2 = INTRP1(ABS(MA1) , ZPR2 , 1) /
     &                               ((1.+ M(3 , 10) / M(1 , 10)) **
     &                               2 * (AU1 / AU2) ** 2)
C
                           ELSE IF ((AU3 / AU1) .LE. 0.2D0) THEN
                              ZETA2 = INTRP1(ABS(MA1) , ZPR3 , 1) /
     &                               ((1.+ M(3 , 10) / M(1 , 10)) **
     &                               2 * (AU1 / AU2) ** 2)
C
                           ELSE IF ((AU3 / AU1) .LE. 0.33D0) THEN
                              ZETA2 = INTRP1(ABS(MA1) , ZPR4 , 1) /
     &                               ((1.+ M(3 , 10) / M(1 , 10)) **
     &                               2 * (AU1 / AU2) ** 2)
C
                           ELSE IF ((AU3 / AU1) .LE. 0.5D0) THEN
                              ZETA2 = INTRP1(ABS(MA1) , ZPR5 , 1) /
     &                               ((1.+ M(3 , 10) / M(1 , 10)) **
     &                               2 * (AU1 / AU2) ** 2)
C
                           END IF
C
                        END IF
                        ZETA3 = (1.+ (M(3 , 10) / M(1 , 10) * AU1 /
     &                         AU3) ** 2 - 2.* AU1 / AU2 * (1.+ M(3 ,
     &                         10) / M(1 , 10)) ** 2 + KS5) / (M(3 , 10)
     &                         / M(1 , 10) * AU1 / AU3) ** 2
C
                     END IF
C
C IF F(AU) ELSE /12
C
                  ELSE
C
                     ERR = 14
                     LEVEL = 2
                     MESAGE = 'Diameter relation out of range'
C
                     CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF F(AU) END /12
C
                  END IF
C
                  IF (ABS(ZETA2) .LT. 1.D- 9) THEN
                     GP(2 , 10) = 1.0E + 9
C
                  ELSE
                     GP(2 , 10) = 1. / ZETA2
C
                  END IF
C
                  IF (ABS(ZETA3) .LT. 1.D- 9) THEN
                     GP(3 , 10) = 1.0E + 9
C
                  ELSE
                     GP(3 , 10) = 1. / ZETA3
C
                  END IF
C
C IF F(ANG) ELSE /11
C
               ELSE
C
                  ERR = 15
                  LEVEL = 2
                  MESAGE = 'Angle out of range'
C
                  CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF F(ANG) END /11
C
               END IF
C
C IF M(3,10) ELSE /10
C
            ELSE IF (M(3 , 10) .LT. 0.D0) THEN
C
C IF F(ANG) BEGIN /13
C
               IF (ANG .LE. 90.D0) THEN
C
                  IF (ANG .LE. 15.D0) THEN
                     KS6 = 0.04
C
                  ELSE IF (ANG .LE. 30.D0) THEN
                     KS6 = 0.16
C
                  ELSE IF (ANG .LE. 45.D0) THEN
                     KS6 = 0.36
C
                  ELSE IF (ANG .LE. 60.D0) THEN
                     KS6 = 0.64
C
                  ELSE
                     KS6 = 1.0
C
                  END IF
C
C IF F(AU) BEGIN /14
C
                  IF(((AU1 + AU3) .GT. AU2) .AND. (ABS(AU1 - AU2)
     &                   .LT. 1.D- 9)) THEN
C
                     IF (ABS(V3 / V2) .LE. 0.8D0) THEN
                        AA1 = 1.
C
                     ELSE
                        AA1 = 0.9
C
                     END IF
C
                     IF ((V1 / V2) .LE. 1.D0) THEN
                        ZETA1 = 0.4 * (1.- V1 / V2) ** 2 / (V1 / V2) **
     &                         2
C
                     ELSE
C
                        ERR = 16
                        LEVEL = 2
                        MESAGE = 'Velocity relation out of range'
C
                        CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     END IF
C
                     IF (((AU3 / AU2) .LE. (2.D0 / 3.D0))
     &                   .AND. ((ANG .LT. 60.D0) .OR. (ABS(ANG - 90.D0)
     &                   .LT. 1.D- 9))) THEN
                        ZETA3 = AA1 * (1.+ (V3 / V2) ** 2 + 2.* V3 /
     &                         V2 * COS(ANG * 3.1416 / 180.)) / (V3 /
     &                         V2) ** 2
C
                     ELSE IF ((ABS(AU3 / AU2 - 1.D0) .LT. 1.D- 9)
     &                        .AND. (ABS(ANG - 90.) .LT. 1.E- 9)) THEN
                        ZETA3 = AA1 * (0.34 + (V3 / V2) ** 2) / (V3 /
     &                         V2) ** 2
C
                     ELSE
C
                        ERR = 17
                        LEVEL = 2
                        MESAGE = 'Angle or diameter relation out of ' //
     &                        'range'
C
                        CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     END IF
C
C IF F(AU) ELSE /14
C
                  ELSE IF(ABS((AU1 + AU3) - AU2) .LT. 1.D- 9) THEN
C
                     IF (ANG .LE. 60.D0) THEN
                        ZETA1 = INTRP1(VR2 , ZPR6 , 1) / (V1 / V2) ** 2
C
                     ELSE IF (ABS(ANG - 90.D0) .LT. 1.D- 9) THEN
C
                        IF ((AU1 / AU2) .LE. 0.4D0) THEN
                           ZETA1 = INTRP1(VR2 , ZPR6 , 1) / (V1 / V2) **
     &                            2
C
                        ELSE IF ((AU1 / AU2) .LE. 0.5D0) THEN
                           ZETA1 = INTRP1(VR2 , ZPR7 , 1) / (V1 / V2) **
     &                            2
C
                        ELSE IF ((AU1 / AU2) .LE. 0.6D0) THEN
                           ZETA1 = INTRP1(VR2 , ZPR8 , 1) / (V1 / V2) **
     &                            2
C
                        ELSE IF ((AU1 / AU2) .LE. 0.7D0) THEN
                           ZETA1 = INTRP1(VR2 , ZPR9 , 1) / (V1 / V2) **
     &                            2
C
                        ELSE
                           ZETA1 = INTRP1(VR2 , ZPR10 , 1) / (V1 / V2)
     &                           ** 2
C
                        END IF
C
                     ELSE
C
                        ERR = 18
                        LEVEL = 2
                        MESAGE = 'Angle out of range'
C
                        CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
                     END IF
                     ZETA3 = (1.+ (V3 / V2) ** 2 + 2.* V3 / V2 *
     &                      COS(ANG * 3.1416 / 180.) - KS6 * (V3 / V2)
     &                     ** 2) / (V3 / V2) ** 2
C
C IF F(AU) ELSE /14
C
                  ELSE
C
                     ERR = 18
                     LEVEL = 2
                     MESAGE = 'Diameter relation out of range'
C
                     CALL SETERX(MESAGE , LEVEL , ENAME)
C
C IF F(AU) END /14
C
                  END IF
C
C IF F(ANG) ELSE /13
C
               ELSE
C
                  ERR = 20
                  LEVEL = 2
                  MESAGE = 'Angle out of range'
C
                  CALL SETERX(MESAGE , LEVEL , ENAME)
C
C IF F(ANG) END /13
C
               END IF
C
               IF (ABS(ZETA1) .LT. 1.D- 9) THEN
                  GP(1 , 10) = 1.0E + 9
C
               ELSE
                  GP(1 , 10) = 1. / ZETA1
C
               END IF
C
               IF (ABS(ZETA3) .LT. 1.D- 9) THEN
                  GP(3 , 10) = 1.0E + 9
C
               ELSE
                  GP(3 , 10) = 1. / ZETA3
C
               END IF
C
C IF M(3,10) ELSE /10
C
            ELSE IF (ABS(M(3 , 10)) .LT. 1.D- 9) THEN
C
               CONTINUE
C
C IF M(3,10) END /10
C
            END IF
C
C IF M(2,10) ELSE /9
C
         ELSE IF (M(2 , 10) .LT. 0.D0) THEN
C
C IF M(3,10) BEGIN /15
C
            IF (M(3 , 10) .GT. 0.D0) THEN
C
               IF (ABS(ANG - 90.D0) .LT. 1.D- 9) THEN
                  ZETA1 = (1. + 0.3 * (V1 / V3) ** 2) / (V1 / V3) ** 2
                  ZETA2 = (1. + 0.3 * (V2 / V3) ** 2) / (V2 / V3) ** 2
                  GP(1 , 10) = 1. / ZETA1
                  GP(2 , 10) = 1. / ZETA2
C
               ELSE
C
                  ERR = 21
                  LEVEL = 2
                  MESAGE = 'Angle out of range'
C
                  CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
               END IF
C
C IF M(3,10) ELSE /15
C
            ELSE IF (M(3 , 10) .LE. 0.D0) THEN
C
               CONTINUE
C
               ERR = 22
               LEVEL = 2
               MESAGE = 'Violation of mass conservation'
C
               CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF M(3,10) END /15
C
            END IF
C
C IF M(2,10) ELSE /9
C
         ELSE IF (ABS(M(2 , 10)) .LT. 1.D- 9) THEN
C
C        GP(2,10) = 1.E-9
C
            IF (M(3 , 10) .GT. 0.D0) THEN
               GP(3 , 10) = 1.E+ 9
C
            ELSE IF (M(3 , 10) .LE. 0.D0) THEN
               CONTINUE
C
               ERR = 23
               LEVEL = 2
               MESAGE = 'Violation of mass conservation'
C
               CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
            END IF
C
C IF M(2,10) END /9
C
         END IF
C
C IF M(1,10) ELSE /1
C
      ELSE IF (ABS(M(1 , 10)) .LT. 1.D- 9) THEN
C
         CONTINUE
C
C IF M(2,10),M(3,10) BEGIN /16
C
         IF ((M(2 , 10) .GT. 0.D0) .AND. (M(3 , 10) .LT. 0.D0)) THEN
            CONTINUE
C
C IF M(2,10),M(3,10) ELSE /16
C
         ELSE IF ((M(2 , 10) .LT. 0.D0) .AND. (M(3 , 10) .GT. 0.D0))
     &            THEN
            CONTINUE
C
C IF M(2,10),M(3,10) ELSE /16
C
         ELSE IF ((ABS(M(2 , 10)) .LT. 1.D- 9) .AND. (ABS(M(3 , 10))
     &            .LT. 1.E- 9)) THEN
            GP(2 , 10) = 1.0E + 9
            GP(3 , 10) = 1.0E + 9
C
C IF M(2,10),M(3,10) ELSE /16
C
         ELSE
            CONTINUE
C
            ERR = 24
            LEVEL = 2
            MESAGE = 'Violation of mass conservation'
C
            CALL SETERX(MESAGE , LEVEL , ERR , ENAME)
C
C IF M(2,10),M(3,10) END /16
C
         END IF
C
C IF M(1,10) END /1
C
      END IF
C
C ======================================================================
C
      RETURN
C
C ======================================================================
C
$ENDMODEL TEEFN
$MODEL VALVE
#
# Two and three way valve element -
#
$DEFAULTS
#
VFX1=0.0 ; VFY1=0.0 ; VFZ1=0.0 ;
VFX2=0.0 ; VFY2=0.0 ; VFZ2=0.0 ;
VFX3=0.0 ; VFY3=0.0 ; VFZ3=0.0 ;
VFST = 'P&T';                              # )
VP1 = 0.0; VP2 = 0.0; VP3 = 0.0;           # )
VT1 = 0.0; VT2 = 0.0; VT3 = 0.0;           # > Default fluid state
VVQ1 = 0.0; VVQ2 = 0.0; VVQ3 = 0.0;        # )
VFE1 = 0.0; VFE2 = 0.0; VFE3 = 0.0;        # )
VA1 = RL11; VA2 = RL12; VA3 = RL13;        # Heat transfer area
VFF1 = 0.0; VFF2 = 0.0; VFF3 = 0.0;        # Zero frictional loss
VFLA1 = RL14; VFLA2 = RL15; VFLA3 = RL16;  # Flow area
XOPEN = 1.0;        # Side link M(1, 3) closed by default
#
# Node three not necessary for two-way valve
# Entities set by reference to node 2 in $INITIAL
#
VALTYP='TWOWAY' ;
MFLOW2=U ;
VFD3=RL2 ;
VFL3=RL3 ;
#
$LOCALS
#
# Use these local constants to initialise values for F3
#
$REAL
RL2=%VFD2% ;
RL3=%VFL2% ;
#
RL10 = 3.14159;
RL11 = RL10 * %VFD1% * %VFL1%;
RL12 = RL10 * %VFD2% * %VFL2%;
RL13 = RL10 * %VFD3% * %VFL3%;
RL14 = RL10 * %VFD1% * %VFD1% / 4.0 ;
RL15 = RL10 * %VFD2% * %VFD2% / 4.0 ;
RL16 = RL10 * %VFD3% * %VFD3% / 4.0 ;
#
$NODES
#
F1, A = %VA1%, FD = %VFD1%, FLA = %VFLA1%, FL = %VFL1%,
    FST = %VFST%, P = %VP1%, T = %VT1%, FE = %VFE1%, VQ = %VVQ1%,
    FF = %VFF1%, FX = %VFX1%, FY = %VFY1%, FZ = %VFZ1%;
F2, A = %VA2%, FD = %VFD2%, FLA = %VFLA2%, FL = %VFL2%,
    FST = %VFST%, P = %VP2%, T = %VT2%, FE = %VFE2%, VQ = %VVQ2%,
    FF = %VFF2%, FX = %VFX2%, FY = %VFY2%, FZ = %VFZ2%;
F3, A = %VA3%, FD = %VFD3%, FLA = %VFLA3%, FL = %VFL3%,
    FST = %VFST%, P = %VP3%, T = %VT3%, FE = %VFE3%, VQ = %VVQ3%,
    FF = %VFF3%, FX = %VFX3%, FY = %VFY3%, FZ = %VFZ3%;
#
$CONDUCTORS
#
M(1,2)=%MFLOW1%;    # Main link
M(1,3)=%MFLOW2%;    # Side branch
#
$CONSTANTS
#
$REAL
EVALUE = %EVALUE% ;    # Valve pressure drop factor
XOPEN = %XOPEN% ;      # Fraction of valve opening between nodes 1 & 2
#
$CHARACTER
VALTYP= %VALTYP%;    # Valve type two or three way
#
$INITIAL
      IF(VALTYP .EQ. 'TWOWAY' )THEN
C
C Two way valve only so set node 3 entities from node 2 and set M[1,3] inactive
C   fluid state must be set to ensure valid conditions
C
         P3 = %VP2%
         T3 = %VT2%
         FE3 = %VFE2%
         VQ3 = %VVQ2%
C
         CALL STATST( 'M(1, 3)' , 'OFF' )
C
         GP(1 , 3) = 0.0
         M(1 , 3) = MINFLO
C
      ELSE
         CONTINUE
C
      END IF
$VARIABLES1
C
C Local Variables
C
C UPAREA - DOUBLE PRECISION - Upstream nodal cross-sectional flow area
C UPRHO  - DOUBLE PRECISION - Upstream nodal density
C
      DOUBLE PRECISION UPAREA , UPRHO
C
      IF(ABS(XOPEN) .LT. 1.0E - 37)THEN
C
         GP(1 , 2 ) = 0.0
C
      ELSE IF(ABS(XOPEN) .LE. 1.0D0)THEN
C
C Determine upstream node for link
C
         IF (M(1 , 2) .GT. 0.0)THEN
C
            UPAREA = FLA1
            UPRHO = RHO(F1)
C
         ELSE
C
            UPAREA = FLA2
            UPRHO = RHO(F2)
C
         END IF
C
C Calculate valve char of by-pass valve
C   Uses DP = E * W ** 2 / ( RHO * XOPEN) ** 2
C      and GP * DP = 0.5 W ** 2 / (RHO * AREA ** 2)
C
         GP(1 , 2) = (UPRHO * XOPEN ** 2.0D0) /
     &                 (2.0D0 * EVALUE * UPAREA ** 2.0D0)
C
      ELSE
C
C flag an error ?
C
      END IF
C
      IF(VALTYP .EQ. 'THREEWAY' )THEN
C
         IF(ABS(1.0D0 - XOPEN) .LT. 1.0E - 37)THEN
C
            GP(1 , 3) = 0.0
C
         ELSE IF(ABS(XOPEN) .LT. 1.0D0)THEN
C
C Determine upstream node for link
C
            IF (M(1 , 3) .GT. 0.0)THEN
C
               UPAREA = FLA1
               UPRHO = RHO(F1)
C
            ELSE
C
               UPAREA = FLA3
               UPRHO = RHO(F3)
C
            END IF
C
            GP(1 , 3) = (UPRHO * (1.0D0 - XOPEN) ** 2.0D0) /
     &                    (2.0D0 * EVALUE * UPAREA ** 2.0D0)
C
         ELSE
C
C Flag error
C
         END IF
C
      ELSE
         CONTINUE
C
      END IF
$ENDMODEL VALVE
#
#
#
$MODEL HXKL
#
#  GENERAL KAYS AND LONDON HEAT EXCHANGER
#
#      P MASON    12 APRIL 1988
#
$LOCALS
$REAL
RL1=%FLH%/2.0;
RL2=%FLC%/2.0;
#
$NODES
# HOT SIDE NODES
F1,1.0,%ADH%,RL1,%PH%,0.0,%TH%,%FFH%,FT=%TYPH%;
F2,1.0,%ADH%,RL1,%PH%,0.0,%TH%,%FFH%,FT=%TYPH%;
# COLD SIDE NODES
F3,1.0,%ADC%,RL2,%PC%,0.0,%TC%,%FFC%,FT=%TYPC%;
F4,1.0,%ADC%,RL2,%PC%,0.0,%TC%,%FFC%,FT=%TYPC%;
#
$CONDUCTORS
M(1,2)=%MFLOWH%;
M(3,4)=%MFLOWC%;
GP(1,2)=%GPH%;
GP(3,4)=%GPC%;
#
$CONSTANTS
$REAL
ETAH=%ETAH%;
ETAC=%ETAC%;
ADH =%ADH%;
ADC =%ADC%;
FLH =%FLH%;
FLC =%FLC%;
#
$SUBROUTINES
      DOUBLE PRECISION FUNCTION NTU(NODEH,NODEC,LH,LC,DH,
     &                             DC,MH,MC,HH,HC)
      INTEGER NODEH,NODEC
      DOUBLE PRECISION LH,LC,DH,DC,MH,MC,HC,HH,STC,STH,CH,CC,
     &     CMIN,UH,UC,NTH,NTC,PI,RHOC,RHOH
C PI
      PI=3.1415926
      RHOC = RHO(NODEC)
      RHOH = RHO(NODEH)
C FLUID VELOCITIES
      UC=MC/(PI*DC*DC*RHOC/4.0)
      UH=MH/(PI*DH*DH*RHOH/4.0)
C STANTON NUMBERS
      STC=HC/(RHO(NODEC)*CP(NODEC)*UC)
      STH=HH/(RHO(NODEH)*CP(NODEH)*UH)
C HEAT CAPACITIES
      CC=MC*CP(NODEC)
      CH=MH*CP(NODEH)
      CMIN=MIN(CC,CH)
C EQUIVALENT NO. OF HEAT TRANSFER UNITS
      NTH=STH*CH/CMIN*LH/(DH/4.0)*ETAH
      NTC=STC*CC/CMIN*LC/(DC/4.0)*ETAC
      NTU=1.0/(1.0/NTH+1.0/NTC)
      RETURN
      END
      DOUBLE PRECISION FUNCTION EFFECT(NTT,CMIN,CMAX,MODE,MFLAG)
      DOUBLE PRECISION NTT,CMIN,CMAX,NUM,DEN,TAU
      INTEGER MODE,MFLAG
      SELECT CASE MODE
          CASE 1
C COUNTERFLOW
          IF (ABS(CMAX/CMIN-1.0) .LT. 0.0001) THEN
              EFFECT=NTT/(1.0+NTT)
          ELSE
              NUM=1.0-EXP(-NTT*(1.0-CMIN/CMAX))
              DEN=1.0-CMIN/CMAX*EXP(-NTT*(1.0-CMIN/CMAX))
              EFFECT=NUM/DEN
          END IF
          CASE 3
C CROSSFLOW HEAT EXCHANGER
          IF (MFLAG.EQ.1) THEN
             TAU=1.0-EXP(-NTT*CMIN/CMAX)
             EFFECT=1.0-EXP(-TAU*CMAX/CMIN)
          ELSE
             TAU=1.0-EXP(-NTT)
             EFFECT=CMAX/CMIN*(1.0-EXP(-TAU*CMIN/CMAX))
          ENDIF
          CASE ELSE
C PARALLEL FLOW (DEFAULT)
          NUM=1.0-EXP(-NTT*(1.0+CMIN/CMAX))
          DEN=1.0+CMIN/CMAX
          EFFECT=NUM/DEN
      END SELECT
      RETURN
      END
$VARIABLES1
      INTEGER INH,INC,MFLAG
      DOUBLE PRECISION HH,HC,NUSS,CH,CC,CMAX,CMIN,NTU,
     &     EFFECT,QKL,EFF,TINC,TINH,TDIAC,TDIAH,PI
      PI=3.1415926
C DETERMINE FLOW DIRECTIONS
           TDIAH=PI*%ADH%*%ADH%/4.0
           TDIAC=PI*%ADC%*%ADC%/4.0
      IF(%MFLOWH%.GT.0.0) THEN
           INH=F1
           TINH=T1
           HH=DBSNCF(INH,TDIAH,ADH)
      ELSE
           INH=F2
           TINH=T2
           HH=DBSNCF(INH,TDIAH,ADH)
      END IF
      IF(%MFLOWC%.GT.0.0) THEN
           INC=F3
           TINC=T3
           HC=DBSNCF(INC,TDIAC,ADC)
      ELSE
           INC=F4
           TINC=T4
           HC=DBSNCF(INC,TDIAC,ADC)
      END IF
C HEAT TRANSRER UNITS
      NUSS=NTU(INH,INC,FLH,FLC,ADH,ADC,M(1,2),M(3,4),HH,HC)
      CH=ABS(M(1,2))*CP(INH)
      CC=ABS(M(3,4))*CP(INC)
      CMAX=MAX(CH,CC)
      CMIN=MIN(CH,CC)
      IF (CMAX.EQ.CC) THEN
         MFLAG=1
      ELSE
         MFLAG=0
      END IF
C EFFECTIVENESS
      EFF=EFFECT(NUSS,CMIN,CMAX,%MODE%,MFLAG)
C HEAT FLOW
      QKL=EFF*CMIN*(TINH-TINC)
      FQ1=-QKL/2.0
      FQ2=-QKL/2.0
      FQ3=QKL/2.0
      FQ4=QKL/2.0
$ENDMODEL
#
#############################################
#############################################
#
$MODEL EVAPORATOR_CAP
#
# PURPOSE:     This element simulates a cylindrical capillary evaporator.
# DESCRIPTION: The fluid network is represented by two fluid nodes F1 and 
#              F2, connected by a mass flow link. The wall is modelled by
#              a thermal node D1002. The user can impose the heat load on  
#              this node. A dummy boundary node is connected to the casing
#              when primed in order to maintain a thermal balance. 
#
# RESTRICTION: Only solver FGENSS or FGENFI is appropriate for this element.
#
# CONNECTION POINTS: F1    -    Inlet
#                    F2    -    Outlet
#                    D1002 -    Evaporator wall
#              
# ORIGIN:      ESATAN/FHTS: CPL Project/W019-C02: ALSTOM Power/00:09:04/HB
#
# ==============================================================================
#
# SUBSTITUTIONS DATA:
#   C_WALL       - REAL      (OPT)     Wall capacitance
#   DELAY_CAPLIM - REAL      (OPT)     Delay in second before re-priming when 
#                                      the evaporator has deprimed because 
#                                      Dp_meniscus > Dp_caplim 
#   DIAMI_WICK   - REAL                Wick inlet diameter
#   DIAMO_WICK   - REAL                Wick outlet diameter
#   DT_SUB       - REAL      (OPT)     Subcooling difference temperature
#   FLA_VAP      - REAL      (OPT)     Flow area for each vapour channels
#   G_DEPRIMED   - REAL      (OPT)     Wall-fluid conductance in deprimed mode
#   G_PRIMED     - REAL                Wall-fluid conductance in primed mode
#   LENGTH       - REAL                Evaporator length 
#   MFLOW        - REAL      (OPT)     Initial mass flow rate
#   MODE         - CHARACTER (OPT)     Operating mode of the evaporator
#   NVAPC        - INTEGER             Number of vapour channels
#   PERM_WICK    - REAL      (OPT)     Permeability of wick
#   PRESS        - REAL                Initial pressure of the fluid
#   Q_LOAD       - REAL      (OPT)     Heat load on the wall
#   Q_START      - REAL      (OPT)     Heat flux to prime the evaporator
#   Q_STOP       - REAL      (OPT)     Heat flux to deprime the evaporator 
#   RAD_PORE     - REAL      (OPT)     Effective pore radius of wick
#   RUG_LIQ      - REAL      (OPT)     Surface roughness of liquid core
#   RUG_VAP      - REAL      (OPT)     Surface roughness of vapour channels
#   TEMP         - REAL                Initial temperature of the fluid
#   THETA_WET    - REAL      (OPT)     Wetting angle of fluid in wick
#   T_WALL       - REAL      (OPT)     Initial wall temperature
#   VQLIMH       - REAL      (OPT)     High limit of vapour quality allowed 
#                                      in wick before depriming
#   VQLIML       - REAL      (OPT)     Low limit of vapour quality allowed
#                                      in wick before priming
#   WIDTH_VAP    - REAL                Width of each vapour channel
#   X_COORD      - REAL      (OPT)     X-coordinate
#   Y_COORD      - REAL      (OPT)     Y-coordinate
#   Z_COORD      - REAL      (OPT)     Z-coordinate
#
# ==============================================================================
#
$DEFAULTS
#
C_WALL = 0.0D0 ;
DELAY_CAPLIM = 0.0D0 ;
DT_SUB = 0.0D0 ;
G_DEPRIMED = %G_PRIMED% ;
MFLOW = 0.0D0 ;
MODE = 'DEPRIMED' ;
PERM_WICK = 1.0D10 ;
Q_LOAD = 0.0D0 ;
Q_START = 0.0D0 ;
Q_STOP = 0.0D0 ;
RAD_PORE = 0.0D0 ;
RUG_LIQ = 0.0D0 ;
RUG_VAP = 0.0D0 ;
THETA_WET = 0.0D0 ;
T_WALL = %TEMP% ;
VQLIMH = 0.0D0 ;
VQLIML = 0.0D0 ;
X_COORD = 0.0D0 ;
Y_COORD = 0.0D0 ;
Z_COORD = 0.0D0 ;
#
FLA_VAP = %WIDTH_VAP% * %WIDTH_VAP% ;
#
$NODES
#
   F1 = 'Inlet ', A = 0.0D0, FD = %DIAMI_WICK% , 
                  FL = %LENGTH%, T = %TEMP% , P = %PRESS% , 
                  FF = %RUG_LIQ%, FX = %X_COORD% ,FY = %Y_COORD% ,
                  FZ = %Z_COORD% ; 
#
   F2 = 'Outlet ', A = 0.0D0 , FD = %WIDTH_VAP% , 
                   FL = %LENGTH%, FLA = %NVAPC% * %FLA_VAP% ,
                   T = %TEMP% , P = %PRESS%, FF = %RUG_VAP% , 
                   FX = %X_COORD% , FY = %Y_COORD% , FZ = %Z_COORD% ;
           
#
   D1002 = 'Casing ', T = %T_WALL%, C = %C_WALL%, QI = Q_load ;
#
# Dummy node to have a thermal balance for the casing when primed
#
   B888 = 'Dummy node ', T = %TEMP% ;
#
$CONDUCTORS
#
M(1, 2) = %MFLOW% ;
GL(1002, 2) = %G_DEPRIMED% ;
GL(1002, 888) = %G_PRIMED% ;
#
$CONSTANTS
#
$REAL
#
Dp_caplim = 0.0D0 ;              # Capillary limit of the wick
Dp_meniscus = 0.0D0 ;            # Pressure rise across meniscus
Dp_wick = 0.0D0 ;                # DARCY pressure loss
Dt_sub = %DT_SUB% ;              # Subcooling difference temperature
G_deprimed = %G_DEPRIMED% ;      # Wall-fluid conductance in deprimed mode
G_primed = %G_PRIMED% ;          # Wall-fluid conductance in primed mode
Q_load = %Q_LOAD% ;              # Heat load on the wall
Q_primed = 0.0D0 ;               # Heat flux during priming
Q_start = %Q_START% ;            # Heat flux to prime the evaporator
Q_stop = %Q_STOP% ;              # Heat flux to deprime the evaporator
Timdry = 0.0D0 ;                 # Time when dryout
Ts = 0.0D0 ;                     # Liquid saturation temperature
#
$INTEGER
#
Dryflg = 0 ;                     # Flag set to 1 when dryout occurs
#
$CHARACTER
#
Mode = 'CHAR * 8' ;              # Evaporator operating mode; initialised
                                 # properly in $INITIAL
#
$SUBROUTINES
#
       SUBROUTINE DARCY(DPV, DPWICK)
#
# ==============================================================================
#
# PURPOSE:       Calculation of the pressure drop given by Darcy's law and its
#                derivative wrt volumetric flow rate
#
# OUTPUT:
#
#   DPV           DOUBLE PRECISION   Darcy derivative
#   DPWICK        DOUBLE PRECISION   Darcy pressure loss
#
# LOCAL:
#
#   DDFLG         LOGICAL            Flag set to TRUE if the calculation has
#                                    to be done
#   DIAM          DOUBLE PRECISION   Inlet diameter
#   EFF           DOUBLE PRECISION   Effectiveness factor
#   RHOF          DOUBLE PRECISION   Fluid density
#   RHOL          DOUBLE PRECISION   Liquid density
#   RHOV          DOUBLE PRECISION   Vapour density
#   UPNODE        INTEGER            Upstream node name (F1 or F2)
#   UPPRES        DOUBLE PRECISION   Pressure of the upstream node  
#   UPQUAL        DOUBLE PRECISION   Vapour quality of the upstream node
#   VAPL          DOUBLE PRECISION   Vapour quality for pure liquid
#   VAPV          DOUBLE PRECISION   Vapour quality for pure vapour
#   VISCF         DOUBLE PRECISION   Fluid viscosity
#   VISCL         DOUBLE PRECISION   Liquid viscosity
#   VISCV         DOUBLE PRECISION   Vapour viscosity
#   VFRAC         DOUBLE PRECISION   Outlet void fraction
#
# ==============================================================================
#
       DOUBLE PRECISION DENSY, DIAM, DPV, DPWICK, EFF, PI, RHOF, RHOL, RHOV,
     &                  UPPRES, UPQUAL, VAPL, VAPV, VISCF, VISCL , VISCV, VFRAC 
       LOGICAL DDFLG
       INTEGER UPNODE
#
# ==============================================================================
#
       PARAMETER(PI = 3.1415927D0, VAPL = 0.0D0, VAPV = 1.0D0)
#
# ==============================================================================
#
       IF (M(1, 2) .GE. 0.0D0) THEN
#
# assign the right properties whether the flow is forward or backward
#
          UPQUAL = VQ1
          UPPRES = P1
          UPNODE = F1
       ELSE
          UPQUAL = VQ2
          UPPRES = P2
          UPNODE = F2
       END IF
#
       IF (UPQUAL .EQ. 1.0D0 .AND. MODULE .EQ. 'FGENFI') THEN
#
          IF (Dryflg .EQ. 1) THEN
#
# if dry out has occured, the fluid properties at saturation
# will be used according to the phase separation facility
#
             EFF = 1.0D0
             VISCF = PROPS2(FT1, 'VISC', UPPRES, UPQUAL, 'P&VQ')
             DENSY = PROPS2(FT1, 'RHO', UPPRES, UPQUAL, 'P&VQ')
             DDFLG = .TRUE.
          ELSE
#
# infinite resistance set to block all flow
#
             EFF = 0.0D0
             VISCF = PROPS2(FT1, 'VISC', UPPRES, VAPL, 'P&VQ')
             DENSY = PROPS2(FT1, 'RHO', UPPRES, VAPL, 'P&VQ')
             DDFLG = .TRUE.
          END IF 
#
       ELSE
#
          IF (%PERM_WICK% .GE. 1.0D10) THEN
             DPV = 0.0D0
             DPWICK = 0.0D0
             DDFLG = .FALSE.
          ELSE
#
             IF (MODULE .EQ. 'FGENSS') THEN
#
                IF (UPQUAL .EQ. 0.0D0) THEN
#
# if pure liquid at the inlet, the node properties 
# will be used according to the phase separation facility
#
                   VISCF = VISC(UPNODE)
                   DENSY = RHO(UPNODE)
                   EFF = 1.0D0
                   DDFLG = .TRUE.
                ELSE
#
# if two phase fluid at the inlet, the liquid properties at saturation
# will be used according to the phase separation facility
#
                   EFF = 1.0D0
                   VISCF = PROPS2(FT1, 'VISC', UPPRES, VAPL, 'P&VQ')
                   DENSY = PROPS2(FT1, 'RHO', UPPRES, VAPL, 'P&VQ')
                   DDFLG = .TRUE.
                END IF
#
             ELSE
#
                IF (UPQUAL .EQ. 0.0D0) THEN
#
# if pure liquid at the inlet, the node properties 
# will be used according to the phase separation facility
#
                   VISCF = VISC(UPNODE)
                   DENSY = RHO(UPNODE)
                   EFF = 1.0D0
                   DDFLG = .TRUE.
                ELSE
#
# if two phase fluid at the inlet, the liquid properties at saturation
# will be used according to the phase separation facility
#
                   RHOL = PROPS2(FT1, 'RHO', UPPRES, VAPL, 'P&VQ')
                   RHOV = PROPS2(FT1, 'RHO', UPPRES, VAPV, 'P&VQ')
                   VISCF = PROPS2(FT1, 'VISC', UPPRES, VAPL, 'P&VQ')
                   VFRAC = 1.0D0 / (1.0D0 + (1.0D0 / UPQUAL - 1.0D0) *
     &                     (RHOV / RHOL))
                   DENSY = PROPS2(FT1, 'RHO', UPPRES, VAPL, 'P&VQ')
                   EFF = 1.0D0 - VFRAC
                   DDFLG = .TRUE.
                END IF
#
             END IF
#
          END IF
#
       END IF
#
       IF (DDFLG) THEN
          EFF = MAX(EFF, 1.0D-10)
          DPV = -VISCF * LOG(%DIAMO_WICK%
     &             / %DIAMI_WICK%) / (2.0D0 * PI * %PERM_WICK% *
     &             EFF * %LENGTH%)
          DPWICK = DPV * M(1, 2) / DENSY
       END IF
#
# ==============================================================================
#
       RETURN
#
# ==============================================================================
#
       END
#
$INITIAL
       Mode = %MODE%
#
       CALL STATST('GL(1002, 888)', 'OFF')
#
$VARIABLES1
#
# ==============================================================================
#
# LOCAL:
#   DVDARC         DOUBLE PRECISION   Darcy derivative
#   ENAME          CHARACTER          Element name string
#   ERR            INTEGER            Error number
#   MESAGE         CHARACTER          Error message string
#   PI             DOUBLE PRECISION   Pi coefficient
#   TYPE           INTEGER            Error type
#
# ==============================================================================
#
       CHARACTER ENAME * 14, MESAGE * 150
       INTEGER ERR, TYPE
       DOUBLE PRECISION DVDARC, PI
#
# ==============================================================================
#
       PARAMETER(PI = 3.1415927D0)
#
# ==============================================================================
#
# calculation of the saturation temperature
#
       Ts = PROPS1(FT2, 'TSAT', P2, 'P')
#
# calculation of q_primed
#
       Q_primed = G_primed * (T1002 - Ts)
#
# set the dummy boundary node temperature to the saturation temperature
#
       T888 = Ts
#
       IF (MODULE .EQ. 'FGENSS' .AND. Mode .EQ. 'PRIMED') THEN
          GL(1002, 888) = G_primed
#
# set the conductor between the casing and the dummy node ON
#
          CALL STATST('GL(1002, 888)', 'ON')
#
# set the conductor between the casing and the fluid outlet node OFF
#
          CALL STATST('GL(1002, 2)', 'OFF')
#
# set the mass flow link as evaporative
#
          CALL MTYPST('M(1, 2)', 'EVAP')
#
          IF (SOLTYP .EQ. 'FLUID') THEN
#
# set Q_primed onto the mass flow link. Q_primed can sometimes be
# negative during some iterations of the solid node solution. To
# avoid this, the MAX subroutine is used
#
             CALL EVLQST('M(1, 2)', MAX(Q_primed, 0.0D0))
#
          END IF
#
       ELSE IF (MODULE .EQ. 'FGENFI' .AND. Mode .EQ. 'PRIMED') THEN
          GL(1002, 888) = G_primed
#
          IF (SOLTYP .EQ. 'FLUID') THEN
#
# set Q_primed onto the mass flow link. Q_primed can sometimes be 
# negative during some iterations of the solid node solution. To
# avoid this, the MAX subroutine is used 
#
             CALL EVLQST('M(1, 2)', MAX(Q_primed, 0.0D0))
#
          END IF
#
       ELSE IF ((MODULE .EQ. 'FGENFI' .OR. MODULE .EQ. 'FGENSS') 
     &          .AND. Mode .EQ. 'DEPRIMED') THEN
#
# the evaporator is deprimed
#  
          GL(1002, 2) = G_deprimed
#
# set the phase separation vapour quality as pure liquid for both directions
# (mass flow link must be momentum)
#
          CALL MTYPST('M(1, 2)', 'MOM')
#
          CALL PHSDST('M(1, 2)', 'BOTH')
#
          CALL PHSXST('M(1, 2)', 'BOTH', 0.0D0)
#
          IF (SOLTYP .EQ. 'FLUID') THEN
#
# Calculation of the pressure drop given by Darcy's law
#
             CALL DARCY(DVDARC, Dp_wick)
#
             CALL SETDPV('M(1, 2)', Dp_wick, DVDARC)
#
          END IF
#
       ELSE 
#
# error
#
          IF (Mode .NE. 'PRIMED' .AND. Mode .NE. 'DEPRIMED') THEN
             MESAGE = 'Element EVAPORATOR_CAP - Mode is incorrect@'//
     &                'User constant Mode should be either PRIMED or DEPRIMED'
             ENAME = 'EVAPORATOR_CAP'
             TYPE = 4
             ERR = 1
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
          END IF
#
          IF (MODULE .NE. 'FGENSS' .AND. MODULE .NE. 'FGENFI') THEN
             MESAGE = 'Element EVAPORATOR_CAP - The solver is incorrect@'//
     &                'The solver should be either FGENSS or FGENFI'
             ENAME = 'EVAPORATOR_CAP'
             TYPE = 4
             ERR = 2
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
          END IF
#
       END IF
#
$VARIABLES2
#
# ==============================================================================
#
# LOCAL:
#   DVDARC         DOUBLE PRECISION   Darcy derivative
#   ENAME          CHARACTER          Element name string
#   ERR            INTEGER            Error number
#   MESAGE         CHARACTER          Error message string
#   PI             DOUBLE PRECISION   Pi coefficient
#   PORRAD         DOUBLE PRECISION   Effective pore radius of wick
#   SIGMA          DOUBLE PRECISION   Surface tension
#   TYPE           INTEGER            Error type
#
# ==============================================================================
#
       CHARACTER ENAME * 14, MESAGE * 150
       INTEGER ERR, TYPE
       DOUBLE PRECISION DVDARC, PI, PORRAD, SIGMA
#
# ==============================================================================
#
       PARAMETER(PI = 3.1415927D0)
#
# ==============================================================================
#
# Calculation of the capillary limit Dp_caplim
#
       PORRAD = %RAD_PORE%
#
       IF (PORRAD .LE. 0.0D0) THEN 
          Dp_caplim = 1.0D10
       ELSE
          SIGMA = PROPS2(FT2, 'SIG', Ts, 0.0D0, 'T&VQ')
          Dp_caplim = 2.0D0 * SIGMA * COS(%THETA_WET%) / PORRAD
       END IF
#
# Calculation of the pressure drop given by Darcy's law
#
       CALL DARCY(DVDARC, Dp_wick)
#
# Calculation of the pressure rise over liquid/vapour interface
#
       Dp_meniscus = P2 - P1 - Dp_wick
#
       Ts = PROPS1(FT2, 'TSAT', P2, 'P')
       Q_primed = G_primed * (T1002 - Ts)
#
# Deprimed -> Primed transition
#
       IF (Mode .EQ. 'DEPRIMED') THEN
#
          IF (Q_primed .GE. Q_start .AND. T1 .LE. Ts - Dt_sub
     &       .AND. Dp_meniscus .LE. Dp_caplim 
     &       .AND. VQ1 .LE. %VQLIML% .AND. Dp_meniscus .GE. 0.0D0) THEN
#
             IF (MODULE .EQ. 'FGENSS') THEN
                WRITE(*, *)'@' 
                WRITE(*, *)'@@@@  WARNING   : The conditions required to' //
     &                                       ' maintain the evaporator'
                WRITE(*, *)'@                 deprimed are not satisfied.'
                WRITE(*, *)'@                 The evaporator has primed. '
#
             ELSE
#
                IF (Dryflg .EQ. 1 .AND. 
     &             TIMEN .GT. Timdry + %DELAY_CAPLIM% .OR.
     &             Dryflg .EQ. 0) THEN
                   Mode = 'PRIMED'
                   Dryflg = 0
                   T888 = Ts
#
# set the conductor between the casing and the dummy node ON
#
                   CALL STATST('GL(1002, 888)', 'ON')
#
# set the conductor between the casing and the fluid outlet node OFF
#
                   CALL STATST('GL(1002, 2)', 'OFF')
#
                   GL(1002, 888) = G_primed
#
# set the mass flow link as evaporative
#
                   CALL MTYPST('M(1, 2)', 'EVAP')
#
                END IF
# 
             END IF 
#
          END IF
#
# Primed -> Deprimed transition
#
       ELSE IF (Mode .EQ. 'PRIMED') THEN
#
          IF (Q_primed .LE. Q_stop .OR. T1 .GT. Ts - Dt_sub
     &       .OR. Dp_meniscus .GT. Dp_caplim 
     &       .OR. VQ1 .GT. %VQLIMH%
     &       .OR. Dp_meniscus .LT. 0.0D0) THEN
             Mode = 'DEPRIMED'
#
             IF (MODULE .EQ. 'FGENSS') THEN
                WRITE(*, *)'@  '
                WRITE(*, *)'@@@@  WARNING   : The conditions required to' //
     &                                       ' maintain the evaporator'
                WRITE(*, *)'@                 primed are not satisfied.'
                WRITE(*, *)'@                 The evaporator has deprimed. '
#
             ELSE
#
# set the conductor between the casing and the fluid outlet node ON
#
                CALL STATST('GL(1002, 2)', 'ON')
#
# set the conductor between the casing and the dummy node OFF
#
                CALL STATST('GL(1002, 888)', 'OFF')
#
                GL(1002, 2) = G_deprimed
#
# set the mass flow link as momentum
#
                CALL MTYPST('M(1, 2)', 'MOM')
#
# If the depriming did occur because the pressure rise accross
# the meniscus is greater than the capillary limit or because
# of a too high vapour quality at the inlet, we have to switch
# off the phase separation and set the dryout flag to 1 
# to impose a time delay before re-priming.
#
                IF (Dp_meniscus .GT. Dp_caplim .OR. VQ1 .GT. %VQLIMH%) THEN
                   Dryflg = 1
                   Timdry = TIMEN
#
# switch off the phase separation
#
                   CALL PHSDST('M(1, 2)', 'NONE')
#
                ELSE
#
# set the phase separation vapour quality as pure liquid for both directions
# 
                   CALL PHSDST('M(1, 2)', 'BOTH')
#
                   CALL PHSXST('M(1, 2)', 'BOTH', 0.0D0)
#
                END IF
#
             END IF
#
          END IF
#
       ELSE 
#
# error
#
          IF (Mode .NE. 'PRIMED' .AND. Mode .NE. 'DEPRIMED') THEN
             MESAGE = 'Element EVAPORATOR_CAP - Mode is incorrect@'//
     &                'User constant Mode should be either PRIMED or DEPRIMED'
             ENAME = 'EVAPORATOR_CAP'
             TYPE = 4
             ERR = 3
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
          END IF
#
       END IF
#
       IF (Mode .EQ. 'PRIMED') THEN
#
# set Q_primed onto the mass flow link
#
          CALL EVLQST('M(1, 2)', Q_primed)
#
       END IF
#
$ENDMODEL EVAPORATOR_CAP
#
#
############################################
############################################
#
#
$MODEL FILTER_CAP 
#
# PURPOSE:     This element simulates a capillary filter.
# DESCRIPTION: It is composed of two fluid nodes F1 (inlet) and 
#              F2 (outlet).The casing is modelled by a thermal node D1002. 
#              This element can handle either a circular or an annular filter.
#              The circular design is used as the default design.
#
# RESTRICTION: Only solver FGENSS or FGENFI is appropriate for this element.
#
# CONNECTION POINTS: F1      -   Inlet
#                    F2      -   Outlet
#                    D1002   -   Filter wall 
#         
# ORIGIN:      ESATAN/FHTS: CPL Project/W019-CO2: ALSTOM Power/00:10:02/HB
#
# ==============================================================================
#
# SUBSTITUTIONS DATA:
#   C_WALL       - REAL      (OPT)   Wall capacitance
#   DIAM         - REAL              Diameter (outer diameter if annular design)
#   DIAMI_WICK   - REAL      (OPT)   Inner diameter if annular design
#   DIAMO_WICK   - REAL      (OPT)   Outer diameter for the wick (only for 
#                                    annular filter)
#   G_WF         - REAL      (OPT)   Thermal conductance wall/fluid
#   LENGTH       - REAL              Filter length
#   LENGTH_WICK  - REAL      (OPT)   Wick length 
#   MFLOW        - REAL      (OPT)   Intial Mass flow rate
#   MODE         - CHARACTER (OPT)   Operating mode ('PRIMED' or 'DEPRIMED')
#   PERM_WICK    - REAL      (OPT)   Permeability of wick
#   PRESS        - REAL              Initial pressure of the fluid
#   RAD_PORE     - REAL      (OPT)   Effective pore radius of wick
#   RUG          - REAL      (OPT)   Surface roughness of the pipe
#   TEMP         - REAL              Initial fluid temperature
#   THETA_WET    - REAL      (OPT)   Wetting angle of fluid in wick
#   TYPE_FILT    - CHARACTER (OPT)   Filter type, circular design or annular
#                                    design
#   T_WALL       - REAL      (OPT)   Initial wall temperature
#   VQ_WET       - REAL      (OPT)   Minimum vapour quality to re-prime                            
#   X_COORD      - REAL      (OPT)   X-coordinate
#   Y_COORD      - REAL      (OPT)   Y-coordinate
#   Z_COORD      - REAL      (OPT)   Z-coordinate
#
# ==============================================================================
#
$DEFAULTS
#
C_WALL = 0.0D0 ;
DIAMI_WICK = 0.0D0 ;
DIAMO_WICK = 0.0D0 ;
G_WF = 0.0D0 ;
LENGTH_WICK = 0.0D0 ;
MFLOW = 0.0D0 ;
MODE = 'PRIMED  ' ;
PERM_WICK  = 1.0D10 ;
RAD_PORE = 0.0D0 ;
RUG = 0.0D0 ;
THETA_WET = 0.0D0 ;
TYPE_FILT = 'CIRC' ;
T_WALL = %TEMP% ;
VQ_WET = 1.0D0 ;
X_COORD = 0.0D0;
Y_COORD = 0.0D0 ;
Z_COORD = 0.0D0 ;
#
$NODES
#
   F1 = 'Inlet ' , A = 0.0D0, FD = %DIAM% ,
                   FL = (%LENGTH% - %LENGTH_WICK%) / 2.0D0,
                   T = %TEMP% , P = %PRESS% , FF = %RUG%,
                   FX = %X_COORD%, FY = %Y_COORD%, FZ = %Z_COORD% ;
#
   F2 = 'Outlet ' , A = 0.0D0, FD = %DIAM% ,
                    FL = (%LENGTH% - %LENGTH_WICK%) / 2.0D0,
                    T = %TEMP% , P = %PRESS% , FF = %RUG%,
                    FX = %X_COORD%, FY = %Y_COORD%, FZ = %Z_COORD% ;
#
   D1002 = 'Casing ' , T = %T_WALL%, C = %C_WALL% ;
#
$CONDUCTORS
#
GL(1002, 2) = %G_WF% ;
M(1, 2) = %MFLOW% ;
#
$CONSTANTS
#
$REAL
# 
Dp_caplim = 0.0D0 ;              # Capillary limit of the wick
Dp_wick = 0.0D0 ;                # Pressure drop through the wick
#
$CHARACTER
#
Mode = 'CHAR * 8' ;              # Filter operating mode; initialised
                                 # properly in $INITIAL
#
$SUBROUTINES
#
       SUBROUTINE DARCY(DPV, DPWICK)
#
# ==============================================================================
#
# PURPOSE:       Calculation of the pressure drop given by Darcy's law and its
#                derivative wrt volumetric flow rate
#
# OUTPUT:
#
#   DPV           DOUBLE PRECISION   Darcy derivative
#   DPWICK        DOUBLE PRECISION   Darcy pressure loss
#
# LOCAL:
#
#   DDFLG         LOGICAL            Flag set to TRUE if the calculation has
#                                    to be done
#   DIAM          DOUBLE PRECISION   Inlet diameter
#   EFF           DOUBLE PRECISION   Effectiveness factor
#   PI            DOUBLE PRECISION   Pi coefficient
#   RHOF          DOUBLE PRECISION   Fluid density
#   RHOL          DOUBLE PRECISION   Liquid density
#   RHOV          DOUBLE PRECISION   Vapour density
#   VAPL          DOUBLE PRECISION   Vapour quality for pure liquid
#   VAPV          DOUBLE PRECISION   Vapour quality for pure vapour
#   VISCF         DOUBLE PRECISION   Fluid viscosity
#   VISCL         DOUBLE PRECISION   Liquid viscosity
#   VISCV         DOUBLE PRECISION   Vapour viscosity
#   VFRAC         DOUBLE PRECISION   Outlet void fraction
#
# ==============================================================================
#
       DOUBLE PRECISION DENSY, DIAM, DPV, DPWICK, EFF, PI, RHOF , RHOL,
     &                  RHOV, VAPL, VAPV, VISCF, VISCL , VISCV, VFRAC
       LOGICAL DDFLG
#
# ==============================================================================
#
       PARAMETER(VAPL = 0.0D0, VAPV = 1.0D0, PI = 3.1415927D0)
#
# ==============================================================================
#
#
       IF (MODULE .NE. 'FGENSS' .AND. VQ1 .EQ. 1.0D0 .AND.
     &     Mode .EQ. 'PRIMED') THEN
#
# infinite resistance set to block all flow
#
          EFF = 0.0D0
          VISCF = PROPS2(FT1, 'VISC', P1, VAPL, 'P&VQ')
          DENSY = PROPS2(FT1, 'RHO', P1, VAPL, 'P&VQ')
          DDFLG = .TRUE.
       ELSE
#
          IF (%PERM_WICK% .GE. 1.0D10) THEN
             DPV = 0.0D0
             DPWICK = 0.0D0
             DDFLG = .FALSE.
          ELSE
#
             IF (MODULE .EQ. 'FGENSS' .AND. Mode .EQ. 'PRIMED') THEN
#
                IF (VQ1 .EQ. 0.0D0) THEN
#
# if pure liquid at the inlet, the node properties
# will be used according to the phase separation facility
#
                   VISCF = VISC(F1)
                   DENSY = RHO(F1)
                   EFF = 1.0D0
                   DDFLG = .TRUE.
                ELSE
#
# if two phase fluid at the inlet, the liquid properties at saturation
# will be used according to the phase separation facility
#
                   EFF = 1.0D0
                   VISCF = PROPS2(FT1, 'VISC', P1, VAPL, 'P&VQ')
                   DENSY = PROPS2(FT1, 'RHO', P1, VAPL, 'P&VQ')
                   DDFLG = .TRUE.
                END IF
#
             ELSE IF (Mode .EQ. 'DEPRIMED') THEN
                EFF = 1.0D0
                VISCF = VISC(F1)
                DENSY = RHO(F1)
                DDFLG = .TRUE.
             ELSE
#
                IF (VQ1 .EQ. 1.0D0) THEN
#
# infinite resistance set to block all flow
#
                   EFF = 0.0D0
                   VISCF = PROPS2(FT1, 'VISC', P1, VAPL, 'P&VQ')
                   DENSY = PROPS2(FT1, 'RHO', P1, VAPL, 'P&VQ')
                   DDFLG = .TRUE.
                ELSE
#
                   IF (VQ1 .EQ. 0.0D0) THEN
#
# if pure liquid at the inlet, the node properties
# will be used according to the phase separation facility
#
                      VISCF = VISC(F1)
                      DENSY = RHO(F1)
                      EFF = 1.0D0
                      DDFLG = .TRUE.
                   ELSE
#
# if two phase fluid at the inlet, the liquid properties at saturation
# will be used according to the phase separation facility
#
                      RHOL = PROPS2(FT1, 'RHO', P1, VAPL, 'P&VQ')
                      RHOV = PROPS2(FT1, 'RHO', P1, VAPV, 'P&VQ')
                      VISCF = PROPS2(FT1, 'VISC', P1, VAPL, 'P&VQ')
                      VFRAC = 1.0D0 / (1.0D0 + (1.0D0 / VQ1 - 1.0D0) *
     &                        (RHOV / RHOL))
                      DENSY = PROPS2(FT1, 'RHO', P1, VAPL, 'P&VQ')
                      EFF = 1.0D0 - VFRAC
                      DDFLG = .TRUE.
                   END IF
#
                END IF
#
             END IF
#
          END IF
#
       END IF
#
       IF (DDFLG) THEN
          EFF = MAX(EFF, 1.0D-10)
#
          IF (%TYPE_FILT% .EQ. 'CIRC') THEN
#
# Calculation of the pressure drop given by Darcy's law for a circular design
#
             DPV = - VISCF * %LENGTH_WICK%
     &                / (%PERM_WICK% * EFF * FLA2)
             DPWICK = DPV * M(1, 2) / DENSY
          ELSE 
#
# Calculation of the pressure drop given by Darcy's law for an annular design
#
             IF (%DIAMO_WICK% .EQ. 0.0D0) THEN
                DPV = 0.0D0
                DPWICK = DPV * M(1, 2) / DENSY
             ELSE
                DIAM = %DIAMI_WICK%
                DPV = - VISCF * LOG(%DIAMO_WICK% / DIAM) /
     &                  ( 2.0D0 * PI * %PERM_WICK% *
     &                  EFF * %LENGTH%)
                DPWICK = DPV * M(1, 2) / DENSY
             END IF
#
          END IF
#
       END IF
#
# ==============================================================================
#
       RETURN
#
# ==============================================================================
#
       END
#
$INITIAL
#
# ==============================================================================
#
# LOCAL:
#   ANFLAI            DOUBLE PRECISION   Inlet annular flow area 
#   ANFLAO            DOUBLE PRECISION   Outlet annular flow area
#   ANFLA             DOUBLE PRECISION   Ideal outlet annular flow area
#   ENAME             CHARACTER          Element name string
#   ERR               INTEGER            Error number
#   MESAGE            CHARACTER          Error message string
#   PI                DOUBLE PRECISION   Pi coefficient
#   TYPE              INTEGER            Error type
#
# ==============================================================================
#
       CHARACTER ENAME * 10, MESAGE * 150
       INTEGER ERR, TYPE 
       DOUBLE PRECISION ANFLA, ANFLAI, ANFLAO, PI
#
# ==============================================================================
#
       PARAMETER(PI = 3.1415927D0) 
#
# ==============================================================================
#
       Mode = %MODE%
#
       Dp_wick = P2 - P1
#
       IF (%TYPE_FILT% .EQ. 'CIRC') THEN
#
          IF (%DIAMI_WICK% .NE. 0.0D0) THEN
             MESAGE = 'Element FILTER_CAP - The filter type is circular@' //
     &                'DIAMI_WICK will be ignored'
             ENAME = 'FILTER_CAP'
             TYPE = 2
             ERR = 1
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)               
#
          END IF
#
          IF (%DIAMO_WICK% .NE. 0.0D0) THEN
             MESAGE = 'Element FILTER_CAP - The filter type is circular@' //
     &                'DIAMO_WICK will be ignored'
             ENAME = 'FILTER_CAP'
             TYPE = 2
             ERR = 2
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
          END IF
#
       ELSE IF (%TYPE_FILT% .EQ. 'ANN') THEN
#
# ANnular FLow Area for the Outlet
#
          ANFLAO = PI * (%DIAM% * %DIAM% - %DIAMO_WICK% * 
     &                   %DIAMO_WICK%) / 4.0D0     
#
# Ideal ANnular FLow Area for the outlet (no wick)
#
          ANFLA = PI * (%DIAM% * %DIAM% - %DIAMI_WICK% *
     &                  %DIAMI_WICK%) / 4.0D0 
#
# ANnular FLow Area for the Inlet
#
          ANFLAI = PI * %DIAMI_WICK% * %DIAMI_WICK% / 4.0D0      
#
          IF (%DIAMI_WICK% .EQ. 0.0D0) THEN
             MESAGE = 'Element FILTER_CAP - Incorrect DIAMI_WICK specified@' //
     &                'With an annular filter design'//
     &                ' inner diameter must be defined'
             ENAME = 'FILTER_CAP'
             TYPE = 4
             ERR = 3
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)          
#
          END IF
#
          FD1 = %DIAMI_WICK%
          FL1 = %LENGTH%
          FLA1 = ANFLAI
          FL2 = %LENGTH%
#
          IF (%DIAMO_WICK% .EQ. 0.0D0) THEN
             FD2 = %DIAM% - %DIAMI_WICK%
             FLA2 = ANFLA
          ELSE
             FD2 = %DIAM% - %DIAMO_WICK%
             FLA2 = ANFLAO
          END IF
#
       ELSE
          MESAGE = 'TYPE_FILT must be CIRC or ANN@'
          ENAME = 'FILTER_CAP'
          TYPE = 4
          ERR = 4
#
          CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
       END IF
#
# set the phase separation vapour quality as pure liquid for forward direction
#
       CALL PHSDST('M(1, 2)', 'FWD')
#
       CALL PHSXST('M(1, 2)', 'FWD', 0.0D0)
#
$VARIABLES1
#
# ==============================================================================
#
# LOCAL:
#   DENSY          DOUBLE PRECISION   Fluid density
#   DPVWIK         DOUBLE PRECISION   Darcy derivative
#   MFLOW          DOUBLE PRECISION   Mass flow rate
#
# ==============================================================================
#
       DOUBLE PRECISION DENSY, DPVWIK, MFLOW 
#
# ==============================================================================
#
       MFLOW = M(1, 2)
#
       IF (MODULE .EQ. 'FGENSS' .AND. Mode .EQ. 'DEPRIMED') THEN
#
# switch off the phase separation
#
          CALL PHSDST('M(1, 2)', 'NONE')
#
       END IF
#
       IF (SOLTYP .EQ. 'FLUID') THEN
#
          CALL DARCY(DPVWIK, Dp_wick)
# 
          CALL SETDPV('M(1, 2)', Dp_wick, DPVWIK)
#
       END IF
#
$VARIABLES2
#
# ==============================================================================
#
# LOCAL:
#   ENAME            CHARACTER          Element name string
#   ERR              INTEGER            Error number
#   MESAGE           CHARACTER          error message
#   PORRAD           DOUBLE PRECISION   Effective pore radius
#   SIGMA            DOUBLE PRECISION   Surface tension
#   TS               DOUBLE PRECISION   Saturation temperature
#   TYPE             INTEGER            Error type
#
# ==============================================================================
#
       DOUBLE PRECISION PORRAD, SIGMA, TS
       CHARACTER ENAME * 10, MESAGE * 150
       INTEGER ERR, TYPE
#
# ==============================================================================
#
# Calculation of the capillary limit Dp_caplim
#
       PORRAD = %RAD_PORE%
#
       IF (PORRAD .LE. 0.0D0) THEN
          Dp_caplim = 1.0D10
       ELSE
          TS = PROPS1(FT1, 'TSAT', P1, 'P')
          SIGMA = PROPS2(FT1, 'SIG', TS, 0.0D0, 'T&VQ')
          Dp_caplim = 2.0D0 * SIGMA * COS(%THETA_WET%) / PORRAD
       END IF
#
# Primed -> Deprimed transition
#
       IF (Mode .EQ. 'PRIMED') THEN
#
          IF (VQ1 .GT. 0.0D0) THEN
# 
             IF (MODULE .EQ. 'FGENSS') THEN
                Mode = 'DEPRIMED'
                WRITE(*, *)'@'
                WRITE(*, *)'@@@@  WARNING   : The conditions required to' //
     &                                       ' maintain the filter'
                WRITE(*, *)'@                 primed are not satisfied.'
                WRITE(*, *)'@                 The filter has deprimed. '
#
             ELSE IF(- Dp_wick .GT. Dp_caplim) THEN
                Mode = 'DEPRIMED'
#
# switch off phase separation
#
                CALL PHSDST('M(1, 2)', 'NONE') 
#
             END IF
#
          END IF
#
       ELSE IF (Mode .EQ. 'DEPRIMED') THEN
#
# Deprimed -> Primed transition
#
          IF (VQ1 .LT. %VQ_WET% .AND. - Dp_wick .LE. Dp_caplim) THEN
             Mode = 'PRIMED'
#
             IF (MODULE .EQ. 'FGENSS') THEN
                WRITE(*, *)'@'
                WRITE(*, *)'@@@@  WARNING   : The conditions required to' //
     &                                       ' maintain the filter'
                WRITE(*, *)'@                 deprimed are not satisfied.'
                WRITE(*, *)'@                 The filter has primed. '
             ELSE
#
# set the phase separation vapour quality as pure liquid for forward direction
#
                CALL PHSDST('M(1, 2)', 'FWD')
#
                CALL PHSXST('M(1, 2)', 'FWD', 0.0D0) 
#
             END IF
#
          END IF
#
       ELSE
#
# error
#
          IF (Mode .NE. 'PRIMED' .AND. Mode .NE. 'DEPRIMED') THEN
             MESAGE = 'Element FILTER_CAP - Mode is incorrect@'//
     &                'User constant Mode should be either PRIMED or DEPRIMED'
             ENAME = 'FILTER_CAP'
             TYPE = 4
             ERR = 4
#
             CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
          END IF
#
       END IF
#
       IF (M(1, 2) .LT. 0.0D0 .AND. VQ2 .GT. 0.0D0) THEN
          WRITE(*, *)'@'
          WRITE(*, *)'@@@@  WARNING   : Backflow is detected in the filter'
          MESAGE = '@                 at TIMEN =                   ' 
          WRITE(MESAGE(30 : 45), '(E16.4)') TIMEN
          WRITE(*, *) MESAGE
          WRITE(*, *)'@                 '
       END IF
#

$ENDMODEL FILTER_CAP 
#
#
############################################
############################################
#
#
$MODEL RESERVOIR_2PH
#
# PURPOSE:     This element simulates a two-phase reservoir.
# DESCRIPTION: It is composed of one fluid node (F1) modelling the working
#              fluid volume and an arithmetic fluid node (H2) for the
#              inlet/outlet. The casing is modelled by a thermal node (D1001).
#              This element allows two-phase fluid to enter into the reservoir
#              but only pure liquid can leave it. This phase separation is
#              carried out by calling PHSDST and PHSXST subroutines.
#
# RESTRICTION: Only solver FGENSS or FGENFI is appropriate for this element.
#
# CONNECTION POINTS:  H2    -   Inlet/outlet
#                     D1001 -   Reservoir wall
#              
# ORIGIN:      ESATAN/FHTS: CPL Project/W019-CO2: ALSTOM Power/00:10:10/HB
#
# ==============================================================================
#
# SUBSTITUTIONS DATA:
#   C_WALL    - REAL    (OPT)   Wall capacitance
#   DIAM      - REAL            Diameter
#   G_WF      - REAL    (OPT)   Thermal conductance wall/fluid
#   LENGTH    - REAL            Reservoir length
#   MFLOW     - REAL    (OPT)   Initial mass flow rate
#   PRESS     - REAL            Initial fluid pressure
#   Q_EXT     - REAL    (OPT)   Direct heat flux into casing
#   Q_INT     - REAL    (OPT)   Direct heat flux into fluid 
#   RUG       - REAL    (OPT)   Surface roughness
#   VOID_FRAC - REAL    (OPT)   Initial void Fraction for the reservoir
#   X_COORD   - REAL    (OPT)   X-coordinate
#   Y_COORD   - REAL    (OPT)   Y-coordinate
#   Z_COORD   - REAL    (OPT)   Z-coordinate
#
# ==============================================================================
#
$DEFAULTS
#
C_WALL = 0.0D0 ;
G_WF = 0.0D0 ;
MFLOW = 0.0D0 ;
Q_EXT = 0.0D0 ;
Q_INT = 0.0D0 ;
RUG = 0.0D0 ;
VOID_FRAC = 0.0D0 ;
X_COORD = 0.0D0 ;
Y_COORD = 0.0D0 ;
Z_COORD = 0.0D0 ;
#
$NODES
#
   H2 = 'Inlet/Outlet ',  A = 0.0D0, FD = %DIAM% , FL = 0.0D0 ,
                          P = %PRESS% , FF = %RUG%, VQ = 0.0D0, FST = 'P&VQ',
                          FX = %X_COORD%, FY = %Y_COORD%, FZ = %Z_COORD% ;
#
   F1 = 'Working volume ',  A = 0.0D0, FD = %DIAM% , FL = %LENGTH% ,
                            P = %PRESS% , FF = %RUG%,
                            FQ = Q_int, VQ = 0.0D0, FST = 'P&VQ',
                            FX = %X_COORD%, FY = %Y_COORD%, FZ = %Z_COORD% ;
#
   D1001 = 'Casing ', T = U, C = %C_WALL%, QI = Q_ext ;
#
$CONDUCTORS
#
M(1, 2) = %MFLOW% ;
GL(1, 1001) = %G_WF% ; 
#
$CONSTANTS
#
$REAL
#
Q_ext = %Q_EXT% ;              # Direct heat flux into casing
Q_int = %Q_INT% ;              # Direct heat flux into fluid
Void_frac = %VOID_FRAC% ;      # Void Fraction for the reservoir
#
$INITIAL
#
# ==============================================================================
#
# LOCAL:
#   RHOL         DOUBLE PRECISION   Liquid density
#   RHOV         DOUBLE PRECISION   Vapour density
#
# ==============================================================================
#
       DOUBLE PRECISION RHOL, RHOV
#
# ==============================================================================
#
       RHOL = PROPS2(FT1, 'RHO', P1, 0.0D0, 'P&VQ')
       RHOV = PROPS2(FT1, 'RHO', P1, 1.0D0, 'P&VQ')
#
       IF (Void_frac .EQ. 0.0D0) THEN
          VQ1 = 0.0D0
       ELSE IF (Void_frac .EQ. 1.0D0) THEN
          VQ1 = 1.0D0
       ELSE
          VQ1 = 1.0D0 / (1.0D0 + (1.0D0 / Void_frac - 1.0D0) * (RHOL / RHOV))
       END IF
#
# GENMOR is called to initialise fluid state variables
#
       GENMOR
#
# set the wall temperature as the fluid temperature
#
       T1001 = T1
#
# set the phase separation for the forward direction
#
       CALL PHSDST('M(1, 2)', 'FWD')
#
# set the phase separation vapour quality as pure liquid for the forward
# direction
#
       CALL PHSXST('M(1, 2)', 'FWD', 0.0D0)
#
$VARIABLES2
#
# ==============================================================================
#
# LOCAL:
#   RHOL         DOUBLE PRECISION   Liquid density
#   RHOV         DOUBLE PRECISION   Vapour density
#
# ==============================================================================
#
       DOUBLE PRECISION RHOL, RHOV
#
# ==============================================================================
#
       RHOL = PROPS2(FT1, 'RHO', P1, 0.0D0, 'P&VQ')
       RHOV = PROPS2(FT1, 'RHO', P1, 1.0D0, 'P&VQ')
#
       IF (VQ1 .EQ. 0.0D0) THEN
          Void_frac = 0.0D0
       ELSE IF (VQ1 .EQ. 1.0D0) THEN
          Void_frac = 1.0D0
       ELSE
          Void_frac = 1.0D0 / (1.0D0 + (1.0D0 / VQ1 - 1.0D0) * (RHOV / RHOL))
       END IF
#
$ENDMODEL RESERVOIR_2PH
#
#
############################################
############################################
#
#
$MODEL TUBE
#
# PURPOSE:     This element simulates a fluid tube work.
# DESCRIPTION: The fluid network is represented by fluid nodes, connected by
#              mass flow links. The wall is modelled by thermal nodes. Each
#              fluid node is connected with thermal nodes using GL conductors.
#              These GL are calculated using internal functions of FHTS or can
#              be define by the user.
#              
# ORIGIN:      ESATAN/FHTS: CPL Project/W019-CO2: ALSTOM Power/00:08:31/HB
#
# ==============================================================================
#
# SUBSTITUTIONS DATA:
#   AX_COND  - REAL      (OPT)   Axial conductance of wall
#   C_WALL   - REAL      (OPT)   Wall capacitance
#   DIAM     - REAL              Hydraulic diameter of the tube 
#   ETA_TUBE - REAL      (OPT)   Overall flow resistance of the tube
#   FLA      - REAL      (OPT)   Flow area 
#   HTC_METH - CHARACTER (OPT)   Calculation method for the heat transfer
#                                coefficient. '*' for internal correlations, 
#                                'USER' for user defined
#   HTC_USER - REAL      (OPT)   Heat transfer coefficient defined by the user
#   HT_AREA  - REAL      (OPT)   Total heat transfer area
#   LENGTH   - REAL              Length of the tube 
#   MFLOW    - REAL      (OPT)   Initial mass flow rate
#   NMESH    - INTEGER   (OPT)   Number of nodes in the tube (including
#                                the inlet and outlet, min 3)
#   N_END    - INTEGER   (OPT)   Numbering for the outlet (default to NMESH) 
#   PRESS    - REAL              Initial fluid pressure
#   Q_LOAD   - REAL      (OPT)   Heat load on the wall
#   RUG      - REAL      (OPT)   Surface roughness
#   TEMP     - REAL              Initial fluid temperature
#   T_WALL   - REAL      (OPT)   Initial wall temperature
#   X_END    - REAL      (OPT)   End X-coordinate
#   X_START  - REAL      (OPT)   Start X-coordinate
#   Y_END    - REAL      (OPT)   End Y-coordinate
#   Y_START  - REAL      (OPT)   Start Y-coordinate
#   Z_END    - REAL      (OPT)   End Z-coordinate
#   Z_START  - REAL      (OPT)   Start Z-coordinate
#
# ==============================================================================
#
$DEFAULTS
#
AX_COND = 0.0D0 ;
C_WALL = 0.0D0 ;
ETA_TUBE = 0.0D0 ;
HTC_METH = 'USER' ;    # Zero heat transfer coefficient - adiabatic tube
HTC_USER = 0.0D0 ;     # 
MFLOW = 0.0D0 ;
NMESH = 3 ; 
Q_LOAD = 0.0D0 ;
RUG = 0.0D0 ;
T_WALL = %TEMP% ;
X_START = 0.0D0 ;
Y_START = 0.0D0 ;
Z_START = 0.0D0 ;
X_END = %LENGTH% ;
Y_END = 0.0D0 ;
Z_END = 0.0D0 ;
#
FLA =  pi * %DIAM% * %DIAM% / 4.0D0 ;
HT_AREA = pi * %DIAM% * %LENGTH% ;
N_END = nmesh ;
#
$LOCALS
#
$REAL
#
pi = 3.1415927D0 ;
#
$INTEGER
#
nmesh = %NMESH% ;
#
$NODES
#
# Inlet fluid node 
#
   F1 = 'Fluid (Inlet)', A = %HT_AREA% / %NMESH%.0, FD = %DIAM%,
                        FLA = %FLA%, T = %TEMP%, P = %PRESS%,
                        FF = %RUG%, FL = %LENGTH% / %NMESH%.0D0 ;
#
# Inlet thermal node 
#
   D1001 = 'Wall (Inlet) ', T = %T_WALL%, C = %C_WALL% / %NMESH%.0D0,
                            QI = Q_load / %NMESH%.0D0 ;
#
# Pipe nodes properties set up (excluding inlet and oulet nodes)
#
FOR KL1 = 2 TO %NMESH% - 1  DO
   FKL1 = 'Fluid ' , A = %HT_AREA% / %NMESH%.0D0, FD = %DIAM% ,
                          FL = %LENGTH% / %NMESH%.0D0 , FLA = %FLA% , 
                          T = %TEMP% , P = %PRESS% , FF = %RUG% ;
   KL2 = KL1 + 1000 ;
   DKL2 = 'Wall ' , T = %T_WALL% , C = %C_WALL% / %NMESH%.0D0,
                    QI = Q_load / %NMESH%.0D0 ;
END DO
#
# Outlet fluid node 
#
KL1 = %N_END% ;
   FKL1 = 'Fluid (Outlet)', A = %HT_AREA% / %NMESH%.0D0, FD = %DIAM%,
                           FLA = %FLA%, T = %TEMP%, P = %PRESS%,
                           FF = %RUG%, FL = %LENGTH% / %NMESH%.0D0 ;
#
# Outlet thermal node
#
KL1 = %N_END% + 1000 ;
   DKL1 = 'Wall (Outlet)', T = %T_WALL%, C = %C_WALL% / %NMESH%.0D0,
                           QI = Q_load / %NMESH%.0D0 ;
#
$CONDUCTORS
#
#  mass flow link set up between fluid nodes within the tube
#  (including the inlet)
#   
FOR KL1 = 1 TO (%NMESH% - 2) DO
   KL2 = KL1 + 1 ;
   M(KL1, KL2) = %MFLOW% ;
END DO
#
#  mass flow link set up between the last node in the tube and the oulet node
#   
   KL1 = %NMESH% - 1 ;
   KL2 = %N_END% ;
   M(KL1, KL2) = %MFLOW% ;
#
#  GL link set up between fluid nodes and thermal nodes
#
FOR KL1 = 1 TO %NMESH% - 1 DO
   KL2 = KL1 + 1000 ;
   GL(KL2, KL1) = * ;
END DO
#
#  GL link set up between the fluid outlet
#  and the thermal outlet
#
   KL1 = %N_END% ;
   KL2 = KL1 + 1000 ;
   GL(KL2, KL1) = * ;
#
#  GL link (axial conductance) set up between
#  thermal nodes within the tube
#
FOR KL1 = 1 TO %NMESH% - 2 DO
   KL2 = KL1 + 1000 ;
   KL3 = KL2 + 1 ;
   GL(KL2, KL3) = (%NMESH% - 1) * %AX_COND% ;
END DO
#
#  GL link (axial conductance) set up between
#  the last node in the tube and the outlet
#
   KL1 = 1000 + %NMESH% - 1 ;
   KL2 = 1000 + %N_END% ;
   GL(KL1, KL2) = (%NMESH% - 1) * %AX_COND% ; 
#
$CONSTANTS
#
$REAL
#
Htc_user = %HTC_USER% ;        # Heat transfer coefficient defined by the user
Q_load = %Q_LOAD% ;            # Heat load on the wall
#
$CHARACTER
#
Htc_meth = 'CH*4';             # Calculation method: 'USER' or '*'; initialised
                               # properly in $INITIAL
#
$INTEGER
#
N_end = %N_END% ;              # Numbering for the outlet
#
$INITIAL
#
# ==============================================================================
#
# LOCAL:
#   DLENGT      DOUBLE PRECISION   Length calculated with the coordinates
#                                  squared
#   ETA         DOUBLE PRECISION   Overall resistance of the tube
#   I           INTEGER            Loop counter
#   TOL         DOUBLE PRECISION   Tolerance for the length difference
#
# ==============================================================================
#
       INTEGER I
       DOUBLE PRECISION DLENGT, ETA, TOL
#
# ==============================================================================
#
       PARAMETER(TOL = 0.01D0)
#
# ==============================================================================
#
       Htc_meth = %HTC_METH%
#
       ETA = %ETA_TUBE%
#
       DLENGT =  SQRT((%X_END% - %X_START%)**2 + 
     &                (%Y_END% - %Y_START%)**2 +  (%Z_END% - %Z_START%)**2)
#
       IF (ABS(%LENGTH% - DLENGT) .GT. TOL * %LENGTH%) THEN
          WRITE(*, *)'@'
          WRITE(*, *)'@@@@  WARNING   : The length defined for the tube is' //
     &                                 ' not consistent with the coordinates.'
          WRITE(*, *)'@                 Please check either the length or' // 
     &                                 ' the coordinates.'
          WRITE(*, *)'@                 '
       END IF
#
       I = 1
#
       REPEAT
          FX1(I - 1) = %X_START% + (DBLE(I - 0.5D0) / DBLE(%NMESH%)) *
     &                                   (%X_END% - %X_START%)
          FY1(I - 1) = %Y_START% + (DBLE(I - 0.5D0) / DBLE(%NMESH%)) *
     &                                   (%Y_END% - %Y_START%) 
          FZ1(I - 1) = %Z_START% + (DBLE(I - 0.5D0) / DBLE(%NMESH%)) *
     &                                   (%Z_END% - %Z_START%) 
          I = I + 1
       UNTIL (I .GT. %NMESH%)
#
       IF (ETA .GT. 0.0D0) THEN
          I = 1
#
          REPEAT
             GP(1, 2)(I - 1) = (%NMESH% - 1) / ETA
             I = I + 1
          UNTIL (I .GE. %NMESH%)
#
       END IF
#   
$VARIABLES1
#
# ==============================================================================
#
# LOCAL:
#   ENAME          CHARACTER   Element name string
#   ERR            INTEGER     Error number
#   I              INTEGER     Loop counter
#   MESAGE         CHARACTER   Error message string
#   TYPE           INTEGER     Error type
#
# ==============================================================================
#
       INTEGER ERR, I, TYPE
       CHARACTER ENAME * 10, MESAGE * 150
#
# ==============================================================================
#
       IF (Htc_meth .EQ. 'USER') THEN
          I = 1
#
          REPEAT 
#
# definition of the GL between the fluid node and the corresponding
# thermal node for the NMESH - 1 first nodes
#
             GL(1001, 1)(I - 1) = Htc_user * A1(I - 1)
             I = I + 1
          UNTIL (I .GT. %NMESH% - 1)
#
# check if the user-defined N_END is not greater than the last thermal
# node number to ensure that the last link is well defined
#
          IF (N_end .GT. %NMESH% - 1 + 1000) THEN
             GL(1001, 1)(2 * %NMESH% - 2) = Htc_user * A1(%NMESH% - 1)
          ELSE
             GL(1001, 1)(%NMESH% - 1) = Htc_user * A1(%NMESH% - 1)
          END IF
#
# htflag is set to false to skip over the generated mortran for the GL
#
          HTFLAG = .FALSE.
#
       ELSE IF (Htc_meth .EQ. '*   ') THEN
#
# intrinsinc correlations will be used
#
          CONTINUE
       ELSE
          MESAGE = 'Element TUBE - Incorrect Htc_meth specified@' //
     &             'The method for the heat transfer coefficient'//
     &              ' must be either ''*'' or ''USER'''
          ENAME = 'TUBE'
          TYPE = 4
          ERR = 1
#
          CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
       END IF
#
$ENDMODEL TUBE
#
##############################################
##############################################
#
$MODEL FLEX_HOSE
#
# PURPOSE:     This element simulates a flexible hose.
# DESCRIPTION: The flexible hose is represented by fluid nodes, connected by
#              mass flow links. The hydraulic resistance formulae is given in
#              'Lessons learned from FHTS used for Columbus thermal design' 
#              by Savino DE PALO's presentation at the 12th Thermal & ECLS
#              Software Workshop in 1998. There is an option for user to set
#              his own resistance values via an user constant Eta_user. 
#              
# ORIGIN:      FHTS Upgrade 2003 APTC/04:02:03/YSU
#
# ==============================================================================
#
# SUBSTITUTIONS DATA
#   BEND_ANGLE - REAL      (OPT)  Bend angle of the hose in degree
#   DIAM       - REAL      (OPT)  Average diameter of the hose 
#   ETA_METH   - CHARACTER (OPT)  Calculation method for the overall hydraulic
#                                 resistance. '*' for calculated using 
#                                 internal function, 'USER' for user defined
#   ETA_USER   - INTEGER   (OPT)  User provided overall hydraulic resistance 
#                                 of the hose
#   FLA        - REAL      (OPT)  Flow area 
#   DIAMI      - REAL             Inner diameter of the hose 
#   LENGTH     - REAL             Length of the hose 
#   MFLOW      - REAL      (OPT)  Initial mass flow rate
#   NMESH      - INTEGER   (OPT)  Number of nodes in the hose (including
#                                 the inlet and outlet, minimum 3)
#   N_END      - INTEGER   (OPT)  Numbering for the outlet (default to NMESH) 
#   PRESS      - REAL             Initial fluid pressure
#   DIAMO      - REAL             Outer diameter of the hose
#   PITCH      - REAL             Pitch of corrugation in the hose
#   PITCH_COEF - REAL      (OPT)  Pitch coeficient
#   RUG        - REAL      (OPT)  Surface roughness
#   TEMP       - REAL             Initial fluid temperature
#
# ==============================================================================
#
$DEFAULTS
#
BEND_ANGLE = 0.0D0 ;
MFLOW = 0.0D0 ;
NMESH = 3 ; 
RUG = 0.0D0 ;
ETA_METH = '*   ' ;
ETA_USER = 0.0D0 ;
PITCH_COEF = 0.44D0 ;
DIAM = (%DIAMI% + %DIAMO%) / 2.0D0 ;
FLA = pi * %DIAM% * %DIAM% / 4.0D0 ;
N_END = nmesh ;
#
$LOCALS
#
$REAL
#
pi = 3.1415927D0 ;
diamo = %DIAMO% ;
dgtrd = 3.1415927D0 / 180.0D0;
#
$INTEGER
#
nmesh = %NMESH% ;
#
$NODES
#
# Inlet fluid node 
#
F1 = 'Fluid (Inlet)', A = 0.0D0, FD = %DIAM%, FLA = %FLA%,
                      T = %TEMP%, P = %PRESS%, FF = %RUG%, 
                      FL = %LENGTH% / %NMESH%.0D0 ;
#
# Pipe nodes properties set up (excluding inlet and oulet nodes)
#
FOR KL1 = 2 TO %NMESH% - 1  DO
   FKL1 = 'Fluid ',   A = 0.0D0, FD = %DIAM%, 
                      FL = %LENGTH% / %NMESH%.0D0, 
                      FLA = %FLA%, T = %TEMP%, 
                      P = %PRESS% , FF = %RUG% ;
END DO
#
# Outlet fluid node 
#
KL1 = %N_END% ;
FKL1 = 'Fluid (Outlet)', A = 0.0D0, FD = %DIAM%, FLA = %FLA%, 
                         T = %TEMP%, P = %PRESS%, FF = %RUG%, 
                         FL = %LENGTH% / %NMESH%.0D0 ;
$CONDUCTORS
#
#  mass flow link set up between fluid nodes within the hose
#  (including the inlet)
#   
FOR KL1 = 1 TO (%NMESH% - 2) DO
   KL2 = KL1 + 1 ;
   M(KL1, KL2) = %MFLOW% ;
END DO
#
#  mass flow link set up between the last node in the hose and the oulet node
#   
KL1 = %NMESH% - 1 ;
KL2 = %N_END% ;
M(KL1, KL2) = %MFLOW% ;
#
$CONSTANTS
#
$REAL
#
Bend_angle = %BEND_ANGLE% ; # Bend angle
Bend_radius = U ;           # Bend radius 
Eta_user = %ETA_USER% ;     # User provided ETA value
# 
$CHARACTER
#
Eta_meth = 'CH*4' ;         # Calculation method for ETA
#
$ARRAYS
#
# Array of function F versus the ratio of bend radius to inner diameter 
#
#              R/D    F
   FRDARR(2,8)=1.0, 0.37,
               1.5, 0.27,
               2.0, 0.21,
               2.5, 0.16,
               3.0, 0.12,
               3.5, 0.10,
               4.0, 0.08;
#
$SUBROUTINES
#
#  Function to calculate overall hose hydraulic resistance
#
#=======================================================================
#
      DOUBLE PRECISION FUNCTION FLXETA()
#
# PURPOSE: Calculate the overall hydraulic resistance of a flexible hose
# METHOD:  Calculate the overall hydraulic resistance of a flexible hose
#          according to the formulae presented in 'Lessons learned from 
#          FHTS used for Columbus thermal design' by Savino DE PALO at 
#          the 12th Thermal & ECLS Software Workshop in 1998.
#
#=======================================================================
#
# OUTPUT
#   FLXETA   - DOUBLE PRECISION   Overall hose flow resistance
#
#=======================================================================
#
# LOCAL
#   B        - DOUBLE PRECISION   B parameter for bending resistance
#   DIAMI    - DOUBLE PRECISION   Inner diameter of the hose
#   ENAME    - CHARACTER          Element name
#   ERR      - INTEGER            Sequential error number
#   ETANB    - DOUBLE PRECISION   Hose resistance without bending
#   ETAB     - DOUBLE PRECISION   Additional hose resistance with 
#                                 bending
#   INTRP1   - DOUBLE PRECISION   Interpolation function
#   MESAGE   - CHARACTER          Error message
#   RD       - DOUBLE PRECISION   Ratio of radius to inner diameter
#   TYPE     - INTEGER            Error classification type
#                                    1 = Diagnostic error
#                                    2 = Warning
#                                    3 = Failure
#                                    4 = Fatal
#
#=======================================================================
#
      CHARACTER ENAME * 10, MESAGE * 250 
      INTEGER ERR, TYPE
      DOUBLE PRECISION B, DIAMI, ETAB, ETANB, RD
#
#=======================================================================
#
      ENAME = ' '
      MESAGE = ' '
      ERR = 0
      TYPE = 0
      B = 0.0D0
      DIAMI = %DIAMI%
      ETAB = 0.0D0          
      ETANB = 0.0D0
      RD = 0.0D0
#
#  calculate hose resistance without bending
#
      IF (DIAMI .GT. 0.0D0) THEN
         ETANB = %LENGTH%/%PITCH% * (1.0D0 - (DIAMI / 
     &           (DIAMI + %PITCH_COEF% * %PITCH%)) ** 2) ** 2
      ELSE
         ENAME = 'FLEX_HOSE'    
         ERR = 10
         TYPE = 4
         MESAGE = 'Element FLEX_HOSE - Invalid inner diameter ' //
     &            'specified@DIAMI must be positive. ' //
     &            'Model name : ' // SUBMOD('ALL')
#
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
      END IF 
#
#  calculate additional hose bending resistance
#     
      IF (Bend_angle .GT. 0.0D0) THEN
# 
         IF (Bend_angle .LT. 90.0D0) THEN
            B = 0.5D0
#
         ELSE IF (Bend_angle .GE. 90.0D0) THEN
            B = 1.0D0
         END IF
#    
         Bend_radius = %LENGTH% / (Bend_angle * dgtrd)
         RD = Bend_radius / DIAMI              
         ETAB = INTRP1(RD, FRDARR, 1) * (Bend_angle / 90.0D0) ** B  
#
      ELSE IF (Bend_angle .EQ. 0.0D0) THEN
         ETAB = 0.0D0
         Bend_radius = 1.0D+10
      ELSE
         ENAME = 'FLEX_HOSE'
         ERR = 11
         TYPE = 4
         MESAGE = 'Element FLEX_HOSE - Invalid bend angle specified@'//
     &         'BEND_ANGLE must be positive. Model name : ' //
     &         SUBMOD('ALL')
#
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
      END IF
#
      FLXETA = ETANB + ETAB
#
#=======================================================================
#
      RETURN
#
#=======================================================================
#
      END
#
#=======================================================================
$INITIAL
#
       Eta_meth = %ETA_METH%
#
       IF (Bend_angle .EQ. 0.0) THEN
          Bend_radius = 1.0D+10
       ELSE
          Bend_radius = %LENGTH% / (Bend_angle * dgtrd)
       END IF
#
$VARIABLES1
#
#=======================================================================
#
# LOCAL
#   ENAME          CHARACTER          Element name string
#   ERR            INTEGER            Error number
#   ETA            DOUBLE PRECISION   Overall resistance of the hose
#   I              INTEGER            Loop counter
#   MESAGE         CHARACTER          Error message string
#   TYPE           INTEGER            Error type
#
#=======================================================================
#
       INTEGER ERR, I, TYPE
       DOUBLE PRECISION ETA, FLXETA
       CHARACTER ENAME * 10, MESAGE * 250
#
#=======================================================================
#
      IF (Eta_meth .EQ. 'USER') THEN
#
#  ETA is provided by user 
#
         ETA = Eta_user
#
         IF (ETA .LT. 0.0D0) THEN                    
            MESAGE = 'Element FLEX_HOSE - Invalid hydraulic '//
     &             'resistance specified@'//
     &             'ETA_USER must be positive '//
     &             'if ETA_METH is set to ''USER''. '//
     &             'Model name : ' // SUBMOD('ALL')
            ENAME = 'FLEX_HOSE'
            TYPE = 4
            ERR = 1
#
            CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#       
         END IF
#          
      ELSE IF (Eta_meth .EQ. '*   ') THEN
#
#  ETA is calculated using internal function FLXETA
#
         ETA = FLXETA()
#
         IF (ETA .LT. 0.0D0) THEN                    
            MESAGE = 'Element FLEX_HOSE - Invalid hydraulic '//
     &               'resistance calculated@'// 
     &               'The overall hydraulic resistance ' //
     &               'calculated is negative. Please check '//
     &               'either LENGTH or PITCH value. '//
     &               'Model name : ' // SUBMOD('ALL')
            ENAME = 'FLEX_HOSE'
            TYPE = 4
            ERR = 2
#
            CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#       
         END IF
#
      ELSE
         MESAGE = 'Element FLEX_HOSE - Invalid ETA_METH specified@'//
     &            'The calculation method for the overall hydraulic '//
     &            'resistance must be either ''*'' or ''USER''. '//
     &            'Model name : ' // SUBMOD('ALL')
         ENAME = 'FLEX_HOSE'
         TYPE = 4
         ERR = 3
#
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
      END IF
#
      I = 1
#
      IF (ETA .GT. 0.0D0) THEN
#
         REPEAT
            GP(1, 2)(I - 1) = (%NMESH% - 1) / ETA
            I = I + 1
         UNTIL (I .GE. %NMESH%)
#
      ELSE
#
         REPEAT
            GP(1, 2)(I - 1) = 1.0D10
            I = I + 1
         UNTIL (I .GE. %NMESH%)
#
      ENDIF
#
#=======================================================================
#
$ENDMODEL FLEX_HOSE
#
##############################################
##############################################
#
$MODEL PELTIER
#
# PURPOSE:     Simulates a Peltier element or thermoelectric cooler
# DESCRIPTION: The element is represented by two diffusive nodes D10 and
#              D20, hot and cold respectively. When positive DC current
#              Ipelt is applied, heat will be absorbed at node 20 and
#              rejected at node 10. Performance of the Peltier element is
#              controlled via the current (intensity).
#
# RESTRICTION: -
#
# CONNECTION POINTS: D10    -    face sink, usually the hot face
#                    D20    -    face source, usually the cold face
#
# ORIGIN:      ESATAN/FHTS: FHTS WP3: ALSTOM Power/30 Sept 2003/BC
#
# ======================================================================
#
# SUBSTITUTIONS DATA:
#  GAS_GL        - REAL (OPT)              Effective conductance of gas filling
#                                          the space between the two plates
#  C_SOURCE      - REAL (OPT)              Thermal capacity for cold-side node
#  C_SINK        - REAL (OPT)              Thermal capacity for hot-side node
#  MATERIAL_TYPE - INT  (OPT)              Set of thermoelectric material
#                                          properties:
#                                            1 - Z=2.67x10^-3
#                                            2 - Z=2.46x10^-3 [def]
#                                          (Z = coefficient of merit)
#  TEMP          - REAL                    Initial temperature of nodes
#
#  METH          - CHAR (OPT)              Method for obtaining number of
#                                          couples and geometric factor:
#                                            'POWER'   - use equation of power
#                                            'VOLTAGE' - use equation of voltage
#                                            ' '       - given by user [def]
#
#  GEOM_FACTOR   - REAL (METH = ' ')       Geometric factor of bars:
#                                            cross-section area / height (cm)
#  N_COUPLES     - INT  (METH = ' ')       Number of couples (pairs of bars)
#                                          between hot & cold sides
#  DATA_TEMP     - REAL (METH != ' ')      Nominal hot-side temperature
#  MAX_DELTAT    - REAL (METH != ' ')      Max temperature difference between
#                                          hot & cold sides (no heat load)
#  MAX_INTENSITY - REAL (METH != ' ')      Current corresponding to MAX_DELTAT
#  MAX_VOLTAGE   - REAL (METH = 'VOLTAGE') Voltage corresponding to MAX_DELTAT
#  MAX_POWER     - REAL (METH = 'POWER')   Max heat load supported by the
#                                          element (no temperature difference)
#
# ======================================================================
#
$DEFAULTS
#
GAS_GL = 0.0D0 ;
C_SOURCE = 0.0D0 ;
C_SINK = 0.0D0 ;
MATERIAL_TYPE = 2 ;
MAX_INTENSITY = 0.0D0 ;
METH =  ' ';
#
DATA_TEMP = 0.0D0 ;
MAX_DELTAT = 0.0D0 ;
MAX_VOLTAGE = 0.0D0 ;
MAX_POWER = 0.0D0 ;
#
N_COUPLES = 0 ;
GEOM_FACTOR = 0.0D0 ;
#
$NODES
#
D10 = 'Sink Face', C = (%C_SINK%), T = (%TEMP%) ;
D20 = 'Source Face', C = (%C_SOURCE%), T = (%TEMP%) ;
#
$CONDUCTORS
#
GL(10, 20) = U;      # Will be defined in $VARIABLES1
#
$CONSTANTS
#
$REAL
#
Geom_factor = 0.0D0 ;   # Geometric factor (bar section/bar height) (cm)
Ipelt = 0.0D0 ;         # Current intensity
Ka0 = 0.0D0 ;           # \
Ka1 = 0.0D0 ;           #  > Thermal conductivity polynomial coefficients
Ka2 = 0.0D0 ;           # /
Cop = 0.0D0 ;           # Peltier coefficient of performance
Presi = 0.0D0 ;         # Electrical power due to resistance
Pseeb = 0.0D0 ;         # Electrical power due to Seebeck effect
Ptot = 0.0D0 ;          # Total electrical power applied
Q_source = 0.0D0 ;      # Total heat on source (cold) face
Q_sink = 0.0D0 ;        # Total heat on sink (hot) face
Ro0 = 0.0D0 ;           # \
Ro1 = 0.0D0 ;           #  > Electrical resistivity polynomial coefficients
Ro2 = 0.0D0 ;           # /
Resi = 0.0D0 ;          # Overall electrical resistance
S0 = 0.0D0 ;            # \
S1 = 0.0D0 ;            #  > Seebeck polynomial coefficients
S2 = 0.0D0 ;            # /
Seebeck = 0.0D0 ;       # Overall Seebeck coefficient
Small = 1.E-10 ;        # Very small value
T_c = 293.15D0 ;        # Temperature of cold side (K)
T_h = 293.15D0 ;        # Temperature of hot side (K)
T_avr = 293.15D0 ;      # Average of hot- & cold-side temperatures (K)
Thermal_source = 0.0D0; # Thermal load on the source (cold) face
Thermal_sink = 0.0D0 ;  # Thermal load on the sink (hot) face
Vresi = 0.0D0 ;         # Voltage due to resistance
Vseeb = 0.0D0 ;         # Voltage due to Seebeck effect
Vtot = 0.0D0 ;          # Total voltage
#
$INTEGER
N_couples = 0 ;         # [-]  Number of pairs of bars
#
$SUBROUTINES
#
       SUBROUTINE COMPEL
#
# ======================================================================
#
# PURPOSE:       Computation of values needed for Peltier operation:
#                thermal coupling, voltages, powers and heat sources.
#
# ======================================================================
#
# compute average temperature in Kelvin
#
      T_c   = T20 + TABS
      T_h   = T10 + TABS
      T_avr = 0.5 * (T_c + T_h)
#
# update thermal coupling between plates
#
      GL(10, 20) = (%GAS_GL%) +
     &             2 * N_couples * Geom_factor *
     &             (Ka0 + Ka1 * T_avr + Ka2 * T_avr ** 2)
#
# compute overall resistance and Seebeck coefficient
#
      Resi = 2 * N_couples * (Ro0 + Ro1 * T_avr + Ro2 * T_avr * T_avr) /
     &       Geom_factor
      Seebeck = 2 * N_couples * (S0 + S1 * T_avr + S2 * T_avr * T_avr)
#
# compute voltages
#
      Vresi = Resi * Ipelt
      Vseeb = Seebeck * (T_h - T_c)
      Vtot = Vresi + Vseeb
#
# compute electrical powers
#
      Presi = Ipelt * Vresi
      Pseeb = Ipelt * Vseeb
      Ptot = Presi + Pseeb
#
# hot- and cold-side heat fluxes
#
      QI 10 = 0.5 * Presi + Thermal_sink
      QR 10 = Seebeck * T_h * Ipelt
#
      QI 20 = 0.5 * Presi + Thermal_source
      QR 20 = -Seebeck * T_c * Ipelt
#
# Compute the total heat on hot & cold sides
#
      Q_sink = GL(10, 20) * (T20 - T10) + QI10 + QR10 - Thermal_sink
      Q_source = GL(10, 20) * (T20 - T10) - QI20 - QR20 + Thermal_source
#
      RETURN
#
      END
#
# ======================================================================
#
      SUBROUTINE PERFCO
#
# ======================================================================
#
# PURPOSE:       Compute the Coefficient of Performance based on the
#                thermal balance on the source face.
#
# ======================================================================
#
# Compute the coefficient of performance
#
      IF (ABS(Ptot) .GT. Small) THEN
         Cop = Q_source / Ptot
      ELSE
         Cop = 1.0D10
      END IF
#
      RETURN
#
      END
#
# ======================================================================
#
      SUBROUTINE EQUIV_GEOM
#
# ======================================================================
#
# PURPOSE:       Compute the equivalent geometric parameters of the
#                Peltier device according to its performance values
#
# ======================================================================
#
      DOUBLE PRECISION RO, S, TM, TCOLD, THOT
      CHARACTER ENAME * 7, MESAGE * 3000, SUBM * 2500
      INTEGER ERR, TYPE
#
# ======================================================================
#
      ENAME = 'PELTIER'
      SUBM = SUBMOD('ALL')
#
      THOT  = (%DATA_TEMP%) + TABS
      TCOLD = THOT - (%MAX_DELTAT%)
      TM = 0.5D0 * (THOT + TCOLD)
#
      RO = Ro0 + Ro1 * TM + Ro2 * TM ** 2
      S = S0 + S1 * TM + S2 * TM ** 2
#
      IF (%MAX_INTENSITY% .LE. Small) THEN
#
# Fatal error
#
         MESAGE =
     &      'Optimal current invalid@' //
     &      'Calculating Peltier equivalent geometry@' //
     &      'Substitution data MAX_INTENSITY must be strictly positive@' //
     &      'PELTIER element -<NL>' //
     &      'submodel ' // SUBM(: STRLNA(SUBM))
         TYPE = 4
         ERR = 1
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
      ENDIF
#
# Compute the geometric factor
#
       Geom_factor = %MAX_INTENSITY% * RO / (TCOLD * S)
#
      IF (Geom_factor .LE. Small) THEN
#
# Fatal error
#
         MESAGE =
     &      'Geometric factor invalid@' //
     &      'Calculating Peltier equivalent geometry@' //
     &      'Geom_factor must be strictly positive. Substitution data ' //
     &         'DATA_TEMP and MAX_DELTAT may be inconsistent@'
     &      'PELTIER element -<NL>' //
     &      'submodel ' // SUBM(: STRLNA(SUBM))
         TYPE = 4
         ERR = 2
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
      ENDIF
#
# Compute the number of couples
#
      IF (%METH% .EQ. 'VOLTAGE') THEN
#
         N_couples = INT(0.5D0 * (%MAX_VOLTAGE%) / (S * THOT)
     &                   + 0.5D0)
#
      ELSE IF (%METH% .EQ. 'POWER') THEN
#
         N_couples = INT(0.5D0 * (%MAX_POWER%) /
     &                   (S * (%MAX_INTENSITY%) * (THOT - 0.5D0 * TCOLD ))
     &                   + 0.5D0)
#
      END IF
#
      RETURN
#
      END
#
# ======================================================================
#
$INITIAL
#
# ======================================================================
#
# LOCAL:
#   ENAME          CHARACTER          Element name string
#   ERR            INTEGER            Error number
#   MESAGE         CHARACTER          Error message string
#   TYPE           INTEGER            Error type
#
# ======================================================================
#
      CHARACTER ENAME * 7, MESAGE * 3000, SUBM * 2499
      INTEGER ERR, TYPE
#
# ======================================================================
#
      ENAME = 'PELTIER'
      SUBM = SUBMOD('ALL')
      ERR = 0
#
# Define the material properties:
#   Thermal conductivity (W/cm.K)    -  Ka0 + Ka1 * T + Ka2 * T^2
#   Electrical resistivity (ohm.cm)  -  Ro0 + Ro1 * T + Ro2 * T^2
#   Seebeck coefficient (V/K)        -  S0 + S1 * T + S2 * T^2
#
      SELECT CASE (%MATERIAL_TYPE%)
#
      CASE (1)
         Ka0 = 5.8077D-02
         Ka1 = -2.5921D-04
         Ka2 = 3.8553D-07
#
         Ro0 = 4.8450D-05
         Ro1 = 1.5489D-06
         Ro2 = 5.9514D-09
#
         S0 = 2.1449D-05
         S1 = 8.9817D-07
         S2 = -9.5593D-10
#
      CASE (2)
         Ka0 = 6.2605D-02
         Ka1 = -2.7770D-04
         Ka2 = 4.1310D-07
#
         Ro0 = 5.112D-05
         Ro1 = 1.634D-06
         Ro2 = 6.279D-09
#
         S0 = 2.2224D-05
         S1 = 9.3060D-07
         S2 = -9.9050D-10
#
      CASE ELSE
#
# Fatal error
#
         MESAGE =
     &      'Material type invalid@' //
     &      'Initialising Peltier element@' //
     &      'Substitution data MATERIAL_TYPE should be ' //
     &      'one of the following:<NL>' //
     &      '  1 - Optimistic properties<NL>' //
     &      '      (Coeff. of merit Z = 2.67x10^-3)<NL>' //
     &      '  2 - Typical properties<NL>' //
     &      '      (Coeff. of merit Z = 2.46x10^-3)@' //
     &      'PELTIER element -<NL>' //
     &      'submodel ' // SUBM(: STRLNA(SUBM))
         TYPE = 4
         ERR = 3
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
      END SELECT
#
# Check consistency of arguments vs method then call if required
# the subroutine computing Peltier equivalent geometry
#
      IF (%METH% .EQ. 'VOLTAGE') THEN
#
         IF (%MAX_VOLTAGE% .LE. 0.0D0) THEN
#
# Fatal error
#
            MESAGE =
     &         'Optimal voltage invalid@' //
     &         'Initialising Peltier element@' //
     &         'Substitution data MAX_VOLTAGE must be positive@'//
     &         'PELTIER element -<NL>' //
     &         'submodel ' // SUBM(: STRLNA(SUBM))
            TYPE = 4
            ERR = 4
            CALL SETERX(MESAGE, TYPE, ERR, ENAME)
         ELSE
            CALL EQUIV_GEOM
         END IF
#
      ELSE IF (%METH% .EQ. 'POWER') THEN
#
         IF (%MAX_POWER% .LE. 0.0D0) THEN
#
# Fatal error
#
            MESAGE =
     &         'Maximum heat load invalid@' //
     &         'Initialising Peltier element@' //
     &         'Substitution data MAX_POWER must be positive@'//
     &         'PELTIER element -<NL>' //
     &         'submodel ' // SUBM(: STRLNA(SUBM))
            TYPE = 4
            ERR = 5
            CALL SETERX(MESAGE, TYPE, ERR, ENAME)
         ELSE
            CALL EQUIV_GEOM
         END IF
#
      ELSE IF (%METH% .EQ. ' ') THEN
#
         IF (%N_COUPLES% .LE. 0) THEN
#
# Fatal error
#
            MESAGE =
     &         'Number of couples invalid@' //
     &         'Initialising Peltier element@' //
     &         'Substitution data N_COUPLES must be positive@'//
     &         'PELTIER element -<NL>' //
     &         'submodel ' // SUBM(: STRLNA(SUBM))
            TYPE = 4
            ERR = 6
            CALL SETERX(MESAGE, TYPE, ERR, ENAME)
         END IF
#
         IF (%GEOM_FACTOR% .LE. Small) THEN
#
# Fatal error
#
            MESAGE =
     &         'Geometric factor invalid@' //
     &         'Initialising Peltier element@' //
     &         'Substitution data GEOM_FACTOR must be positive@'//
     &         'PELTIER element -<NL>' //
     &         'submodel ' // SUBM(: STRLNA(SUBM))
            TYPE = 4
            ERR = 7
            CALL SETERX(MESAGE, TYPE, ERR, ENAME)
         END IF
#
         Geom_factor = %GEOM_FACTOR%
         N_couples = %N_COUPLES%
#
      ELSE
#
# Fatal error
#
         MESAGE =
     &      'Equivalent-geometry calculation method invalid@' //
     &      'Initialising Peltier element@' //
     &      'Substitution data METH must be one of the following:<NL>'//
     &      '  ''POWER''   - use equation of power<NL>' //
     &      '  ''VOLTAGE'' - use equation of voltage<NL>' //
     &      '  '' ''       - N_COUPLES & GEOM_FACTOR given<NL>' //
     &      '              by user@' //
     &      'PELTIER element -<NL>' //
     &      'submodel ' // SUBM(: STRLNA(SUBM))
         TYPE = 4
         ERR = 8
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
#
      END IF
#
# call the subroutine for main calculations
#
      CALL COMPEL
#
$VARIABLES1
#
# call the subroutine for main calculations
#
      CALL COMPEL
#
$VARIABLES2
#
# call the subroutine for coefficient of performance
#
      CALL PERFCO
#
$ENDMODEL PELTIER
#
##############################################
##############################################
#
$MODEL PID
#
# PURPOSE:     This element simulates a PID controller.
# DESCRIPTION: The element can regulate as a P, PI or PID controller.
#              It does not contain nodes.
#              If the element is used in steady-state, then the iteration
#              count is used as pseudo-time
#
# RESTRICTION: -
#
# CONNECTION POINTS: -
#
# ORIGIN:      ESATAN/FHTS: FHTS WP3: ALSTOM Power/02 Oct 2003/BC
#
# ======================================================================
#
# SUBSTITUTIONS DATA:
#   D_GAIN         - REAL      (OPT)     Derivative Gain
#   I_GAIN         - REAL      (OPT)     Integral Gain
#   P_GAIN         - REAL      (OPT)     Proportional Gain
#
# ======================================================================
#
$DEFAULTS
#
D_GAIN = 0.0D0 ;
I_GAIN = 0.0D0 ;
P_GAIN = 0.0D0 ;
#
$CONSTANTS
#
$REAL
#
Ctrl_avr = 0.0D0 ;              # Average Control
Ctrld = 0.0D0 ;                 # Derivative Control
Ctrli = 0.0D0 ;                 # Integral Control
Ctrlp = 0.0D0 ;                 # Proportional Control
Ctrl_tot = 0.0D0 ;              # Total PID Control
Ctrl_inc = 0.0D0 ;              # Incremental PID Control
Ctrl_max = 1.0D10 ;             # Upper limit the control can reach
Ctrl_min = 0.0D0 ;              # Lower limit the control can reach
Delta = 0.0D0 ;                 # Difference between Setpoint and Measure
Delta_min = 0.0D0 ;             # Min value for the control to operate
Delta_old = 0.0D0 ;             # Previous delta
Gaind = %D_GAIN% ;              # Derivative Gain
Gaini = %I_GAIN% ;              # Integral Gain
Gainp = %P_GAIN% ;              # Proportional Gain
Measure = 0.0D0 ;               # Measure of the control variable
Setpoint = 0.0D0 ;              # Set point value to reach
Timtot = 0.0D0 ;                # Total time (iteration) gone
#
$CHARACTER
#
Onoff = 'ON ' ;                 # Controller On or Off
Reseti = 'NO ' ;                # Reset integral control to 0: YES or NO
Ctrl_state = 'ACTIVE     ' ;    # Controler state (ACTIVE, OFF, NEUTRAL,
#                               # MINIMUM, OVERLOAD, I_OVERLOAD)
Ctrl_neg = 'OFF'  ;             # Flag to allow negative response
#                                 'ON'  = negative response allowed
#                                 'OFF' = positive response only (default)
#
$SUBROUTINES
#
      SUBROUTINE PIDC(Delta_time)
#
# INPUT
#   Delta_time   - DOUBLE PRECISION time step (or iteration)
# LOCALS
#   CTROLD       - DOUBLE PRECISION Previous total PID control
#   ENAME        - CHARACTER Element name
#   ERR          - INTEGER Error number
#   MESAGE       - CHARACTER Error message
#   INVALID_NEG  - LOGICAL Flag for invalid negative response
#   TYPE         - INTEGER Error type
#
      CHARACTER ENAME * 14, MESAGE * 150
      INTEGER ERR, TYPE
      DOUBLE PRECISION CTROLD, Delta_time
      LOGICAL INVALID_NEG
#
# Initialisation of some values
#
      CTROLD = Ctrl_tot
      INVALID_NEG = .FALSE.
#
# Set minimum Control to be positive
#
      IF (Ctrl_min .LT. 0.0D0) THEN
         MESAGE = 'Incorrect control value.@' //
     &            'Processing PID element.@' //
     &            'Ctrl_min cannot be negative.@' //
     &            'Model name : ' // SUBMOD('ALL')
         ENAME = 'PID'
         TYPE = 4
         ERR = 1
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
      ENDIF
#
# Check Ctrl_min & Ctrl_max
#
      IF (Ctrl_min .GE. Ctrl_max) THEN
         MESAGE = 'Incorrect control value.@' //
     &            'Processing PID element.@' //
     &            'Ctrl_max must be strictly greater than Ctrl_min.@' //
     &            'Model name : ' // SUBMOD('ALL')
         ENAME = 'PID'
         TYPE = 4
         ERR = 2
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
      ENDIF
#
# Check Ctrl_neg
#
      IF (Ctrl_neg .NE. 'OFF' .AND. Ctrl_neg .NE. 'ON') THEN
         MESAGE = 'Incorrect control value.@' //
     &         'Processing PID element.@' //
     &         'Ctrl_neg must be either ''ON'' or ''OFF''.@' //
     &         'Model name : ' // SUBMOD('ALL')
         ENAME = 'PID'
         TYPE = 4
         ERR = 3
         CALL SETERX(MESAGE, TYPE, ERR, ENAME)
      ENDIF
#
# Only work if controller's ON
#
      IF (Onoff .EQ. 'OFF') THEN
         Ctrl_state = 'OFF'
         Ctrl_tot = 0.
         Ctrld = 0.
         Ctrli = 0.
         Ctrlp = 0.
      ELSE
         Ctrl_state = 'ACTIVE'
         Delta = Setpoint - Measure
#
# ON and Neutral Zones of work
#
         IF (ABS(Delta) .GE. ABS(Delta_min)) THEN
            Ctrlp = Gainp * Delta
            Ctrli = Ctrli + Gaini * (Delta * Delta_time)
#
# Check for small time steps
#    If Delta_time less than 1.0D-10, Ctrld is left unchanged on the
#    assumption that Delta will hardly have changed.
#
            IF (Delta_time .GT. 1.0D-10) THEN
               Ctrld = Gaind * (Delta - Delta_old) / Delta_time
            ENDIF
#
            Ctrl_tot = Ctrlp + Ctrli + Ctrld
#
# Check for invalid negative value and set flag
#
            IF (Ctrl_neg .NE. 'ON' .AND. Ctrl_tot .LT. 0.0D0) THEN
               INVALID_NEG = .TRUE.
            ENDIF
#
# Check Ctrl_tot and Ctrli do not exceed the Ctrl_max limit
#
            IF (ABS(Ctrl_tot) .GT. Ctrl_max) THEN
#
               IF (ABS(Ctrli) .GT. Ctrl_max) THEN
                  Ctrl_state = 'I_OVERLOAD'
                  Ctrli = SIGN(Ctrl_max, Ctrli)
               ENDIF
#
               IF (.NOT. INVALID_NEG) THEN
                  Ctrl_state = 'OVERLOAD'
                  Ctrl_tot = SIGN(Ctrl_max, Ctrl_tot)
               ENDIF
#
            ENDIF
#
# Check Total Control does exceed the Ctrl_min threshold
#
            IF (ABS(Ctrl_tot) .LT. Ctrl_min) THEN
#
               IF (.NOT. INVALID_NEG) THEN
                  Ctrl_state = 'MINIMUM'
                  Ctrl_tot = SIGN(Ctrl_min, Ctrl_tot)
               ENDIF
#
            ENDIF
#
# Check Total Control after limit/threshold tests
#
            IF (INVALID_NEG) THEN
               Ctrl_state = 'MINIMUM'
               Ctrl_tot = Ctrl_min
            ENDIF
#
         ELSE
            Ctrl_state = 'NEUTRAL'
         ENDIF
#
         IF (Reseti .EQ. 'YES') THEN
            Ctrli = 0.
            Reseti = 'NO '
         ENDIF
#
         Delta_old = Delta
      ENDIF
#
      IF (Delta_time .GT. 1.0D-10) THEN
         Ctrl_avr =  (Ctrl_avr * Timtot + Ctrl_tot * Delta_time) /
     &               (Timtot + Delta_time)
      ENDIF
#
      Timtot = Timtot + Delta_time
      Ctrl_inc = Ctrl_tot - CTROLD
#
      RETURN
      END
#
$VARIABLES1

# Main calculations only done for steady state iterations
# Iteration count is used as pseudo-time step here:
# Delta_time = LOOPCT - (LOOPCT - 1) = 1.0D0
#
      IF (SOLVER(1:4) .EQ. 'SSTH' .OR.
     &    SOLVER(1:4) .EQ. 'SSFL' .AND. SOLTYP .EQ. ' ') THEN
         CALL PIDC(1.0D0)
      ENDIF
#
$VARIABLES2
#
# Main calculations only done for transient iterations
#
      IF (SOLVER(1:4) .EQ. 'SSTH' .OR.
     &    SOLVER(1:4) .EQ. 'SSFL' .AND. SOLTYP .EQ. ' ') THEN
      ELSE
         CALL PIDC(TIMEN - TIMEO)
      ENDIF
#
$ENDMODEL PID
#
##############################################
##############################################
#
$MODEL FLUID
#
# Model of fluid only pipe work
#
$DEFAULTS
#
FXSTA = 0.0; FYSTA = 0.0; FZSTA = 0.0;   # Default coordinates
FXEND = FXSTA; FYEND = FYSTA; FZEND = FZSTA;
#
FST = 'P&T' ;                     # )
PSTA = 0.0 ; PEND = PSTA;         # )
TSTA = 0.0 ; TEND = TSTA;         # ) FLuid state - note end conditions
FESTA = 0.0 ; FEEND = FESTA;      # )     default to start conditions
VQSTA = 0.0 ; VQEND = VQSTA;      # )     not zero
#
FLA = RL2 ;      # Area of circle diameter FD
FA = RL4 ;       # Surface area of cylinder diameter FD
NNODES = 2;      # Default to 2 nodes in the pipe
#
$LOCALS
#
# Note Flow area and volume need to be defined prior to heat transfer
#    area to avoid FL being undefined if VOL and FD specified
#
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %FD% * %FD% / 4.0 ;     # Flow area
RL4 = RL1 * %FD% * %LENGTH%   ;     # Total heat transfer area
#
$INTEGER
IL1 = %NSTART% + %NNODES% - 1 ; # End node number
#
$NODES
#
# Note FX , FY , FZ , P , T , FE , VQ initialised within $INITIAL block
#
# Note A and FL are total values, hence divided by NNODES
#
FOR KL1 = %NSTART% TO IL1 DO
   FKL1, A = %FA% / %NNODES%.0, FD = %FD% , FL = %LENGTH% / %NNODES% ,
       FLA = %FLA%, FST = %FST%, T = %TSTA% , P = %PSTA%, FE = %FESTA%,
       VQ = %VQSTA%, FF = %FF%, FX = %FXSTA%, FY = %FYSTA%,
       FZ = %FZSTA%;
END DO
#
$CONDUCTORS
#
FOR KL1 = %NSTART% TO IL1 - 1 DO
   KL2 = KL1 + 1;
   M(KL1 , KL2) = %MFLOW% ;
#
END DO
#
$CONSTANTS
#
$REAL
#
PSTA = %PSTA%;
TSTA = %TSTA%;
FESTA = %FESTA%;
VQSTA = %VQSTA%;
FXSTA = %FXSTA%;
FYSTA = %FYSTA%;
FZSTA = %FZSTA%;
#
$INITIAL
      INTEGER I
      I = 0
      REPEAT
         T%NSTART%(I) = %TSTA% + DBLE(I / %NNODES%) *
     &                                   (%TEND% - %TSTA%)
         FE%NSTART%(I) = %FESTA% + DBLE(I / %NNODES%) *
     &                                   (%FEEND% - %FESTA%)
         VQ%NSTART%(I) = %VQSTA% + DBLE(I / %NNODES%) *
     &                                   (%VQEND% - %VQSTA%)
         P%NSTART%(I) = %PSTA% + DBLE(I / %NNODES%) *
     &                                   (%PEND% - %PSTA%)
         FX%NSTART%(I) = %FXSTA% + DBLE(I / %NNODES%) *
     &                                   (%FXEND% - %FXSTA%)
         FY%NSTART%(I) = %FYSTA% + DBLE(I / %NNODES%) *
     &                                   (%FYEND% - %FYSTA%)
         FZ%NSTART%(I) = %FZSTA% + DBLE(I / %NNODES%) *
     &                                   (%FZEND% - %FZSTA%)
      I = I + 1
      UNTIL(I .GE. %NNODES%)

$ENDMODEL FLUID
$MODEL FLUIDWALL
#
# Model of fluid only pipe work
#
$DEFAULTS
#
FXSTA = 0.0; FYSTA = 0.0; FZSTA = 0.0;   # Default coordinates
FXEND = FXSTA; FYEND = FYSTA; FZEND = FZSTA;
#
FST = 'P&T' ;                     # )
PSTA = 0.0 ; PEND = PSTA;         # )
TSTA = 0.0 ; TEND = TSTA;         # ) FLuid state - note end conditions
FESTA = 0.0 ; FEEND = FESTA;      # )     default to start conditions
VQSTA = 0.0 ; VQEND = VQSTA;      # )     not zero
#
FLA = RL2 ;      # Area of circle diameter FD
FA = RL4 ;        # Surface area of cylinder diameter FD
NNODES = 2 ;     # Default to two nodes in the pipe
CTOTAL = 0.0 ;   # Default to arithmetic diffusion nodes
#
$LOCALS
#
# Note Flow area and volume need to be defined prior to heat transfer
#    area to avoid FL being undefined if VOL and FD specified
#
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %FD% * %FD% / 4.0 ;    # Flow area
RL4 = RL1 * %FD% * %LENGTH%   ;    # Total heat transfer area
#
$INTEGER
IL1 = %NSTART% + %NNODES% - 1 ; # End node number
#
$NODES
#
# Note FX , FY , FZ , P , T , FE , VQ initialised within $INITIAL block
#
# Note A , FL and C are total values, hence divided by NNODES
#
FOR KL1 = %NSTART% TO IL1 DO
   FKL1, A = %FA% / %NNODES%.0, FD = %FD% , FL = %LENGTH% / %NNODES% ,
       FLA = %FLA%, FST = %FST%, T = %TSTA% , P = %PSTA%, FE = %FESTA%,
       VQ = %VQSTA%, FF = %FF%, FX = %FXSTA%, FY = %FYSTA%,
       FZ = %FZSTA%;
   KL2 = KL1 + 100;
   DKL2 , T = %TWALL% , C = %CTOTAL% / IL1;
END DO
#
$CONDUCTORS
#
FOR KL1 = %NSTART% TO IL1 - 1 DO
   KL2 = KL1 + 1;
   M(KL1 , KL2) = %MFLOW%;
END DO
#
FOR KL1 = %NSTART% TO IL1 DO
   KL2 = KL1 + 100;
   GL(KL1 , KL2) = *;
END DO
#
$CONSTANTS
#
$REAL
#
PSTA = %PSTA%;
TSTA = %TSTA%;
FESTA = %FESTA%;
VQSTA = %VQSTA%;
FXSTA = %FXSTA%;
FYSTA = %FYSTA%;
FZSTA = %FZSTA%;
#
$INITIAL
      INTEGER I
      I = 0
      REPEAT
         T%NSTART%(I) = %TSTA% + DBLE(I / %NNODES%) *
     &                                   (%TEND% - %TSTA%)
         FE%NSTART%(I) = %FESTA% + DBLE(I / %NNODES%) *
     &                                   (%FEEND% - %FESTA%)
         VQ%NSTART%(I) = %VQSTA% + DBLE(I / %NNODES%) *
     &                                   (%VQEND% - %VQSTA%)
         P%NSTART%(I) = %PSTA% + DBLE(I / %NNODES%) *
     &                                   (%PEND% - %PSTA%)
         FX%NSTART%(I) = %FXSTA% + DBLE(I / %NNODES%) *
     &                                   (%FXEND% - %FXSTA%)
         FY%NSTART%(I) = %FYSTA% + DBLE(I / %NNODES%) *
     &                                   (%FYEND% - %FYSTA%)
         FZ%NSTART%(I) = %FZSTA% + DBLE(I / %NNODES%) *
     &                                   (%FZEND% - %FZSTA%)
      I = I + 1
      UNTIL(I .GE. %NNODES%)
#
$ENDMODEL FLUIDWALL
$MODEL NODE
#
# Model of node
#
$DEFAULTS
#
FX = 0.0; FY = 0.0; FZ = 0.0;   # Default coordinates
#
FST = 'P&T' ; # )
FP = 0.0 ;    # )
TF = 0.0 ;    # ) FLuid state
FE = 0.0 ;    # )
VQ = 0.0 ;    # )
#
FLA = RL2 ;      # Area of circle diameter FD
FA = RL4 ;       # Surface area of cylinder diameter FD
NTYPE = 'F';     # Default node type
NNUM = 1 ;       # Default node number
#
FQ = 0.0;
FM = 0.0;
FH = 0.0;
FR = 0.0;
PHI = 0.0;
FW = 0.0;
CMP = 0.0;
VDT = 0.0;
#
$LOCALS
#
$REAL
RL1 = 3.1415927;
RL2 = RL1 * %FD% * %FD% / 4.0 ;     # Flow area
RL4 = RL1 * %FD% * %FL%       ;     # Total heat transfer area
#
$NODES
#
F%NNUM%, A = %FA% , FD = %FD% , FL = %FL% ,
    FLA = %FLA%, FST = %FST%, T = %TF% , P = %FP%, FE = %FE%,
    VQ = %VQ%, FF = %FF%, FX = %FX%, FY = %FY%,
    FZ = %FZ% , FQ = %FQ% , FM = %FM% , FH = %FH% , FR = %FR% ,
    PHI = %PHI% , FW = %FW% , CMP = %CMP% , VDT = %VDT% ;
#
$INITIAL
       CHARACTER * 1 NTYPE
       NTYPE = %NTYPE%
       IF(NTYPE .EQ. 'R')THEN
          CALL STATST('N%NNUM%' , 'R')
C
       ELSE IF(NTYPE .EQ. 'K')THEN
          CALL STATST('N%NNUM%' , 'K')
C
       ELSE IF(NTYPE .EQ. 'J')THEN
          CALL STATST('N%NNUM%' , 'J')
C
       ELSE
C
C Default of F assumed
C
       END IF
C
$ENDMODEL NODE
#
##############################################
##############################################
#
$MODEL CHABLQUADRILATERAL
#
#  ABLAT : charring ablation of primitive QUADRILATERAL
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = 1;           # active surface : 1 = outside
PTYPE  = 1;           # primitive type : 1 = quadrilateral
ABLTYP = 1;           # ablation type  : 1 = charring ablation
PYRM   = %PYRMOD%;    # ablation model (1:dens/temp-function, 2:Arrhenius)
N1     = %NODES1%;    # subdivision in y-direction
N2     = %NODES2%;    # subdivision in x-direction
N3     = %NODES3%;    # subdivision of ablative layer
NSUB   = %NSUB%;      # number of subnodes in one cell
GASMOD = %GASMOD%;    # gas flow model (1:fissure, 2:equilib.)
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
FEROS  = %FEROS%;     # flag for char erosion      (0:no, 1:erosion)
FOXID  = %FOXID%;     # flag for eroded char oxid. (0:no, 1:yes)
FCHSUB = %FCHSUB%;    # flag for char sublimation  (0:no, 1:yes)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
KMAX   = 0;           # node number of pyrolysis zone start
KMIN   = 0;           # node number of pyrolysis zone end
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %YMAX%;      # dimensional range in NODES1-direction
DB     = %XMAX%;      # dimensional range in NODES2-direction
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = 0.0D+00;     # dummy real value
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
EPSC   = %EPSC%;      # char IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
TCHAR  = %TCHAR%;     # ablation end temperature
TREC   = %TREC%;      # char erosion start temperature
TCSUB  = %TCSUB%;     # char sublimation temperature
BBCON  = %BBCON%;     # reaction rate for Arrhenius function
ERCON  = %ERCON%;     # activation energy/general gas const
NNCON  = %NNCON%;     # reaction order for Arrhenius function
DEVRHO = %DEVRHO%;    # density deviation
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HCSUB  = %HCSUB%;     # latent heat of char sublimation
HOXID  = %HOXID%;     # latent heat of char oxidation
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
MOXI(%NODES2%,%NODES1%) = U;          # mass flux of oxidation or sublimation
POSC(%NODES2%,%NODES1%) = U;          # position of pyrolysis start
POSV(%NODES2%,%NODES1%) = U;          # position of pyrolysis end
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
SVOT(%NODES3%,%NSUB%)   = U;          # subnodal top half volume
SVOB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half volume
SALT(%NODES3%,%NSUB%)   = U;          # subnodal top half A/l-value
SALB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half A/l-value
SRHO(%NODES3%,%NSUB%)   = U;          # density at subnodes
SCP(%NODES3%,%NSUB%)    = U;          # spec. heat at subnodes
SLAMDA(%NODES3%,%NSUB%) = U;          # conductivity at subnodes
TSUB(%NODES3%,%NSUB%)   = U;          # temperatures at subnodes
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
MGAS(%NODES3%,%NODES2%,%NODES1%)   = U; # mass flux of pyrolysis gas
MGASST(%NODES3%,%NODES2%,%NODES1%) = U; # 2nd storage for gas mass flux
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
CR(2,2) = %RHOC%;                     # char density
CL(2,2) = %LAMBDC%;                   # char conductivity
CC(2,2) = %CPC%;                      # char specific heat
CER(2,1) = %ERATE%;                   # char erosion rate
VCGAS(2,1) = %CPGAS%;                 # spec. heat of pyrolysis gas
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I , J , K, CTYPE
C
C scale dimensional ranges
C
      DG = DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array and others
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J , I) = DX * 0.5
            MOXI(J , I) = XDUM
            POSV(J , I) = XDUM
            POSC(J , I) = XDUM
            POSS(J , I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3 , J , I) = 11
            ISTATE(N3 - 1 , J , I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K , J , I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1 , J , I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE , CTYPE , K , J , I , KMAX , KMIN ,
     &                     N1 , N2 , N3 , NSUB , ASS , DG , DB , DX ,
     &                     SEMIS , XDUM , XDUM , XDUM , ISTATE , DSN ,
     &                     NVL , ALT , ALB , SVOT , SVOB , SALT , SALB)
               MGAS(K , J , I) = XDUM
               MGASST(K , J , I) = XDUM
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C compute material properties at beginn of computation
C
      IF (PYRM .EQ. 2) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL, AC, NNSM)
      END IF
C
$VARIABLES1
C
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN , PROPS:ARTIME ,
     &                                PROPS:AQ0101 + KK - 1 , 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      IF (PYRM .EQ. 1) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL , AC , NNSM)
      END IF
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3 , ABLTYP , ISTATE , AR , AL , AC , NVL , ALT ,
     &             ALB , NNSM , MGAS , HABL , VCGAS , GASMOD)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J , I , BLKEFF , HW , HR , N1 , N2 , N3 ,
     &                   MGAS , FBLOCK , FBLOW , HREF , ISTATE ,
     &                   MOXI , FOXID , FCHSUB , HOXID , HCSUB)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLSUB (ISTATE , AL , AR , AC , ALT , ALB , MGAS ,
     &                  MGASST , NVL , N1 , N2 , N3 , TSUB , TCHAR ,
     &                  TABL , VR , VL , VC , SRHO , SCP , SLAMDA ,
     &                  CR , CL , CC , NSUB , KMAX , KMIN , I , J ,
     &                  BBCON , ERCON , NNCON , DEVRHO , PYRM ,
     &                  EPSC , DSN , DX , POSV , POSC , SEMIS)
C
           CALL ABLINT (ISTATE , AR , AL , AC , SRHO , SCP , SLAMDA ,
     &                  MGAS , MGASST , SVOT , SVOB , SALT , SALB ,
     &                  DSN , XDUM , NVL , ALT , ALB , SEMIS , XDUM ,
     &                  ASS , XDUM , N1 , N2 , N3 , NSUB , DB , DG ,
     &                  DX , PTYPE , KMAX , KMIN, I , J , PYRM)
C
           IF (FEROS .EQ. 1) THEN
              CALL ABLREC (J , I , TREC , ISTATE , NVL , ALT , ALB ,
     &                     CER , DSN , N3 , N2 , N1 , DB , DG , DX ,
     &                     AL , PTYPE , ASS , SEMIS , XDUM , XDUM ,
     &                     XDUM , KMAX , AR , MOXI , TCSUB , FOXID ,
     &                     FCHSUB , POSS , CR)
           END IF
C
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL CHABLQUADRILATERAL
#
#
#
$MODEL CHABLDISC
#
#  ABLAT : charring ablation of primitive DISC
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = 1;           # active surface : 1 = outside
PTYPE  = 2;           # primitive type : 2 = disc
ABLTYP = 1;           # ablation type  : 1 = charring ablation
PYRM   = %PYRMOD%;    # ablation model (1:dens/temp-function, 2:Arrhenius)
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in radial direction
N3     = %NODES3%;    # subdivision of ablative layer
NSUB   = %NSUB%;      # number of subnodes in one cell
GASMOD = %GASMOD%;    # gas flow model (1:fissure, 2:equilib.)
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
FEROS  = %FEROS%;     # flag for char erosion      (0:no, 1:erosion)
FOXID  = %FOXID%;     # flag for eroded char oxid. (0:no, 1:yes)
FCHSUB = %FCHSUB%;    # flag for char sublimation  (0:no, 1:yes)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
KMAX   = 0;           # node number of pyrolysis zone start
KMIN   = 0;           # node number of pyrolysis zone end
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = %RMAX%;      # dimensional range in NODES2-direction
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = 0.0D+00;     # dummy real value
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
EPSC   = %EPSC%;      # char IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
TCHAR  = %TCHAR%;     # ablation end temperature
TREC   = %TREC%;      # char erosion start temperature
TCSUB  = %TCSUB%;     # char sublimation temperature
BBCON  = %BBCON%;     # reaction rate for Arrhenius function
ERCON  = %ERCON%;     # activation energy/general gas const
NNCON  = %NNCON%;     # reaction order for Arrhenius function
DEVRHO = %DEVRHO%;    # density deviation
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HCSUB  = %HCSUB%;     # latent heat of char sublimation
HOXID  = %HOXID%;     # latent heat of char oxidation
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
MOXI(%NODES2%,%NODES1%) = U;          # mass flux of oxidation or sublimation
POSC(%NODES2%,%NODES1%) = U;          # position of pyrolysis start
POSV(%NODES2%,%NODES1%) = U;          # position of pyrolysis end
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
SVOT(%NODES3%,%NSUB%)   = U;          # subnodal top half volume
SVOB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half volume
SALT(%NODES3%,%NSUB%)   = U;          # subnodal top half A/l-value
SALB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half A/l-value
SRHO(%NODES3%,%NSUB%)   = U;          # density at subnodes
SCP(%NODES3%,%NSUB%)    = U;          # spec. heat at subnodes
SLAMDA(%NODES3%,%NSUB%) = U;          # conductivity at subnodes
TSUB(%NODES3%,%NSUB%)   = U;          # temperatures at subnodes
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
MGAS(%NODES3%,%NODES2%,%NODES1%)   = U; # mass flux of pyrolysis gas
MGASST(%NODES3%,%NODES2%,%NODES1%) = U; # 2nd storage for gas mass flux
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
CR(2,2) = %RHOC%;                     # char density
CL(2,2) = %LAMBDC%;                   # char conductivity
CC(2,2) = %CPC%;                      # char specific heat
CER(2,1) = %ERATE%;                   # char erosion rate
VCGAS(2,1) = %CPGAS%;                 # spec. heat of pyrolysis gas
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I , J , K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array and others
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J , I) = DX * 0.5
            MOXI(J , I) = XDUM
            POSV(J , I) = XDUM
            POSC(J , I) = XDUM
            POSS(J , I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3 , J , I) = 11
            ISTATE(N3 - 1 , J , I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K , J , I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1 , J , I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE , CTYPE , K , J , I , KMAX , KMIN ,
     &                     N1 , N2 , N3 , NSUB , ASS , DG , DB , DX ,
     &                     SEMIS , XDUM , XDUM , XDUM , ISTATE , DSN ,
     &                     NVL , ALT , ALB , SVOT , SVOB , SALT , SALB)
               MGAS(K , J , I) = XDUM
               MGASST(K , J , I) = XDUM
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C compute material properties at beginn of computation
C
      IF (PYRM .EQ. 2) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL, AC, NNSM)
      END IF
C
$VARIABLES1
C
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN , PROPS:ARTIME ,
     &                                PROPS:AQ0101 + KK - 1 , 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      IF (PYRM .EQ. 1) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL , AC , NNSM)
      END IF
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3 , ABLTYP , ISTATE , AR , AL , AC , NVL , ALT ,
     &             ALB , NNSM , MGAS , HABL , VCGAS , GASMOD)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J , I , BLKEFF , HW , HR , N1 , N2 , N3 ,
     &                   MGAS , FBLOCK , FBLOW , HREF , ISTATE ,
     &                   MOXI , FOXID , FCHSUB , HOXID , HCSUB)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLSUB (ISTATE , AL , AR , AC , ALT , ALB , MGAS ,
     &                  MGASST , NVL , N1 , N2 , N3 , TSUB , TCHAR ,
     &                  TABL , VR , VL , VC , SRHO , SCP , SLAMDA ,
     &                  CR , CL , CC , NSUB , KMAX , KMIN , I , J ,
     &                  BBCON , ERCON , NNCON , DEVRHO , PYRM ,
     &                  EPSC , DSN , DX , POSV , POSC , SEMIS)
C
           CALL ABLINT (ISTATE , AR , AL , AC , SRHO , SCP , SLAMDA ,
     &                  MGAS , MGASST , SVOT , SVOB , SALT , SALB ,
     &                  DSN , XDUM , NVL , ALT , ALB , SEMIS , XDUM ,
     &                  ASS , XDUM , N1 , N2 , N3 , NSUB , DB , DG ,
     &                  DX , PTYPE , KMAX , KMIN, I , J , PYRM)
C
           IF (FEROS .EQ. 1) THEN
              CALL ABLREC (J , I , TREC , ISTATE , NVL , ALT , ALB ,
     &                     CER , DSN , N3 , N2 , N1 , DB , DG , DX ,
     &                     AL , PTYPE , ASS , SEMIS , XDUM , XDUM ,
     &                     XDUM , KMAX , AR , MOXI , TCSUB , FOXID ,
     &                     FCHSUB , POSS , CR)
           END IF
C
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL CHABLDISC
#
#
#
$MODEL CHABLCYLINDER
#
#  ABLAT : charring ablation of primitive CYLINDER
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = %SIDE%;      # active surface
PTYPE  = 3;           # primitive type : 3 = cylinder
ABLTYP = 1;           # ablation type  : 1 = charring ablation
PYRM   = %PYRMOD%;    # ablation model (1:dens/temp-function, 2:Arrhenius)
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in axial direction
N3     = %NODES3%;    # subdivision of ablative layer
NSUB   = %NSUB%;      # number of subnodes in one cell
GASMOD = %GASMOD%;    # gas flow model (1:fissure, 2:equilib.)
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
FEROS  = %FEROS%;     # flag for char erosion      (0:no, 1:erosion)
FOXID  = %FOXID%;     # flag for eroded char oxid. (0:no, 1:yes)
FCHSUB = %FCHSUB%;    # flag for char sublimation  (0:no, 1:yes)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
KMAX   = 0;           # node number of pyrolysis zone start
KMIN   = 0;           # node number of pyrolysis zone end
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = %HMAX%;      # dimensional range in NODES2-direction
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = %RADIUS%;    # radius of cylinder
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
EPSC   = %EPSC%;      # char IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
TCHAR  = %TCHAR%;     # ablation end temperature
TREC   = %TREC%;      # char erosion start temperature
TCSUB  = %TCSUB%;     # char sublimation temperature
BBCON  = %BBCON%;     # reaction rate for Arrhenius function
ERCON  = %ERCON%;     # activation energy/general gas const
NNCON  = %NNCON%;     # reaction order for Arrhenius function
DEVRHO = %DEVRHO%;    # density deviation
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HCSUB  = %HCSUB%;     # latent heat of char sublimation
HOXID  = %HOXID%;     # latent heat of char oxidation
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
MOXI(%NODES2%,%NODES1%) = U;          # mass flux of oxidation or sublimation
POSC(%NODES2%,%NODES1%) = U;          # position of pyrolysis start
POSV(%NODES2%,%NODES1%) = U;          # position of pyrolysis end
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
SVOT(%NODES3%,%NSUB%)   = U;          # subnodal top half volume
SVOB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half volume
SALT(%NODES3%,%NSUB%)   = U;          # subnodal top half A/l-value
SALB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half A/l-value
SRHO(%NODES3%,%NSUB%)   = U;          # density at subnodes
SCP(%NODES3%,%NSUB%)    = U;          # spec. heat at subnodes
SLAMDA(%NODES3%,%NSUB%) = U;          # conductivity at subnodes
TSUB(%NODES3%,%NSUB%)   = U;          # temperatures at subnodes
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
MGAS(%NODES3%,%NODES2%,%NODES1%)   = U; # mass flux of pyrolysis gas
MGASST(%NODES3%,%NODES2%,%NODES1%) = U; # 2nd storage for gas mass flux
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
CR(2,2) = %RHOC%;                     # char density
CL(2,2) = %LAMBDC%;                   # char conductivity
CC(2,2) = %CPC%;                      # char specific heat
CER(2,1) = %ERATE%;                   # char erosion rate
VCGAS(2,1) = %CPGAS%;                 # spec. heat of pyrolysis gas
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I , J , K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array and others
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J , I) = DX * 0.5
            MOXI(J , I) = XDUM
            POSV(J , I) = XDUM
            POSC(J , I) = XDUM
            POSS(J , I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3 , J , I) = 11
            ISTATE(N3 - 1 , J , I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K , J , I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1 , J , I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE , CTYPE , K , J , I , KMAX , KMIN ,
     &                     N1 , N2 , N3 , NSUB , ASS , DG , DB , DX ,
     &                     SEMIS , R , XDUM , XDUM , ISTATE , DSN ,
     &                     NVL , ALT , ALB , SVOT , SVOB , SALT , SALB)
               MGAS(K , J , I) = XDUM
               MGASST(K , J , I) = XDUM
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C compute material properties at beginn of computation
C
      IF (PYRM .EQ. 2) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL, AC, NNSM)
      END IF
C
$VARIABLES1
C
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN , PROPS:ARTIME ,
     &                                PROPS:AQ0101 + KK - 1 , 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      IF (PYRM .EQ. 1) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL , AC , NNSM)
      END IF
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3 , ABLTYP , ISTATE , AR , AL , AC , NVL , ALT ,
     &             ALB , NNSM , MGAS , HABL , VCGAS , GASMOD)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J , I , BLKEFF , HW , HR , N1 , N2 , N3 ,
     &                   MGAS , FBLOCK , FBLOW , HREF , ISTATE ,
     &                   MOXI , FOXID , FCHSUB , HOXID , HCSUB)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLSUB (ISTATE , AL , AR , AC , ALT , ALB , MGAS ,
     &                  MGASST , NVL , N1 , N2 , N3 , TSUB , TCHAR ,
     &                  TABL , VR , VL , VC , SRHO , SCP , SLAMDA ,
     &                  CR , CL , CC , NSUB , KMAX , KMIN , I , J ,
     &                  BBCON , ERCON , NNCON , DEVRHO , PYRM ,
     &                  EPSC , DSN , DX , POSV , POSC , SEMIS)
C
           CALL ABLINT (ISTATE , AR , AL , AC , SRHO , SCP , SLAMDA ,
     &                  MGAS , MGASST , SVOT , SVOB , SALT , SALB ,
     &                  DSN , XDUM , NVL , ALT , ALB , SEMIS , R ,
     &                  ASS , XDUM , N1 , N2 , N3 , NSUB , DB , DG ,
     &                  DX , PTYPE , KMAX , KMIN, I , J , PYRM)
C
           IF (FEROS .EQ. 1) THEN
              CALL ABLREC (J , I , TREC , ISTATE , NVL , ALT , ALB ,
     &                     CER , DSN , N3 , N2 , N1 , DB , DG , DX ,
     &                     AL , PTYPE , ASS , SEMIS , R , XDUM ,
     &                     XDUM , KMAX , AR , MOXI , TCSUB , FOXID ,
     &                     FCHSUB , POSS , CR)
           END IF
C
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL CHABLCYLINDER
#
$MODEL CHABLCONE
#
#  ABLAT : charring ablation of primitive CONE
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = %SIDE%;      # active surface
PTYPE  = 4;           # primitive type : 4 = cone
ABLTYP = 1;           # ablation type  : 1 = charring ablation
PYRM   = %PYRMOD%;    # ablation model (1:dens/temp-function, 2:Arrhenius)
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in axial direction
N3     = %NODES3%;    # subdivision of ablative layer
NSUB   = %NSUB%;      # number of subnodes in one cell
GASMOD = %GASMOD%;    # gas flow model (1:fissure, 2:equilib.)
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
FEROS  = %FEROS%;     # flag for char erosion      (0:no, 1:erosion)
FOXID  = %FOXID%;     # flag for eroded char oxid. (0:no, 1:yes)
FCHSUB = %FCHSUB%;    # flag for char sublimation  (0:no, 1:yes)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
KMAX   = 0;           # node number of pyrolysis zone start
KMIN   = 0;           # node number of pyrolysis zone end
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = 0.0D+00;     # dimensional range in NODES2-direction (set up in $init)
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = %HMIN%;      # min. base radius when multipl. with tan(alph)
ALPH   = %SEMANG%;    # half cone opening angle
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
EPSC   = %EPSC%;      # char IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
TCHAR  = %TCHAR%;     # ablation end temperature
TREC   = %TREC%;      # char erosion start temperature
TCSUB  = %TCSUB%;     # char sublimation temperature
BBCON  = %BBCON%;     # reaction rate for Arrhenius function
ERCON  = %ERCON%;     # activation energy/general gas const
NNCON  = %NNCON%;     # reaction order for Arrhenius function
DEVRHO = %DEVRHO%;    # density deviation
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HCSUB  = %HCSUB%;     # latent heat of char sublimation
HOXID  = %HOXID%;     # latent heat of char oxidation
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
MOXI(%NODES2%,%NODES1%) = U;          # mass flux of oxidation or sublimation
POSC(%NODES2%,%NODES1%) = U;          # position of pyrolysis start
POSV(%NODES2%,%NODES1%) = U;          # position of pyrolysis end
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
SVOT(%NODES3%,%NSUB%)   = U;          # subnodal top half volume
SVOB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half volume
SALT(%NODES3%,%NSUB%)   = U;          # subnodal top half A/l-value
SALB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half A/l-value
SRHO(%NODES3%,%NSUB%)   = U;          # density at subnodes
SCP(%NODES3%,%NSUB%)    = U;          # spec. heat at subnodes
SLAMDA(%NODES3%,%NSUB%) = U;          # conductivity at subnodes
TSUB(%NODES3%,%NSUB%)   = U;          # temperatures at subnodes
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
MGAS(%NODES3%,%NODES2%,%NODES1%)   = U; # mass flux of pyrolysis gas
MGASST(%NODES3%,%NODES2%,%NODES1%) = U; # 2nd storage for gas mass flux
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
CR(2,2) = %RHOC%;                     # char density
CL(2,2) = %LAMBDC%;                   # char conductivity
CC(2,2) = %CPC%;                      # char specific heat
CER(2,1) = %ERATE%;                   # char erosion rate
VCGAS(2,1) = %CPGAS%;                 # spec. heat of pyrolysis gas
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I , J , K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
      DB = %HMAX% - %HMIN%
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
      ALPH = DTR * ALPH
      R = R * TAN(ALPH)
C
C initialize surface depth array and others
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J , I) = DX * 0.5
            MOXI(J , I) = XDUM
            POSV(J , I) = XDUM
            POSC(J , I) = XDUM
            POSS(J , I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3 , J , I) = 11
            ISTATE(N3 - 1 , J , I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K , J , I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1 , J , I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE , CTYPE , K , J , I , KMAX , KMIN ,
     &                     N1 , N2 , N3 , NSUB , ASS , DG , DB , DX ,
     &                     SEMIS , R , XDUM , ALPH , ISTATE , DSN ,
     &                     NVL , ALT , ALB , SVOT , SVOB , SALT , SALB)
               MGAS(K , J , I) = XDUM
               MGASST(K , J , I) = XDUM
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C compute material properties at beginn of computation
C
      IF (PYRM .EQ. 2) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL, AC, NNSM)
      END IF
C
$VARIABLES1
C
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN , PROPS:ARTIME ,
     &                                PROPS:AQ0101 + KK - 1 , 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      IF (PYRM .EQ. 1) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL , AC , NNSM)
      END IF
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3 , ABLTYP , ISTATE , AR , AL , AC , NVL , ALT ,
     &             ALB , NNSM , MGAS , HABL , VCGAS , GASMOD)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J , I , BLKEFF , HW , HR , N1 , N2 , N3 ,
     &                   MGAS , FBLOCK , FBLOW , HREF , ISTATE ,
     &                   MOXI , FOXID , FCHSUB , HOXID , HCSUB)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLSUB (ISTATE , AL , AR , AC , ALT , ALB , MGAS ,
     &                  MGASST , NVL , N1 , N2 , N3 , TSUB , TCHAR ,
     &                  TABL , VR , VL , VC , SRHO , SCP , SLAMDA ,
     &                  CR , CL , CC , NSUB , KMAX , KMIN , I , J ,
     &                  BBCON , ERCON , NNCON , DEVRHO , PYRM ,
     &                  EPSC , DSN , DX , POSV , POSC , SEMIS)
C
           CALL ABLINT (ISTATE , AR , AL , AC , SRHO , SCP , SLAMDA ,
     &                  MGAS , MGASST , SVOT , SVOB , SALT , SALB ,
     &                  DSN , ALPH , NVL , ALT , ALB , SEMIS , R ,
     &                  ASS , XDUM , N1 , N2 , N3 , NSUB , DB , DG ,
     &                  DX , PTYPE , KMAX , KMIN, I , J , PYRM)
C
           IF (FEROS .EQ. 1) THEN
              CALL ABLREC (J , I , TREC , ISTATE , NVL , ALT , ALB ,
     &                     CER , DSN , N3 , N2 , N1 , DB , DG , DX ,
     &                     AL , PTYPE , ASS , SEMIS , R , XDUM ,
     &                     ALPH , KMAX , AR , MOXI , TCSUB , FOXID ,
     &                     FCHSUB , POSS , CR)
           END IF
C
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL CHABLCONE
#
$MODEL CHABLSPHERE
#
#  ABLAT : charring ablation of primitive SPHERE
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = %SIDE%;      # active surface
PTYPE  = 5;           # primitive type : 5 = sphere
ABLTYP = 1;           # ablation type  : 1 = charring ablation
PYRM   = %PYRMOD%;    # ablation model (1:dens/temp-function, 2:Arrhenius)
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision of latitude range
N3     = %NODES3%;    # subdivision of ablative layer
NSUB   = %NSUB%;      # number of subnodes in one cell
GASMOD = %GASMOD%;    # gas flow model (1:fissure, 2:equilib.)
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
FEROS  = %FEROS%;     # flag for char erosion      (0:no, 1:erosion)
FOXID  = %FOXID%;     # flag for eroded char oxid. (0:no, 1:yes)
FCHSUB = %FCHSUB%;    # flag for char sublimation  (0:no, 1:yes)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
KMAX   = 0;           # node number of pyrolysis zone start
KMIN   = 0;           # node number of pyrolysis zone end
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %LONGMX%;    # dimensional range in NODES1-direction
DB     = 0.0D+00;     # dimensional range in NODES2-direction (set up in $init)
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = %RADIUS%;    # radius of sphere
BMIN   = %LATMIN%;    # dimensional offset in NODES2-direction
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
EPSC   = %EPSC%;      # char IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
TCHAR  = %TCHAR%;     # ablation end temperature
TREC   = %TREC%;      # char erosion start temperature
TCSUB  = %TCSUB%;     # char sublimation temperature
BBCON  = %BBCON%;     # reaction rate for Arrhenius function
ERCON  = %ERCON%;     # activation energy/general gas const
NNCON  = %NNCON%;     # reaction order for Arrhenius function
DEVRHO = %DEVRHO%;    # density deviation
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HCSUB  = %HCSUB%;     # latent heat of char sublimation
HOXID  = %HOXID%;     # latent heat of char oxidation
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
MOXI(%NODES2%,%NODES1%) = U;          # mass flux of oxidation or sublimation
POSC(%NODES2%,%NODES1%) = U;          # position of pyrolysis start
POSV(%NODES2%,%NODES1%) = U;          # position of pyrolysis end
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
SVOT(%NODES3%,%NSUB%)   = U;          # subnodal top half volume
SVOB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half volume
SALT(%NODES3%,%NSUB%)   = U;          # subnodal top half A/l-value
SALB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half A/l-value
SRHO(%NODES3%,%NSUB%)   = U;          # density at subnodes
SCP(%NODES3%,%NSUB%)    = U;          # spec. heat at subnodes
SLAMDA(%NODES3%,%NSUB%) = U;          # conductivity at subnodes
TSUB(%NODES3%,%NSUB%)   = U;          # temperatures at subnodes
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
MGAS(%NODES3%,%NODES2%,%NODES1%)   = U; # mass flux of pyrolysis gas
MGASST(%NODES3%,%NODES2%,%NODES1%) = U; # 2nd storage for gas mass flux
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
CR(2,2) = %RHOC%;                     # char density
CL(2,2) = %LAMBDC%;                   # char conductivity
CC(2,2) = %CPC%;                      # char specific heat
CER(2,1) = %ERATE%;                   # char erosion rate
VCGAS(2,1) = %CPGAS%;                 # spec. heat of pyrolysis gas
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I , J , K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
      DB = %LATMAX%-%LATMIN%
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DTR * DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
      BMIN = BMIN * DTR
C
C initialize surface depth array and others
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J , I) = DX * 0.5
            MOXI(J , I) = XDUM
            POSV(J , I) = XDUM
            POSC(J , I) = XDUM
            POSS(J , I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3 , J , I) = 11
            ISTATE(N3 - 1 , J , I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K , J , I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1 , J , I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE , CTYPE , K , J , I , KMAX , KMIN ,
     &                     N1 , N2 , N3 , NSUB , ASS , DG , DB , DX ,
     &                     SEMIS , R , BMIN , XDUM , ISTATE , DSN ,
     &                     NVL , ALT , ALB , SVOT , SVOB , SALT , SALB)
               MGAS(K , J , I) = XDUM
               MGASST(K , J , I) = XDUM
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C compute material properties at beginn of computation
C
      IF (PYRM .EQ. 2) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL, AC, NNSM)
      END IF
C
$VARIABLES1
C
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN , PROPS:ARTIME ,
     &                                PROPS:AQ0101 + KK - 1 , 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      IF (PYRM .EQ. 1) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL , AC , NNSM)
      END IF
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3 , ABLTYP , ISTATE , AR , AL , AC , NVL , ALT ,
     &             ALB , NNSM , MGAS , HABL , VCGAS , GASMOD)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J , I , BLKEFF , HW , HR , N1 , N2 , N3 ,
     &                   MGAS , FBLOCK , FBLOW , HREF , ISTATE ,
     &                   MOXI , FOXID , FCHSUB , HOXID , HCSUB)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLSUB (ISTATE , AL , AR , AC , ALT , ALB , MGAS ,
     &                  MGASST , NVL , N1 , N2 , N3 , TSUB , TCHAR ,
     &                  TABL , VR , VL , VC , SRHO , SCP , SLAMDA ,
     &                  CR , CL , CC , NSUB , KMAX , KMIN , I , J ,
     &                  BBCON , ERCON , NNCON , DEVRHO , PYRM ,
     &                  EPSC , DSN , DX , POSV , POSC , SEMIS)
C
           CALL ABLINT (ISTATE , AR , AL , AC , SRHO , SCP , SLAMDA ,
     &                  MGAS , MGASST , SVOT , SVOB , SALT , SALB ,
     &                  DSN , XDUM , NVL , ALT , ALB , SEMIS , R ,
     &                  ASS , BMIN , N1 , N2 , N3 , NSUB , DB , DG ,
     &                  DX , PTYPE , KMAX , KMIN, I , J , PYRM)
C
           IF (FEROS .EQ. 1) THEN
              CALL ABLREC (J , I , TREC , ISTATE , NVL , ALT , ALB ,
     &                     CER , DSN , N3 , N2 , N1 , DB , DG , DX ,
     &                     AL , PTYPE , ASS , SEMIS , R , BMIN ,
     &                     XDUM , KMAX , AR , MOXI , TCSUB , FOXID ,
     &                     FCHSUB , POSS , CR)
           END IF
C
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL CHABLSPHERE
#
$MODEL CHABLPARABOLOID
#
#  ABLAT : charring ablation of primitive PARABOLOID
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = 1;           # active surface : 1 = outside
PTYPE  = 6;           # primitive type : 6 = paraboloid
ABLTYP = 1;           # ablation type  : 1 = charring ablation
PYRM   = %PYRMOD%;    # ablation model (1:dens/temp-function, 2:Arrhenius)
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in axial direction
N3     = %NODES3%;    # subdivision of ablative layer
NSUB   = %NSUB%;      # number of subnodes in one cell
GASMOD = %GASMOD%;    # gas flow model (1:fissure, 2:equilib.)
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
FEROS  = %FEROS%;     # flag for char erosion      (0:no, 1:erosion)
FOXID  = %FOXID%;     # flag for eroded char oxid. (0:no, 1:yes)
FCHSUB = %FCHSUB%;    # flag for char sublimation  (0:no, 1:yes)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
KMAX   = 0;           # node number of pyrolysis zone start
KMIN   = 0;           # node number of pyrolysis zone end
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = 0.0D+00;     # dimensional range in NODES2-direction (set up in $init)
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = 0.0D+00;     # dummy real value
ALPH   = %FLENG%;     # distance between apex and focus
BMIN   = %HMIN%;      # dimensional offset in NODES2-direction
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
EPSC   = %EPSC%;      # char IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
TCHAR  = %TCHAR%;     # ablation end temperature
TREC   = %TREC%;      # char erosion start temperature
TCSUB  = %TCSUB%;     # char sublimation temperature
BBCON  = %BBCON%;     # reaction rate for Arrhenius function
ERCON  = %ERCON%;     # activation energy/general gas const
NNCON  = %NNCON%;     # reaction order for Arrhenius function
DEVRHO = %DEVRHO%;    # density deviation
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HCSUB  = %HCSUB%;     # latent heat of char sublimation
HOXID  = %HOXID%;     # latent heat of char oxidation
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
MOXI(%NODES2%,%NODES1%) = U;          # mass flux of oxidation or sublimation
POSC(%NODES2%,%NODES1%) = U;          # position of pyrolysis start
POSV(%NODES2%,%NODES1%) = U;          # position of pyrolysis end
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
SVOT(%NODES3%,%NSUB%)   = U;          # subnodal top half volume
SVOB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half volume
SALT(%NODES3%,%NSUB%)   = U;          # subnodal top half A/l-value
SALB(%NODES3%,%NSUB%)   = U;          # subnodal bottom half A/l-value
SRHO(%NODES3%,%NSUB%)   = U;          # density at subnodes
SCP(%NODES3%,%NSUB%)    = U;          # spec. heat at subnodes
SLAMDA(%NODES3%,%NSUB%) = U;          # conductivity at subnodes
TSUB(%NODES3%,%NSUB%)   = U;          # temperatures at subnodes
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
MGAS(%NODES3%,%NODES2%,%NODES1%)   = U; # mass flux of pyrolysis gas
MGASST(%NODES3%,%NODES2%,%NODES1%) = U; # 2nd storage for gas mass flux
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
CR(2,2) = %RHOC%;                     # char density
CL(2,2) = %LAMBDC%;                   # char conductivity
CC(2,2) = %CPC%;                      # char specific heat
CER(2,1) = %ERATE%;                   # char erosion rate
VCGAS(2,1) = %CPGAS%;                 # spec. heat of pyrolysis gas
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I , J , K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
      DB  = %HMAX%-%HMIN%
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array and others
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J , I) = DX * 0.5
            MOXI(J , I) = XDUM
            POSV(J , I) = XDUM
            POSC(J , I) = XDUM
            POSS(J , I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3 , J , I) = 11
            ISTATE(N3 - 1 , J , I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K , J , I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1 , J , I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE , CTYPE , K , J , I , KMAX , KMIN ,
     &                     N1 , N2 , N3 , NSUB , ASS , DG , DB , DX ,
     &                     SEMIS , R , BMIN , ALPH , ISTATE , DSN ,
     &                     NVL , ALT , ALB , SVOT , SVOB , SALT , SALB)
               MGAS(K , J , I) = XDUM
               MGASST(K , J , I) = XDUM
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C compute material properties at beginn of computation
C
      IF (PYRM .EQ. 2) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL, AC, NNSM)
      END IF
C
$VARIABLES1
C
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN , PROPS:ARTIME ,
     &                                PROPS:AQ0101 + KK - 1 , 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      IF (PYRM .EQ. 1) THEN
         CALL ABLPRO (ABLTYP , ISTATE , VR , VL , VC , CR , CL , CC ,
     &                AR , AL , AC , NNSM)
      END IF
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3 , ABLTYP , ISTATE , AR , AL , AC , NVL , ALT ,
     &             ALB , NNSM , MGAS , HABL , VCGAS , GASMOD)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J , I , BLKEFF , HW , HR , N1 , N2 , N3 ,
     &                   MGAS , FBLOCK , FBLOW , HREF , ISTATE ,
     &                   MOXI , FOXID , FCHSUB , HOXID , HCSUB)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLSUB (ISTATE , AL , AR , AC , ALT , ALB , MGAS ,
     &                  MGASST , NVL , N1 , N2 , N3 , TSUB , TCHAR ,
     &                  TABL , VR , VL , VC , SRHO , SCP , SLAMDA ,
     &                  CR , CL , CC , NSUB , KMAX , KMIN , I , J ,
     &                  BBCON , ERCON , NNCON , DEVRHO , PYRM ,
     &                  EPSC , DSN , DX , POSV , POSC , SEMIS)
C
           CALL ABLINT (ISTATE , AR , AL , AC , SRHO , SCP , SLAMDA ,
     &                  MGAS , MGASST , SVOT , SVOB , SALT , SALB ,
     &                  DSN , ALPH , NVL , ALT , ALB , SEMIS , R ,
     &                  ASS , BMIN , N1 , N2 , N3 , NSUB , DB , DG ,
     &                  DX , PTYPE , KMAX , KMIN, I , J , PYRM)
C
           IF (FEROS .EQ. 1) THEN
              CALL ABLREC (J , I , TREC , ISTATE , NVL , ALT , ALB ,
     &                     CER , DSN , N3 , N2 , N1 , DB , DG , DX ,
     &                     AL , PTYPE , ASS , SEMIS , R , BMIN ,
     &                     ALPH , KMAX , AR , MOXI , TCSUB , FOXID ,
     &                     FCHSUB , POSS , CR)
           END IF
C
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL CHABLPARABOLOID
#
$MODEL NCHABLQUADRILATERAL
#
#  ABLAT : non-charring ablation of primitive QUADRILATERAL
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = 1;           # active surface : 1 = outside
PTYPE  = 1;           # primitive type : 1 = quadrilateral
ABLTYP = 0;           # ablation type  : 0 = non-charring ablation
N1     = %NODES1%;    # subdivision in y-direction
N2     = %NODES2%;    # subdivision in x-direction
N3     = %NODES3%;    # subdivision of ablative layer
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
IDUM   = 1;           # dummy integer value used in case of undefined param
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %YMAX%;      # dimensional range in NODES1-direction
DB     = %XMAX%;      # dimensional range in NODES2-direction
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = 0.0D+00;     # dummy real value
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I, J, K, CTYPE
C
C scale dimensional ranges
C
      DG = DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J, I) = DX * 0.5
            POSS(J, I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3, J, I) = 11
            ISTATE(N3 - 1, J, I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K, J, I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1, J, I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE, CTYPE, K, J, I, IDUM, IDUM,
     &                     N1, N2, N3, IDUM, ASS, DG, DB, DX,
     &                     SEMIS, XDUM, XDUM, XDUM, ISTATE, DSN,
     &                     NVL, ALT, ALB, IDUM, IDUM, IDUM, IDUM)
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES1
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN, PROPS:ARTIME,
     &                                PROPS:AQ0101 + KK - 1, 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      CALL ABLPRO (ABLTYP, ISTATE, VR, VL, VC, VR, VL, VC,
     &             AR, AL, AC, NNSM)
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3, ABLTYP, ISTATE, AR, AL, AC, NVL, ALT,
     &             ALB, NNSM, IDUM, HABL, IDUM, IDUM)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J, I, BLKEFF, HW, HR, N1, N2, N3,
     &                   IDUM, FBLOCK, FBLOW, HREF, ISTATE,
     &                   IDUM, IDUM, IDUM, XDUM, XDUM)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLMLT (J, I, ISTATE, NVL, ALT, ALB, DSN, N3,
     &                  N2, N1, DB, DG, DX, AL, PTYPE, ASS,
     &                  SEMIS, XDUM, XDUM, XDUM, HABL, TABL,
     &                  AR, POSS)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL NCHABLQUADRILATERAL
#
$MODEL NCHABLDISC
#
#  ABLAT : non-charring ablation of primitive DISC
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = 1;           # active surface : 1 = outside
PTYPE  = 2;           # primitive type : 2 = disc
ABLTYP = 0;           # ablation type  : 0 = non-charring ablation
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in radial direction
N3     = %NODES3%;    # subdivision of ablative layer
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
IDUM   = 1;           # dummy integer value used in case of undefined param
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = %RMAX%;      # dimensional range in NODES2-direction
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = 0.0D+00;     # dummy real value
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I, J, K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J, I) = DX * 0.5
            POSS(J, I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3, J, I) = 11
            ISTATE(N3 - 1, J, I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K, J, I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1, J, I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE, CTYPE, K, J, I, IDUM, IDUM,
     &                     N1, N2, N3, IDUM, ASS, DG, DB, DX,
     &                     SEMIS, XDUM, XDUM, XDUM, ISTATE, DSN,
     &                     NVL, ALT, ALB, IDUM, IDUM, IDUM, IDUM)
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES1
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN, PROPS:ARTIME,
     &                                PROPS:AQ0101 + KK - 1, 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      CALL ABLPRO (ABLTYP, ISTATE, VR, VL, VC, VR, VL, VC,
     &             AR, AL, AC, NNSM)
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3, ABLTYP, ISTATE, AR, AL, AC, NVL, ALT,
     &             ALB, NNSM, IDUM, HABL, IDUM, IDUM)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J, I, BLKEFF, HW, HR, N1, N2, N3,
     &                   IDUM, FBLOCK, FBLOW, HREF, ISTATE,
     &                   IDUM, IDUM, IDUM, XDUM, XDUM)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLMLT (J, I, ISTATE, NVL, ALT, ALB, DSN, N3,
     &                  N2, N1, DB, DG, DX, AL, PTYPE, ASS,
     &                  SEMIS, XDUM, XDUM, XDUM, HABL, TABL,
     &                  AR, POSS)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL NCHABLDISC
#
$MODEL NCHABLCYLINDER
#
#  ABLAT : non-charring ablation of primitive CYLINDER
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = %SIDE%;      # active surface
PTYPE  = 3;           # primitive type : 3 = cylinder
ABLTYP = 0;           # ablation type  : 0 = non-charring ablation
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in axial direction
N3     = %NODES3%;    # subdivision of ablative layer
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
IDUM   = 1;           # dummy integer value used in case of undefined param
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = %HMAX%;      # dimensional range in NODES2-direction
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = %RADIUS%;    # radius of cylinder
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I, J, K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J, I) = DX * 0.5
            POSS(J, I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3, J, I) = 11
            ISTATE(N3 - 1, J, I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K, J, I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1, J, I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE, CTYPE, K, J, I, IDUM, IDUM,
     &                     N1, N2, N3, IDUM, ASS, DG, DB, DX,
     &                     SEMIS, R, XDUM, XDUM, ISTATE, DSN,
     &                     NVL, ALT, ALB, IDUM, IDUM, IDUM, IDUM)
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES1
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN, PROPS:ARTIME,
     &                                PROPS:AQ0101 + KK - 1, 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      CALL ABLPRO (ABLTYP, ISTATE, VR, VL, VC, VR, VL, VC,
     &             AR, AL, AC, NNSM)
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3, ABLTYP, ISTATE, AR, AL, AC, NVL, ALT,
     &             ALB, NNSM, IDUM, HABL, IDUM, IDUM)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J, I, BLKEFF, HW, HR, N1, N2, N3,
     &                   IDUM, FBLOCK, FBLOW, HREF, ISTATE,
     &                   IDUM, IDUM, IDUM, XDUM, XDUM)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLMLT (J, I, ISTATE, NVL, ALT, ALB, DSN, N3,
     &                  N2, N1, DB, DG, DX, AL, PTYPE, ASS,
     &                  SEMIS, R, XDUM, XDUM, HABL, TABL,
     &                  AR, POSS)
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL NCHABLCYLINDER
#
$MODEL NCHABLCONE
#
#  ABLAT : non-charring ablation of primitive CONE
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = %SIDE%;      # active surface
PTYPE  = 4;           # primitive type : 4 = cone
ABLTYP = 0;           # ablation type  : 0 = non-charring ablation
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in axial direction
N3     = %NODES3%;    # subdivision of ablative layer
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
IDUM   = 1;           # dummy integer value used in case of undefined param
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = 0.0D+00;     # dimensional range in NODES2-direction (set up in $init)
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = %HMIN%;      # min. base radius when multipl. with tan(alph)
ALPH   = %SEMANG%;    # half cone opening angle
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I, J, K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
      DB = %HMAX% - %HMIN%
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
      ALPH = DTR * ALPH
      R = R * TAN(ALPH)
C
C initialize surface depth array
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J, I) = DX * 0.5
            POSS(J, I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3, J, I) = 11
            ISTATE(N3 - 1, J, I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K, J, I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1, J, I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE, CTYPE, K, J, I, IDUM, IDUM,
     &                     N1, N2, N3, IDUM, ASS, DG, DB, DX,
     &                     SEMIS, R, XDUM, ALPH, ISTATE, DSN,
     &                     NVL, ALT, ALB, IDUM, IDUM, IDUM, IDUM)
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES1
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN, PROPS:ARTIME,
     &                                PROPS:AQ0101 + KK - 1, 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      CALL ABLPRO (ABLTYP, ISTATE, VR, VL, VC, VR, VL, VC,
     &             AR, AL, AC, NNSM)
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3, ABLTYP, ISTATE, AR, AL, AC, NVL, ALT,
     &             ALB, NNSM, IDUM, HABL, IDUM, IDUM)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J, I, BLKEFF, HW, HR, N1, N2, N3,
     &                   IDUM, FBLOCK, FBLOW, HREF, ISTATE,
     &                   IDUM, IDUM, IDUM, XDUM, XDUM)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLMLT (J, I, ISTATE, NVL, ALT, ALB, DSN, N3,
     &                  N2, N1, DB, DG, DX, AL, PTYPE, ASS,
     &                  SEMIS, R, XDUM, ALPH, HABL, TABL,
     &                  AR, POSS)
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL NCHABLCONE
#
$MODEL NCHABLSPHERE
#
#  ABLAT : non-charring ablation of primitive SPHERE
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = %SIDE%;      # active surface
PTYPE  = 5;           # primitive type : 5 = sphere
ABLTYP = 0;           # ablation type  : 0 = non-charring ablation
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision of latitude range
N3     = %NODES3%;    # subdivision of ablative layer
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
IDUM   = 1;           # dummy integer value used in case of undefined param
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %LONGMX%;    # dimensional range in NODES1-direction
DB     = 0.0D+00;     # dimensional range in NODES2-direction (set up in $init)
DX     = %THICK%;     # dimensional range in NODES3-direction
BMIN   = %LATMIN%;    # dimensional offset in NODES2-direction
R      = %RADIUS%;    # radius of sphere
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I, J, K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
      DB = %LATMAX%-%LATMIN%
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DTR * DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
      BMIN = BMIN * DTR
C
C initialize surface depth array
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J, I) = DX * 0.5
            POSS(J, I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3, J, I) = 11
            ISTATE(N3 - 1, J, I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K, J, I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1, J, I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE, CTYPE, K, J, I, IDUM, IDUM,
     &                     N1, N2, N3, IDUM, ASS, DG, DB, DX,
     &                     SEMIS, R, BMIN, XDUM, ISTATE, DSN,
     &                     NVL, ALT, ALB, IDUM, IDUM, IDUM, IDUM)
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES1
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN, PROPS:ARTIME,
     &                                PROPS:AQ0101 + KK - 1, 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      CALL ABLPRO (ABLTYP, ISTATE, VR, VL, VC, VR, VL, VC,
     &             AR, AL, AC, NNSM)
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3, ABLTYP, ISTATE, AR, AL, AC, NVL, ALT,
     &             ALB, NNSM, IDUM, HABL, IDUM, IDUM)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J, I, BLKEFF, HW, HR, N1, N2, N3,
     &                   IDUM, FBLOCK, FBLOW, HREF, ISTATE,
     &                   IDUM, IDUM, IDUM, XDUM, XDUM)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLMLT (J, I, ISTATE, NVL, ALT, ALB, DSN, N3,
     &                  N2, N1, DB, DG, DX, AL, PTYPE, ASS,
     &                  SEMIS, R, BMIN, XDUM, HABL, TABL,
     &                  AR, POSS)
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL NCHABLSPHERE
#
$MODEL NCHABLPARABOLOID
#
#  ABLAT : non-charring ablation of primitive PARABOLOID
#
$NODES
#
# Node Definition
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3% DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
DKL6 = %LABEL%, T = %TINIT%, C = 0.0, A = 0.0, QI = 0.0, QR = 0.0;
END DO
END DO
END DO
#
$CONDUCTORS
#
# Definition of Linear Conductor Network
#
FOR KL1=1 TO %NODES1% DO
FOR KL2=1 TO %NODES2% DO
FOR KL3=1 TO %NODES3%-1 DO
KL6 = 10000 * KL1 + 100 * KL2 + KL3;
KL7 = KL6 + 1;
GL( KL6, KL7) = 0.0;
END DO
END DO
END DO
#
$CONSTANTS
#
$INTEGER
#
ASS    = 1;           # active surface : 1 = outside
PTYPE  = 6;           # primitive type : 6 = paraboloid
ABLTYP = 0;           # ablation type  : 0 = non-charring ablation
N1     = %NODES1%;    # subdivision in circumferential direction
N2     = %NODES2%;    # subdivision in axial direction
N3     = %NODES3%;    # subdivision of ablative layer
FBLOW  = %FBLOW%;     # blowing flag  (0:no, 1:active)
FBLOCK = %FBLOCK%;    # blocking flag (0:no, 1:exponential, 2:polynomial)
NNSM   = %NODES1% * %NODES2% * %NODES3%;  # number of nodes in primitive
IDUM   = 1;           # dummy integer value used in case of undefined param
#
$REAL
#
# for final definition of dimensional ranges see $INITIAL
#
DG     = %ANGMAX%;    # dimensional range in NODES1-direction
DB     = 0.0D+00;     # dimensional range in NODES2-direction (set up in $init)
DX     = %THICK%;     # dimensional range in NODES3-direction
R      = 0.0D+00;     # dummy real value
ALPH   = %FLENG%;     # distance between apex and focus
BMIN   = %HMIN%;      # dimensional offset in NODES2-direction
XDUM   = 0.0D+00;     # dummy real value used in case of undefined param
SEMIS  = %EPSV%;      # IR emissivity
HABL   = %HABL%;      # latent heat of ablation
TABL   = %TABL%;      # ablation start temperature
BLKEFF = %BLKEFF%;    # transpiration cooling coefficient
HREF   = %HREF%;      # refenece enthalpy
#
$ARRAYS
#
$INTEGER
#
ISTATE(%NODES3%,%NODES2%,%NODES1%) = U; # info of nodal state and position
#
$REAL
#
DSN(%NODES2%,%NODES1%)  = U;          # depth of surface node
POSS(%NODES2%,%NODES1%) = U;          # actual thickness of layer
NVL(%NODES3%,%NODES2%,%NODES1%) = U;  # nodal volume
ALT(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for top half
ALB(%NODES3%,%NODES2%,%NODES1%) = U;  # A/l-values for bottom half
AR(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual density values
AL(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual conductivity values
AC(%NODES3%,%NODES2%,%NODES1%)  = U;  # actual specific heat values
#
VR(2,1) = %RHOV%;                     # virgin density
VL(2,1) = %LAMBDV%;                   # virgin conductivity
VC(2,1) = %CPV%;                      # virgin specific heat
HW(2,1) = %HWALL%;                    # outer gas enthalpy vs wall temp
HR(2,1) = %HRECOV%;                   # recovery enthalpy
#
$SUBROUTINES
#
$INITIAL
C
      INTEGER I, J, K, CTYPE
      DOUBLE PRECISION DTR
C
      DTR = 1.7453292D-02
      DB = %HMAX%-%HMIN%
C
C scale dimensional ranges
C
      DG = DTR * DG / DBLE(N1)
      DB = DB / DBLE(N2)
      DX = DX / DBLE(N3 - 1)
C
C initialize surface depth array
C
      I  = 1
      REPEAT
         J  = 1
         REPEAT
            DSN(J, I) = DX * 0.5
            POSS(J, I) = %THICK%
            J  = J + 1
         UNTIL(J .GT. N2)
         I  = I + 1
      UNTIL(I .GT. N1)
C
C initialize ISTATE ( 11 = virgin material, surface node,
C                     12 = virgin material, node next to surface
C                     13 = virgin material, inner node
C                     14 = virgin material, node at rear end )
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            ISTATE(N3, J, I) = 11
            ISTATE(N3 - 1, J, I) = 12
            K = N3 - 2
            REPEAT
               ISTATE(K, J, I) = 13
               K = K - 1
            UNTIL(K .EQ. 1)
            ISTATE(1, J, I) = 14
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
C initialize geometrical parameters (volume, A/l) and gas rate
C
      CTYPE = 1
      I = 1
      REPEAT
         J = 1
         REPEAT
            K = 1
            REPEAT
               CALL ABLGEO (PTYPE, CTYPE, K, J, I, IDUM, IDUM,
     &                     N1, N2, N3, IDUM, ASS, DG, DB, DX,
     &                     SEMIS, R, BMIN, ALPH, ISTATE, DSN,
     &                     NVL, ALT, ALB, IDUM, IDUM, IDUM, IDUM)
               K = K + 1
            UNTIL(K .GT. N3)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES1
C
      INTEGER I, J, KK
C
C interpolate convective heat input and assign values to surface nodes
C
      IF (PROPS:TYPFLG .EQ. 1) THEN
         KK = 1
         I = 1
         REPEAT
            J = 1
            REPEAT
               QR10101(KK * N3 - 1) = INTERP(TIMEN, PROPS:ARTIME,
     &                                PROPS:AQ0101 + KK - 1, 1)
               KK = KK + 1
               J = J + 1
            UNTIL(J .GT. N2)
            I = I + 1
         UNTIL(I .GT. N1)
      ELSE IF (PROPS:TYPFLG .EQ. 2) THEN
C
C interpolation of time & temperature depentent QCONV not yet implemented
C
      END IF
C
C update temperature dependent material properties (only if PYRMOD = 1)
C
      CALL ABLPRO (ABLTYP, ISTATE, VR, VL, VC, VR, VL, VC,
     &             AR, AL, AC, NNSM)
C
C use new properties to update nodal entities and linear conductors
C
      CALL ABLCOF (N3, ABLTYP, ISTATE, AR, AL, AC, NVL, ALT,
     &             ALB, NNSM, IDUM, HABL, IDUM, IDUM)
C
C correct convective heat input according to blowing and blockage
C
      I = 1
      REPEAT
         J = 1
         REPEAT
            CALL ABLQRM (J, I, BLKEFF, HW, HR, N1, N2, N3,
     &                   IDUM, FBLOCK, FBLOW, HREF, ISTATE,
     &                   IDUM, IDUM, IDUM, XDUM, XDUM)
            J = J + 1
         UNTIL(J .GT. N2)
         I = I + 1
      UNTIL(I .GT. N1)
C
$VARIABLES2
C
C
      INTEGER I, J
C
C skip all statements if MODULE is not SLFWBK
C
      IF (MODULE .EQ. 'SLFWBK') THEN
C
C determine range of pyrolysis zone and subdivide zone into subnodes,
C calculate properties for subnodes and then integrate over cells
C
      I = 1
      REPEAT
         J = 1
         REPEAT
           CALL ABLMLT (J, I, ISTATE, NVL, ALT, ALB, DSN, N3,
     &                  N2, N1, DB, DG, DX, AL, PTYPE, ASS,
     &                  SEMIS, R, BMIN, ALPH, HABL, TABL,
     &                  AR, POSS)
           J = J + 1
        UNTIL(J .GT. N2)
        I = I + 1
      UNTIL(I .GT. N1)
C
      CALL ABLSPT
C
      END IF
C
$ENDMODEL NCHABLPARABOLOID
